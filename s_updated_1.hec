import os, platform, psutil, getpass
import subprocess
import time
import numpy as np
import pandas as pd
import xlwings as xw
import plotly.graph_objects as go
import plotly.io as pio
from pyNastran.bdf.bdf import read_bdf
from pyNastran.bdf.mesh_utils import free_edges
import re
import warnings
warnings.filterwarnings('ignore')


# =============================================================================
# HELPERS
# =============================================================================

def my_read_bdf(path):
    try:
        try: bdf=read_bdf(path,punch=True,xref=True)
        except: bdf=read_bdf(path,punch=True,xref=False)
    except:
        try: bdf=read_bdf(path,punch=False,xref=True)
        except: bdf=read_bdf(path,punch=False,xref=False)
    return bdf


def plot_free_edges(bdf):
    """Plot lines connecting free edges in the mesh."""
    free_nodes = free_edges.non_paired_edges(bdf)
    x, y, z = [], [], []
    
    for node_pair in free_nodes:
        for nid in node_pair:
            node_coords = bdf.nodes[nid].xyz
            x.append(node_coords[0])
            y.append(node_coords[1])
            z.append(node_coords[2])
        # Add None to create breaks between line segments
        x.append(None)
        y.append(None)
        z.append(None)
    
    return go.Scatter3d(
        x=x, y=y, z=z, 
        mode='lines', 
        line=dict(color='rgba(50, 50, 50, 1)', width=8),  # Darker and thicker
        showlegend=False, 
        hoverinfo="none",
        name="free_edges",
        opacity=1  # Always fully opaque
    )

def add_js(fig,output_name):
    #DOES NOT WORK CONSISTENTLY, NEED TO MAKE SURE THAT IT WORKS
    script="""
    <script>
        document.addEventListener('DOMContentLoaded',function()) {
            var plotDiv = document.querySelector('.js-plotly-plot');
            
            if (plotDiv) {
                plotDiv.on('plotly_click', function(data)) {
                    if (data.event.shiftKey && data.points && data.points[0]) {
                        var pt = data.points[0];
                                
                        Plotly.relayout(plotDiv, {
                            'scene.camera.center': {
                                x: pt.x,
                                y: pt.y,
                                z: pt.z
                        }});
                    }
                }
            }
        }
    
    </script>
    """
    
    # html_content=fig.to_html(include_plotlyjs=True, full_html=True)
    html_content=fig.to_html()
    final_html = html_content.replace('<body>', script + '</body>')
    
    return final_html

    
def label_trace(bdf,coords):
    labels={"PID":[],"x":[],"y":[],"z":[],"text":[]}
    
    all_node_coords=[]
    for elid in coords["ELID"]:
        element=bdf.elements[elid]
        for nid in element.nodes:
            all_node_coords.append(np.array(bdf.nodes[nid.get_position()]))
    
    centroid=np.mean(all_node_coords,axis=0)
    labels["x"].append(centroid[0])
    labels["y"].append(centroid[1])
    labels["z"].append(centroid[2])
    
    trace=go.Scatter3d(x=labels["x"],y=labels["y"],z=labels["z"],
                       text=labels["text"],mode="markers+text",
                       marker=dict(color="red",size=5),
                       textposition="top center",
                       textfont=dict(size=16,color="red",family="Comics Bold"),
                       name="Property Labels",
                       visible=True,
                       customdata=labels["PID"],
                       showlegend=False,
                       hoverinfo="text")
    return trace


def project_onto(v, target):
    """
    this is for CBAR offsets,
    v: offset vector wa,wb
    target: normal vector of cbar
    """
    axis=np.array(target)
    v=np.array(v)
    axis_norm_sq=np.dot(axis,target)
    return np.dot(v,axis)/axis_norm_sq*target
    

def offset_cbar_elements(bdf,element,offset_distance):
    original_bars, left_offset_bars, right_offset_bars= [],[],[]
    n1,n2=element.nodes
    p1=np.array(bdf.nodes[n1].get_position())
    p2=np.array(bdf.nodes[n2].get_position())
    
    bar_vector=p2-p1
    bar_length=np.linalg.norm(bar_vector)
    bar_unit=bar_vector/bar_length
    
    
    if element.g0 is not None:
        g0_coord=np.array(bdf.nodes[element.g0].get_position())
        v_temp=g0_coord-p1
    else:
        v_temp=np.array(element.x)
    
    if element.wa is not None:
        wa,wb = element.wa, element.wb
    else:
        print("WARNING - Offset values are not found, taking arbitrary values.")
        wa,wb=np.array([0,0,0]),np.array([0,0,0])
        
    #make sure v_temp is not parallel to bar_unit
    if np.isclose(np.abs(np.dot(v_temp/np.linalg.norm(v_temp),bar_unit)),1.0):
        if not np.isclose(np.abs(bar_unit[0]),1.0):
            v_temp=np.array([1,0,0])
        else:
            v_temp=np.array([0,1,0])
    
    y_axis = np.cross(bar_unit,v_temp)
    y_axis = y_axis / np.linalg.norm(y_axis)
    
    z_axis = np.cross(bar_unit,y_axis)
    z_axis = z_axis / np.linalg.norm(z_axis)
    
    '''
    globalZ=np.array([0,0,1])
    sim_y_globalZ=np.dot(y_axis,globalZ)/(np.linalg.norm(y_axis) * np.linalg.norm(globalZ))
    sim_z_globalZ=np.dot(z_axis,globalZ)/(np.linalg.norm(z_axis) * np.linalg.norm(globalZ))
    
    if sim_y_globalZ>sim_z_globalZ:
        y_axis=z_axis
    '''
    y_axis=z_axis
    wa=project_onto(wa,y_axis)
    wb=project_onto(wa,y_axis)
    
    left_p1=p1+y_axis*offset_distance + wa
    left_p2=p2+y_axis*offset_distance + wb
    
    right_p1=p1-y_axis*offset_distance + wa
    right_p2=p2-y_axis*offset_distance + wb
    
    original_bars.append((p1,p2))
    left_offset_bars.append((left_p1,left_p2))
    right_offset_bars.append((right_p1,right_p2))
    
    return original_bars, left_offset_bars, right_offset_bars


# =============================================================================
# FASTENER PLOT    
# =============================================================================

def plot_fastener_points(bdf,fastener_df):
    # Create dictionaries to store data by diameter
    diameter_data = {}
    
    # Track unique fastener types
    fastener_types_set = set()
    elements=fastener_df["Element ID (PBARL)"].to_list()
    # elems=fastener_df["Property ID (PBARL)"].to_list()
    
    for elid in elements:
        # try:
        #     prop=bdf.properties[pid]
        #     elements=pid2eid[pid]
        # except:
        #     continue
        
        pid=bdf.elements[elid].pid
        if bdf.elements[elid].type == "CBAR":
            # Get fastener info
            fastener_info = fastener_df[fastener_df["Element ID (PBARL)"] == elid]
            fastener_type = fastener_info["Pin"].values[0]
            diameter = float(fastener_info["Diameter"].values[0])
            
            # Track fastener type
            fastener_types_set.add(fastener_type)
            
            # Initialize data structure for this diameter if needed
            if diameter not in diameter_data:
                diameter_data[diameter] = {}
            
            # Initialize data structure for this fastener type if needed
            if fastener_type not in diameter_data[diameter]:
                diameter_data[diameter][fastener_type] = {
                    "x": [], "y": [], "z": [], "pids": [], "elids":[]
                }
            
        # Calculate centroid for element
            # valid_nodes = [node for node in bdf.elements[elid].nodes if node is not None]
            valid_nodes=bdf.elements[elid].nodes
            if valid_nodes:
                x = sum(bdf.nodes[nid].xyz[0] for nid in valid_nodes) / len(valid_nodes)
                y = sum(bdf.nodes[nid].xyz[1] for nid in valid_nodes) / len(valid_nodes)
                z = sum(bdf.nodes[nid].xyz[2] for nid in valid_nodes) / len(valid_nodes)
                
                diameter_data[diameter][fastener_type]["x"].append(x)
                diameter_data[diameter][fastener_type]["y"].append(y)
                diameter_data[diameter][fastener_type]["z"].append(z)
                diameter_data[diameter][fastener_type]["pids"].append(pid)
                diameter_data[diameter][fastener_type]["elids"].append(elid)
    
    traces = []
    
    # Color map for different diameters
    colors = {
        4.17: "blue",
        4.78: "cyan",
        6.35: "lime",
        7.92: "darkgreen",
        9.53: "yellow",
        11.13: "orange",
        12.7: "red",
        14.3: "magenta",
        # Add more as needed
    }
    
    # Symbol map for different fastener types
    symbols = ['circle', 'square', 'x', 'diamond',
    'diamond-open', 'circle-open', 'square-open', 'cross']
    symbol_map = {}
    
    # Assign a different symbol to each fastener type
    for i, fastener_type in enumerate(sorted(fastener_types_set)):
        symbol_map[fastener_type] = symbols[i % len(symbols)]
    
    # print(f"Symbol mapping: {symbol_map}")
    
    for diameter, type_data in diameter_data.items():
        for fastener_type, data in type_data.items():
            if not data["x"]:  # Skip if no points
                continue
                
            trace = go.Scatter3d(
                x=data["x"],
                y=data["y"],
                z=data["z"],
                mode='markers',
                marker=dict(
                    size=diameter,  # Use diameter for size
                    color=colors.get(diameter, "gray"),
                    symbol=symbol_map[fastener_type],  # Use assigned symbol
                    opacity=1,
                    line=dict(width=1, color='rgba(0, 0, 0, 0.5)')
                ),
                name=f'√ò{diameter}mm ({fastener_type})',
                hovertemplate='<i>PBARL %{text}</i><br>Type: ' + fastener_type + '<br>Diameter: ' + str(diameter) + ' mm<extra></extra>',
                text=data["pids"],
                hoverinfo='none'  # This removes the default hover text
            )
            traces.append(trace)
    
    return traces


def fplot(bdf_file,excel_file):
    print("\nPLOTTING the TTB_fastener...\n")
    bdf=my_read_bdf(bdf_file)
    bdf_name=os.path.basename(bdf_file)
    pid2eid=bdf.get_property_id_to_element_ids_map()
    fastener_df=pd.read_excel(excel_file,sheet_name="JOINT")
    
    # Generate edge trace
    edge_trace = plot_free_edges(bdf)

    # Generate fastener traces
    fastener_traces = plot_fastener_points(bdf,fastener_df)

    # Combine all traces
    all_traces = [edge_trace] + fastener_traces

    # Create figure with all traces
    fig = go.Figure(data=all_traces)

    # Update layout with bigger legend and title
    fig.update_layout(
        scene=dict(
            aspectmode='data',
            xaxis=dict(visible=False),
            yaxis=dict(visible=False),
            zaxis=dict(visible=False)
        ),
        template="plotly_white",
        legend=dict(
            font=dict(size=16),  # Bigger font size for legend items
            # itemsizing="constant",  # Makes the legend items consistent size
            x=0.99,
            y=1.0,
        )
    )
    
    fig.update_layout(updatemenus=[dict(
      type="buttons",
      direction="right",
      active=0, #0,
      showactive=True,
      x=0.5,
      y=0.0,
      xanchor="center",
      yanchor="bottom",
      buttons=list(
        [
        dict(args=['template', pio.templates['plotly_white']], label="White Theme", method="relayout"),   
        dict(args=['template', pio.templates['plotly_dark']], label="Black Theme", method="relayout")
        ]
      ), 
      font=dict(color="black")
    )]) #ilginctir ama bu virg√ºl √∂nemli
    
    
    title=f"<b>{bdf_name}</b><br>Fastener representation"
        
    fig.update_layout(margin=dict(r=0,l=0,t=0,b=0),
                      title_text=title,title_x=0.003,title_y=0.98)
    
    os.chdir(os.path.dirname(excel_file))
    
    try:
        fig.write_html("TTB_fastener_plot.html",config={"displayModeBar":False})
        return 0
    except Exception as e:
        print(f"ERROR F-Plot: {e}")
        return 1
    
    # final_html = add_js(fig,"TTB_fastener_plot.html")
    # with open("TTB_fastener_plot.html", 'w', encoding='utf-8') as f:
        # f.write(final_html,config={"displayModeBar":False})
        # f.write(final_html)
        
    return 0


# =============================================================================
# SUMMARY PLOT
# =============================================================================

def extract_mesh_data(df, bdf):
    """Extract mesh data including nodes, faces, and all RF values dynamically."""
    coords = {'PID':[],'ELID':[],'x': [], 'y': [], 'z': [],
              'cx':[],'cy':[],'cz':[]}
    
    global pid_centroids
    pid_centroids={}
    node_id_to_idx={}
    current_idx=0
    
    edges_xyz = {'x': [], 'y': [], 'z': []}
    faces = {'i': [], 'j': [], 'k': []}
    hover_texts = []
    offset = 0
    
    df.rename(columns={"Min RF":"RF (min)", "RF min":"RF (min)", "RF min sized":"RF (min) sized"},inplace=True)
    excluded_columns = ['Property ID','Default Failure','Optimized Failure']
    
    try:
        df["Optimized Failur(E)"]=df["Optimized Failure"].astype('category').cat.codes
        df["Default Failur(E)"]=df["Default Failure"].astype('category').cat.codes
    except:
        pass
    
    
    # Get all columns except excluded ones
    intensity_columns = [col for col in df.columns if col not in excluded_columns]
    intensity_values = {col: [] for col in intensity_columns}
    
    for elid, element in bdf.elements.items():
        # Get property data
        pid = element.pid
        row = df[df['Property ID'] == pid]
        if row.empty:
            continue
        
        #addition
        coords['PID'].append(pid)
        coords['ELID'].append(elid)
        
        # Extract data for row
        rf_data = row.iloc[0]
        
        # Build hover info for all columns
        hover_info = []
        for col in df.columns:  # Include all columns in hover info
            if col in row.columns and col not in ['Property ID', 'LCID', 'Default Failur(E)', 'Optimized Failur(E)']:
                if col in ["RF (min)", "RF min"]:
                    try: hover_info.append(f"<b>‚ö´</b><br>{col}: {rf_data[col]:0.2f}")
                    except: hover_info.append(f"<b>‚ö´</b><br>{col}: {rf_data[col]}") #incase of string
                else:
                    try: hover_info.append(f"{col}: {rf_data[col]:0.2f}")
                    except: hover_info.append(f"{col}: {rf_data[col]}") #incase of string
            elif col=="Property ID":
                hover_info.append(f"PID: {rf_data[col]:0.0f}")
            elif col=="LCID":
                try: hover_info.append(f"{col}: {rf_data[col]:0.0f}<br><b>‚ö´</b>")
                except: hover_info.append(f"{col}: {rf_data[col]}<br><b>‚ö´</b>")
                # hover_info.append(f"__________________________")
                
        hover_text = "<br>".join(hover_info)
        
        
        # Add node coordinates
            # Add element edges and faces
        if element.type == 'CQUAD4':
            for nid in element.nodes:
                node_xyz = bdf.nodes[nid].xyz
                coords['x'].append(node_xyz[0])
                coords['y'].append(node_xyz[1])
                coords['z'].append(node_xyz[2])
                node_id_to_idx[nid]=current_idx
                current_idx+=1
                
                # Store intensity values for each column
                for col in intensity_columns:
                    intensity_values[col].append(rf_data[col])
                
                hover_texts.append(hover_text)
                if pid not in pid_centroids: pid_centroids[pid] = []
                pid_centroids[pid].append(node_xyz)
                
            # Add quad edges
            edges = [[offset, offset+1], [offset+1, offset+2], 
                     [offset+2, offset+3], [offset+3, offset]]
            
            # Add quad faces (two triangles)
            faces['i'].extend([offset, offset])
            faces['j'].extend([offset+1, offset+2])
            faces['k'].extend([offset+2, offset+3])
            offset += 4
                
        elif element.type == 'CTRIA3':
            for nid in element.nodes:
                node_xyz = bdf.nodes[nid].xyz
                coords['x'].append(node_xyz[0])
                coords['y'].append(node_xyz[1])
                coords['z'].append(node_xyz[2])
                node_id_to_idx[nid]=current_idx
                current_idx+=1
                
                # Store intensity values for each column
                for col in intensity_columns:
                    intensity_values[col].append(rf_data[col])
                
                hover_texts.append(hover_text)
                pid_centroids.setdefault(pid,[]).append(node_xyz)
                
            # Add triangle edges
            edges = [[offset, offset+1], [offset+1, offset+2], [offset+2, offset]]
            
            # Add triangle face
            faces['i'].append(offset)
            faces['j'].append(offset+1)
            faces['k'].append(offset+2)
            offset += 3
            
            
        elif element.type == "CBAR":
            try:
                prop=bdf.properties[pid]
                width=max(prop.dim)
            except:
                n1,n2=element.nodes
                p1=np.array(bdf.nodes[n1].get_position())
                p2=np.array(bdf.nodes[n2].get_position())
                bar_length=np.linalg.norm(p2-p1)
                width=bar_length*0.05
            
            original_bars,left_offset_bars,right_offset_bars = offset_cbar_elements(bdf,element,width/2)
            
            p1,p2=original_bars[0]
            left_p1,left_p2=left_offset_bars[0]
            right_p1,right_p2=right_offset_bars[0]
            
            all_points=[left_p1,right_p1,left_p2,right_p2]
            for point in all_points:
                coords["x"].append(point[0])
                coords["y"].append(point[1])
                coords["z"].append(point[2])
                
                # Store intensity values for each column
                for col in intensity_columns:
                    intensity_values[col].append(rf_data[col])
                
                hover_texts.append(hover_text)
                pid_centroids.setdefault(pid,[]).append((point[0],point[1],point[2]))
                
            edges = [[offset, offset+1], [offset+1, offset+3], 
                     [offset+3, offset+2], [offset+2, offset]]
            
            # Add quad faces (two triangles)
            faces['i'].extend([offset, offset+1])
            faces['j'].extend([offset+1, offset+3])
            faces['k'].extend([offset+2, offset+2])
            offset += 4
                
        # Store edges for plotting
        for edge in edges:
            for idx in range(2):
                node_idx = edge[idx]
                edges_xyz['x'].append(coords['x'][node_idx])
                edges_xyz['y'].append(coords['y'][node_idx])
                edges_xyz['z'].append(coords['z'][node_idx])
            # Add None to create a break between edges
            edges_xyz['x'].append(None)
            edges_xyz['y'].append(None)
            edges_xyz['z'].append(None)
    
    # ============================================================
    # CONVERT TO NUMPY ARRAYS WITH REDUCED PRECISION
    # ============================================================
    print(f"Converting coordinates to float32 for memory optimization...")
    
    # Convert coordinate lists to numpy arrays with float32
    coords['x'] = np.array(coords['x'], dtype=np.float32)
    coords['y'] = np.array(coords['y'], dtype=np.float32)
    coords['z'] = np.array(coords['z'], dtype=np.float32)
    
    # Convert edges to float32 (handle None values)
    edges_xyz['x'] = np.array(edges_xyz['x'], dtype=np.float32)
    edges_xyz['y'] = np.array(edges_xyz['y'], dtype=np.float32)
    edges_xyz['z'] = np.array(edges_xyz['z'], dtype=np.float32)
    
    # Convert faces to int32 (smaller than default int64)
    faces['i'] = np.array(faces['i'], dtype=np.int32)
    faces['j'] = np.array(faces['j'], dtype=np.int32)
    faces['k'] = np.array(faces['k'], dtype=np.int32)
    
    return coords, faces, edges_xyz, intensity_values, hover_texts, intensity_columns


def plot_coordinate_system(bdf, coords, offset_distance=None):
    """Plot X-Y-Z coordinate system axes at the model origin or offset location."""
    
    # Find the minimum coordinates to place axes at corner of model
    if offset_distance is None:
        x_min = np.min(coords['x'])-np.std(coords['x'])
        y_min = np.min(coords['y'])-np.std(coords['y'])
        z_min = np.min(coords['z'])-np.std(coords['z'])
    else:
        x_min = y_min = z_min = 0
    
    # Calculate axis length (10% of model size)
    x_range = np.max(coords['x']) - np.min(coords['x'])
    y_range = np.max(coords['y']) - np.min(coords['y'])
    z_range = np.max(coords['z']) - np.min(coords['z'])
    axis_length = max(x_range, y_range, z_range) * 0.05
    
    # X-axis (Red)
    x_axis = go.Scatter3d(
        x=[x_min, x_min + axis_length],
        y=[y_min, y_min],
        z=[z_min, z_min],
        mode='lines+text',
        line=dict(color='black', width=4),
        text=['', 'X'],
        textposition='top center',
        textfont=dict(size=12, color='black', family='Arial Black'),
        showlegend=False,
        hoverinfo='skip',
        name='X_axis'
    )
    
    # Y-axis (Green)
    y_axis = go.Scatter3d(
        x=[x_min, x_min],
        y=[y_min, y_min + axis_length],
        z=[z_min, z_min],
        mode='lines+text',
        line=dict(color='black', width=4),
        text=['', 'Y'],
        textposition='top center',
        textfont=dict(size=12, color='black', family='Arial Black'),
        showlegend=False,
        hoverinfo='skip',
        name='Y_axis'
    )
    
    # Z-axis (Blue)
    z_axis = go.Scatter3d(
        x=[x_min, x_min],
        y=[y_min, y_min],
        z=[z_min, z_min + axis_length],
        mode='lines+text',
        line=dict(color='black', width=4),
        text=['', 'Z'],
        textposition='top center',
        textfont=dict(size=12, color='black', family='Arial Black'),
        showlegend=False,
        hoverinfo='skip',
        name='Z_axis'
    )
    
    return [x_axis, y_axis, z_axis]

#redundant
def get_smart_colorscale(col, n_cats):
    """Select appropriate colorscale based on column name and category count"""
    
    # For failure modes - use semantic colors
    if 'failure' in col.lower() or 'fail' in col.lower():
        return [
            '#00FF00',  # Green - OK
            '#FFFF00',  # Yellow - Warning
            '#FFA500',  # Orange - Caution
            '#FF0000',  # Red - Critical
        ]
    
    # For stress/RF - use traffic light
    if 'rf' in col.lower() or 'stress' in col.lower():
        return [
            '#0000FF',  # Blue - Safe
            '#00FFFF',  # Cyan
            '#00FF00',  # Green
            '#FFFF00',  # Yellow
            '#FFA500',  # Orange
            '#FF0000',  # Red - Critical
        ]
    
    # Default: use full spectrum
    return [
        '#FF0000', '#0000FF', '#00FF00', '#FFA500', '#FF00FF', '#00FFFF',
        '#FFFF00', '#800080', '#FFC0CB', '#A52A2A', '#808080', '#000080',
        '#8B4513', '#2F4F4F', '#FF1493', '#00CED1', '#FF4500', '#DA70D6',
        '#32CD32', '#FFD700', '#4169E1', '#FF6347', '#40E0D0', '#EE82EE',
        '#F0E68C', '#90EE90', '#ADD8E6', '#F08080', '#E0FFFF', '#FAFAD2'
    ]

def create_mesh_visualization(df, coords, faces, edges_xyz, intensity_values, hover_texts, intensity_columns):
    """Create mesh visualization with dynamically generated intensity meshes and buttons."""
    mesh_traces = []
    centroids = {}
    
    removed_ones = ["SubcaseID", "Subcase ID"]
    for i in removed_ones: 
        try: intensity_columns.remove(i)
        except: pass
    
    # Create a mesh for each intensity column
    for i, col in enumerate(intensity_columns):
        
        # -----------------------------------------
        # Build centroids (only once per column)
        if col not in centroids:
            centroids[col] = {"cx": [], "cy": [], "cz": [], "t": [], "colors": [], "sizes": []}
            
            # Find max and min value PIDs for this column
            try:
                numeric_col = df[col].astype(float)
                max_idx = numeric_col.idxmax()
                min_idx = numeric_col.idxmin()
                max_pid = df.loc[max_idx, 'Property ID']
                min_pid = df.loc[min_idx, 'Property ID']
            except:
                max_pid = None
                min_pid = None
            
            for pid, coords_list in pid_centroids.items():
                row = df[df["Property ID"] == pid]
                if row.empty:
                    continue
                intensity_row = row.iloc[0]
                
                coords_arr = np.array(coords_list)
                centroids[col]["cx"].append(coords_arr[:, 0].mean())
                centroids[col]["cy"].append(coords_arr[:, 1].mean())
                centroids[col]["cz"].append(coords_arr[:, 2].mean())
                
                # Check if this is the max or min value element
                is_max = (pid == max_pid)
                is_min = (pid == min_pid)
                
                # Format text with marker if max/min
                try: 
                    text_val = f"{intensity_row[col]:0.2f}"
                except: 
                    text_val = f"{intensity_row[col]}"
                
                if is_max:
                    centroids[col]["t"].append(text_val)
                    centroids[col]["colors"].append("red")
                    centroids[col]["sizes"].append(16)
                elif is_min:
                    centroids[col]["t"].append(text_val)
                    centroids[col]["colors"].append("blue")
                    centroids[col]["sizes"].append(16)
                else:
                    centroids[col]["t"].append(text_val)
                    centroids[col]["colors"].append("black")
                    centroids[col]["sizes"].append(4)
        # -----------------------------------------
        
        # TREAT EVERYTHING AS CATEGORICAL/DISCRETE
        raw_values = intensity_values[col]
        
        # Try to convert to numeric and round, handling NaN/blank/N/A
        try:
            numeric_series = pd.to_numeric(pd.Series(raw_values), errors='coerce')
            if not numeric_series.isna().all():
                # Round to 2 decimal places, convert NaN to "N/A"
                rounded_values = []
                for v in numeric_series:
                    if pd.isna(v):
                        rounded_values.append("N/A")
                    else:
                        rounded_values.append(round(v, 2))
                processed_values = [str(v) for v in rounded_values]
            else:
                # Pure categorical - normalize NaN-like values
                processed_values = []
                for v in raw_values:
                    if pd.isna(v) or str(v).strip().lower() in ['nan', 'n/a', '', 'none', 'null']:
                        processed_values.append("N/A")
                    else:
                        processed_values.append(str(v))
        except:
            # Pure categorical - normalize NaN-like values
            processed_values = []
            for v in raw_values:
                if pd.isna(v) or str(v).strip().lower() in ['nan', 'n/a', '', 'none', 'null']:
                    processed_values.append("N/A")
                else:
                    processed_values.append(str(v))
        
        # Get unique categories - ensure N/A is always first (index 0 = gray)
        unique_cats_set = set(processed_values)
        if "N/A" in unique_cats_set:
            unique_cats = ["N/A"]  # N/A first
            unique_cats.extend([cat for cat in dict.fromkeys(processed_values) if cat != "N/A"])
        else:
            unique_cats = list(dict.fromkeys(processed_values))
        
        n_cats = len(unique_cats)
        
        # Info message for many categories
        if n_cats > 100:
            print(f"‚ÑπÔ∏è Column '{col}' has {n_cats} unique values. Using continuous gradient fallback.")
        elif n_cats > 50:
            print(f"‚ö†Ô∏è Column '{col}' has {n_cats} unique values. Colors will cycle.")
        
        # Create mapping from category to integer
        cat_to_int = {cat: idx for idx, cat in enumerate(unique_cats)}
        numeric_values = [cat_to_int[cat] for cat in processed_values]
        
        # ROBUST COLOR GENERATION: Generate colors procedurally
        def generate_distinct_colors(n, gray_for_na=True):
            """Generate n visually distinct colors using HSV color space"""
            colors = []
            
            if gray_for_na:
                colors.append('#808080')  # Gray for N/A
                n = n - 1  # Generate n-1 additional colors
            
            if n <= 0:
                return colors
            
            # Use golden ratio for hue distribution (maximizes distinction)
            golden_ratio = 0.618033988749895
            hue = 0
            
            for i in range(n):
                hue += golden_ratio
                hue %= 1.0
                
                # Vary saturation and value to increase distinctiveness
                saturation = 0.6 + (i % 3) * 0.15  # 0.6, 0.75, 0.9
                value = 0.7 + (i % 4) * 0.1       # 0.7, 0.8, 0.9, 1.0
                
                # Convert HSV to RGB
                import colorsys
                r, g, b = colorsys.hsv_to_rgb(hue, saturation, value)
                
                # Convert to hex
                hex_color = f'#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}'
                colors.append(hex_color)
            
            return colors
        
        # Generate colors based on number of categories
        if n_cats <= 30:
            # Use predefined palette for best aesthetics
            base_palette = [
                '#FF0000', '#0000FF', '#00FF00', '#FFA500', '#FF00FF', '#00FFFF',
                '#FFFF00', '#800080', '#FFC0CB', '#A52A2A', '#808080', '#000080',
                '#8B4513', '#2F4F4F', '#FF1493', '#00CED1', '#FF4500', '#DA70D6',
                '#32CD32', '#FFD700', '#4169E1', '#FF6347', '#40E0D0', '#EE82EE',
                '#F0E68C', '#90EE90', '#ADD8E6', '#F08080', '#E0FFFF', '#FAFAD2'
            ]
            
            distinct_colors = []
            for idx, cat in enumerate(unique_cats):
                if cat == "N/A":
                    distinct_colors.append('#808080')
                else:
                    color_idx = idx - 1 if "N/A" in unique_cats else idx
                    distinct_colors.append(base_palette[color_idx % len(base_palette)])
        
        elif n_cats <= 100:
            # Generate procedural colors for 30-100 categories
            distinct_colors = generate_distinct_colors(n_cats, gray_for_na=("N/A" in unique_cats))
        
        else:
            # For 100+ categories, use continuous gradient (fallback)
            print(f"   ‚Üí Using gradient colorscale for better performance")
            
            # Use a perceptually uniform colorscale
            if "N/A" in unique_cats:
                # Reserve gray for N/A, use gradient for rest
                import plotly.express as px
                gradient_colors = px.colors.sample_colorscale(
                    "Viridis", 
                    [i/(n_cats-1) for i in range(n_cats-1)]
                )
                distinct_colors = ['#808080'] + gradient_colors
            else:
                import plotly.express as px
                distinct_colors = px.colors.sample_colorscale(
                    "Viridis", 
                    [i/(n_cats-1) for i in range(n_cats)]
                )
        
        # Build DISCRETE colorscale with FLAT steps
        colorscale = []
        if n_cats == 1:
            colorscale = [[0, distinct_colors[0]], [1, distinct_colors[0]]]
        else:
            for idx in range(n_cats):
                color = distinct_colors[idx]
                lower_bound = idx / n_cats
                upper_bound = (idx + 1) / n_cats
                
                colorscale.append([lower_bound, color])
                colorscale.append([upper_bound, color])
        
        cmin = 0
        cmax = n_cats
        
        # ROBUST TICK SAMPLING - always readable
        def smart_tick_selection(n_cats, unique_cats, max_ticks=15):
            """Intelligently select which ticks to show"""
            tick_vals = []
            tick_text = []
            
            if n_cats <= max_ticks:
                # Show all
                return [i + 0.5 for i in range(n_cats)], unique_cats
            
            # Always include N/A if present
            if "N/A" in unique_cats:
                tick_vals.append(0.5)
                tick_text.append("N/A")
            
            # Calculate step size to get approximately max_ticks
            start_idx = 1 if "N/A" in unique_cats else 0
            remaining_cats = n_cats - start_idx
            step = max(1, remaining_cats // (max_ticks - 2))  # -2 for first/last
            
            # Sample evenly
            for idx in range(start_idx, n_cats - 1, step):
                if len(tick_vals) >= max_ticks - 1:  # Leave room for last
                    break
                tick_vals.append(idx + 0.5)
                tick_text.append(unique_cats[idx])
            
            # Always include last value
            if (n_cats - 1) != (tick_vals[-1] - 0.5 if tick_vals else -1):
                tick_vals.append(n_cats - 0.5)
                tick_text.append(unique_cats[-1])
            
            return tick_vals, tick_text
        
        # Select ticks based on number of categories
        max_ticks = 15 if n_cats < 50 else 10  # Fewer ticks for many categories
        tick_vals, tick_text = smart_tick_selection(n_cats, unique_cats, max_ticks)
        
        # Adjust font size based on number of ticks and categories
        if n_cats > 100:
            tick_font_size = 7
        elif n_cats > 50:
            tick_font_size = 8
        elif len(tick_vals) > 15:
            tick_font_size = 8
        else:
            tick_font_size = 10
        
        colorbar_config = dict(
            title=dict(text=col, side='right', font=dict(size=9)),
            tickmode='array',
            tickvals=tick_vals,
            ticktext=tick_text,
            len=0.82,
            thickness=15,
            x=1.02,
            tickfont=dict(size=tick_font_size),
            tickangle=0 if len(str(tick_text[0])) < 8 else -45  # Angle long labels
        )
        
        # Create mesh trace
        mesh = [
            go.Mesh3d(
                x=coords['x'], y=coords['y'], z=coords['z'],
                i=faces['i'], j=faces['j'], k=faces['k'],
                intensity=numeric_values,
                intensitymode='vertex',
                colorscale=colorscale,
                cmin=cmin,
                cmax=cmax,
                hoverlabel=dict(
                    bgcolor="rgba(0, 0, 55, 0.9)",
                    bordercolor="rgba(255, 255, 255, 0.8)",
                    font=dict(color="white", size=14, family="Segoe UI, Arial, sans-serif")
                ),
                colorbar=colorbar_config,
                opacity=1,
                lighting=dict(
                    ambient=1.0,
                    diffuse=0.0,
                    specular=0.0,
                    roughness=1.0,
                    fresnel=0.0
                ),
                flatshading=False,
                hovertemplate='%{text}<extra></extra>',
                text=hover_texts,
                visible=(i == 0),
                showlegend=False,
                name="",
                hoverinfo='text'
            ),
            
            go.Scatter3d(
                x=centroids[col]["cx"], 
                y=centroids[col]["cy"], 
                z=centroids[col]["cz"],
                mode="text+markers",
                text=centroids[col]["t"],
                textfont=dict(size=11, color=centroids[col]["colors"]),
                marker=dict(
                    color=centroids[col]["colors"],
                    symbol="diamond",
                    size=centroids[col]["sizes"]
                ),
                name="Labels ON/OFF",
                showlegend=True,
                hoverinfo="skip",
                visible=(i == 1),
                textposition="top center"
            )
        ]
        
        mesh_traces.extend(mesh)
    
    # Create edges trace
    edges_trace = go.Scatter3d(
        x=edges_xyz['x'], y=edges_xyz['y'], z=edges_xyz['z'],
        mode='lines',
        line=dict(color='black', width=1),
        hoverinfo="none",
        showlegend=False,
        name="edge_traces"
    )
    
    # Create buttons dynamically for each intensity column
    buttons = []
    for i, col in enumerate(intensity_columns):
        visible = [False] * len(intensity_columns) * 2
        visible[2*i] = True
        visible[2*i+1] = True
        # visible.extend([True, True])
        visible.extend([True, True, True, True])  # ‚úÖ edges + 3 coord axes
        
        label = col if len(col) <= 25 else col[:22] + "..."
        
        button = {
            'label': f'üìä {label}',
            'method': "update",
            'args': [{"visible": visible}],
            'args2': None
        }
        buttons.append(button)
    
    updatemenus = [{
        'buttons': buttons,
        'direction': 'down',
        'showactive': True,
        'x': 1.01,
        'xanchor': "right",
        'y': 0.989,
        'yanchor': "top",
        'font': {'color': 'black', 'size': 11}
    }]
    
    return mesh_traces + [edges_trace], updatemenus


def splot(bdf_file, excel_file):
    """read TTB summary excel and plots 3D mesh plot w plotly by also using pynastran"""
    
    # Load data
    print("\nPLOTTING the TTB_summary...\n")
    df = pd.read_excel(excel_file)
    bdf_model = my_read_bdf(bdf_file)
    
    mass_default, mass_optimized = "n/a", "n/a"
    if "mass (kg) default" in df.columns:
        mass_default = df["mass (kg) default"].sum()
    if "mass (kg) optimized" in df.columns:
        mass_optimized = df["mass (kg) optimized"].sum()
    
    # Extract mesh data
    coords, faces, edges_xyz, intensity_values, hover_texts, intensity_columns = extract_mesh_data(df, bdf_model)
    
    # Create visualization
    mesh_traces, updatemenus = create_mesh_visualization(df, coords, faces, edges_xyz, intensity_values, hover_texts, intensity_columns)
    
    # Add free edges
    free_edges_trace = plot_free_edges(bdf_model)
    
    # Add custom coordinate system
    coord_system_traces = plot_coordinate_system(bdf_model, coords)
    
    # Create figure with all traces
    fig = go.Figure(data=mesh_traces + [free_edges_trace] + coord_system_traces)
    
    # Get indices of mesh traces
    n_intensity_cols = len(intensity_columns)
    mesh_indices = list(range(0, n_intensity_cols * 2, 2))
    
    # Build opacity list
    opacity_on = [0.5 if i in mesh_indices else 1 for i in range(len(fig.data))]
    opacity_off = [1] * len(fig.data)
    
    # Button 1: Theme toggle
    updatemenus.append(dict(
        type="buttons",
        active=0,
        showactive=True,
        xanchor="left",
        yanchor="bottom",
        x=0.031,
        y=0.012,
        buttons=[dict(
            label=" üåó ",
            method="relayout",
            args=[{"template": pio.templates['plotly_white']}],
            args2=[{"template": pio.templates['plotly_dark']}]
        )],
        font=dict(color="black", size=10),
        bordercolor="gray",
        borderwidth=1
    ))
    
    # Button 2: Reset camera
    updatemenus.append(dict(
        type="buttons",
        showactive=False,
        buttons=[dict(
            args=[{
                'scene.camera.center': {'x': 0, 'y': 0, 'z': 0},
                'scene.camera.eye': {'x': 1.5, 'y': 1.5, 'z': 1.5},
                'scene.camera.up': {'x': 0, 'y': 0, 'z': 1}
            }],
            label="üî≤",
            method='relayout'
        )],
        direction="down",
        x=0.003,
        y=0.012,
        xanchor="left",
        yanchor="bottom",
        bordercolor="gray",
        borderwidth=1
    ))
    
    # Button 3: Edge visibility toggle
    updatemenus.append(dict(
        type="buttons",
        direction="right",
        active=0,
        showactive=True,
        xanchor="left",
        yanchor="bottom",
        x=0.059,
        y=0.012,
        buttons=[dict(
            label=" üí† ",
            method="restyle",
            args=[{"mode": ['lines' if trace.name == "edge_traces" else getattr(trace, 'mode', None) for trace in fig.data]}],
            args2=[{"mode": ['text' if trace.name == "edge_traces" else getattr(trace, 'mode', None) for trace in fig.data]}]
        )],
        font=dict(color="black", size=10),
        bordercolor="gray",
        borderwidth=1
    ))
    
    # Button 4: Transparency toggle
    updatemenus.append(dict(
        type="buttons",
        showactive=True,
        active=1,
        xanchor="left",
        yanchor="bottom",
        x=0.087,
        y=0.012,
        buttons=[dict(
            label=" üëÅ‚Äçüó® ",
            method="restyle",
            args=[{"opacity": opacity_on}],
            args2=[{"opacity": opacity_off}]
        )],
        font=dict(color="black", size=10),
        bordercolor="gray",
        borderwidth=1
    ))
    
    bdf_name = os.path.basename(bdf_file)
    
    ll = bdf_model.get_bdf_stats().split()
    no_nodes = ll[ll.index('bdf.nodes:') + 1]
    no_elements = ll[ll.index('bdf.elements:') + 1]
    no_properties = ll[ll.index('bdf.properties:') + 1]
    
    try:
        title = f"<b>{bdf_name}</b><br>Nodes: {no_nodes}<br>Elements: {no_elements}<br>Properties: {no_properties}<br>Default mass: {mass_default:0.2f} kg<br>Optimized mass: {mass_optimized:0.2f} kg"
    except:
        title = f"<b>{bdf_name}</b><br>Nodes: {no_nodes}<br>Elements: {no_elements}<br>Properties: {no_properties}<br>Default mass: {mass_default}<br>Optimized mass: {mass_optimized}"
    
    # SINGLE scene configuration - hide Plotly's axes, use only custom coordinate system
    fig.update_layout(
        margin=dict(r=0, l=0, t=0, b=0),
        title_text=title,
        title_x=0.003,
        title_y=0.98,
        scene=dict(
            aspectmode='data',
            xaxis=dict(visible=False),  # Hide Plotly axes
            yaxis=dict(visible=False),
            zaxis=dict(visible=False)
        ),
        template="plotly_white",
        updatemenus=updatemenus,
        hovermode="closest",
        legend=dict(x=1.01, y=0.012, xanchor="right", yanchor="bottom", bordercolor="gray", borderwidth=1)
    )
    
    # Save result
    os.chdir(os.path.dirname(excel_file))
    
    try:
        fig.write_html("TTB_summary_plot.html", config={"displayModeBar": False})
        print(f"‚úì HTML saved: {len(fig.data)} traces total")
        return 0
    except Exception as e:
        print(f"ERROR S-Plot: {e}")
        return 1
    
bdf=r'C:/Users/User/Desktop/VSCODE/95_MISGEN/updated_statics.bdf'
xls=r'C:/Users/User/Desktop/VSCODE/95_MISGEN/updated_statics_misc.xlsx'
splot(bdf,xls)
