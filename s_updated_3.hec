import os, platform, psutil, getpass
import subprocess
import time
import numpy as np
import pandas as pd
import xlwings as xw
import plotly.graph_objects as go
import plotly.io as pio
from pyNastran.bdf.bdf import read_bdf
from pyNastran.bdf.mesh_utils import free_edges
from collections import Counter
import re
import warnings
warnings.filterwarnings('ignore')


# =============================================================================
# HELPERS
# =============================================================================

def my_read_bdf(path):
    try:
        try: bdf=read_bdf(path,punch=True,xref=True)
        except: bdf=read_bdf(path,punch=True,xref=False)
    except:
        try: bdf=read_bdf(path,punch=False,xref=True)
        except: bdf=read_bdf(path,punch=False,xref=False)
    return bdf


def plot_free_edges(bdf):
    """Plot lines connecting free edges in the mesh."""
    free_nodes = free_edges.non_paired_edges(bdf)
    x, y, z = [], [], []
    
    for node_pair in free_nodes:
        for nid in node_pair:
            node_coords = bdf.nodes[nid].xyz
            x.append(node_coords[0])
            y.append(node_coords[1])
            z.append(node_coords[2])
        # Add None to create breaks between line segments
        x.append(None)
        y.append(None)
        z.append(None)
    
    return go.Scatter3d(
        x=x, y=y, z=z, 
        mode='lines', 
        line=dict(color='rgba(50, 50, 50, 1)', width=8),
        showlegend=False, 
        hoverinfo="none",
        name="free_edges",
        opacity=1
    )


def project_onto(v, target):
    """
    this is for CBAR offsets,
    v: offset vector wa,wb
    target: normal vector of cbar
    """
    axis=np.array(target)
    v=np.array(v)
    axis_norm_sq=np.dot(axis,target)
    return np.dot(v,axis)/axis_norm_sq*target
    

def offset_cbar_elements(bdf,element,offset_distance):
    original_bars, left_offset_bars, right_offset_bars= [],[],[]
    n1,n2=element.nodes
    p1=np.array(bdf.nodes[n1].get_position())
    p2=np.array(bdf.nodes[n2].get_position())
    
    bar_vector=p2-p1
    bar_length=np.linalg.norm(bar_vector)
    bar_unit=bar_vector/bar_length
    
    
    if element.g0 is not None:
        g0_coord=np.array(bdf.nodes[element.g0].get_position())
        v_temp=g0_coord-p1
    else:
        v_temp=np.array(element.x)
    
    if element.wa is not None:
        wa,wb = element.wa, element.wb
    else:
        wa,wb=np.array([0,0,0]),np.array([0,0,0])
        
    #make sure v_temp is not parallel to bar_unit
    if np.isclose(np.abs(np.dot(v_temp/np.linalg.norm(v_temp),bar_unit)),1.0):
        if not np.isclose(np.abs(bar_unit[0]),1.0):
            v_temp=np.array([1,0,0])
        else:
            v_temp=np.array([0,1,0])
    
    y_axis = np.cross(bar_unit,v_temp)
    y_axis = y_axis / np.linalg.norm(y_axis)
    
    z_axis = np.cross(bar_unit,y_axis)
    z_axis = z_axis / np.linalg.norm(z_axis)
    
    y_axis=z_axis
    wa=project_onto(wa,y_axis)
    wb=project_onto(wa,y_axis)
    
    left_p1=p1+y_axis*offset_distance + wa
    left_p2=p2+y_axis*offset_distance + wb
    
    right_p1=p1-y_axis*offset_distance + wa
    right_p2=p2-y_axis*offset_distance + wb
    
    original_bars.append((p1,p2))
    left_offset_bars.append((left_p1,left_p2))
    right_offset_bars.append((right_p1,right_p2))
    
    return original_bars, left_offset_bars, right_offset_bars


# =============================================================================
# FASTENER PLOT    
# =============================================================================

def plot_fastener_points(bdf,fastener_df):
    # Create dictionaries to store data by diameter
    diameter_data = {}
    
    # Track unique fastener types
    fastener_types_set = set()
    elements=fastener_df["Element ID (PBARL)"].to_list()
    
    for elid in elements:
        pid=bdf.elements[elid].pid
        #diameter_data[diameter][fastener_type]["pids"].append(pid)
        
        if bdf.elements[elid].type == "CBAR":
            # Get fastener info
            fastener_info = fastener_df[fastener_df["Element ID (PBARL)"] == elid]
            fastener_type = fastener_info["Pin"].values[0]
            diameter = float(fastener_info["Diameter"].values[0])
            
            # Track fastener type
            fastener_types_set.add(fastener_type)
            
            # Initialize data structure for this diameter if needed
            if diameter not in diameter_data:
                diameter_data[diameter] = {}
            
            # Initialize data structure for this fastener type if needed
            if fastener_type not in diameter_data[diameter]:
                diameter_data[diameter][fastener_type] = {
                    "x": [], "y": [], "z": [], "pids": [], "elids":[]
                }
            
            # Calculate centroid for element
            valid_nodes=bdf.elements[elid].nodes
            if valid_nodes:
                x = sum(bdf.nodes[nid].xyz[0] for nid in valid_nodes) / len(valid_nodes)
                y = sum(bdf.nodes[nid].xyz[1] for nid in valid_nodes) / len(valid_nodes)
                z = sum(bdf.nodes[nid].xyz[2] for nid in valid_nodes) / len(valid_nodes)
                
                diameter_data[diameter][fastener_type]["x"].append(x)
                diameter_data[diameter][fastener_type]["y"].append(y)
                diameter_data[diameter][fastener_type]["z"].append(z)
                diameter_data[diameter][fastener_type]["pids"].append(pid)
                diameter_data[diameter][fastener_type]["elids"].append(elid)
    
    traces = []
    
    # Color map for different diameters
    colors = {
        4.17: "blue", 4.78: "cyan", 6.35: "lime", 7.92: "darkgreen",
        9.53: "yellow", 11.13: "orange", 12.7: "red", 14.3: "magenta",
    }
    
    # Symbol map for different fastener types
    symbols = ['circle', 'square', 'x', 'diamond',
    'diamond-open', 'circle-open', 'square-open', 'cross']
    symbol_map = {}
    
    # Assign a different symbol to each fastener type
    for i, fastener_type in enumerate(sorted(fastener_types_set)):
        symbol_map[fastener_type] = symbols[i % len(symbols)]
    
    for diameter, type_data in diameter_data.items():
        for fastener_type, data in type_data.items():
            if not data["x"]:  # Skip if no points
                continue
                
            trace = go.Scatter3d(
                x=data["x"], y=data["y"], z=data["z"],
                mode='markers',
                marker=dict(
                    size=diameter,
                    color=colors.get(diameter, "gray"),
                    symbol=symbol_map[fastener_type],
                    opacity=1,
                    line=dict(width=1, color='rgba(0, 0, 0, 0.5)')
                ),
                name=f'Ã˜{diameter}mm ({fastener_type})',
                hovertemplate='<i>PBARL %{text}</i><br>Type: ' + fastener_type + '<br>Diameter: ' + str(diameter) + ' mm<extra></extra>',
                text=data["pids"],
                hoverinfo='none'
            )
            traces.append(trace)
    
    return traces


def fplot(bdf_file,excel_file):
    print("\nPLOTTING the TTB_fastener...\n")
    bdf=my_read_bdf(bdf_file)
    bdf_name=os.path.basename(bdf_file)
    pid2eid=bdf.get_property_id_to_element_ids_map()
    fastener_df=pd.read_excel(excel_file,sheet_name="JOINT")
    
    # Generate edge trace
    edge_trace = plot_free_edges(bdf)

    # Generate fastener traces
    fastener_traces = plot_fastener_points(bdf,fastener_df)

    # Combine all traces
    all_traces = [edge_trace] + fastener_traces

    # Create figure with all traces
    fig = go.Figure(data=all_traces)

    # Update layout with bigger legend and title
    fig.update_layout(
        scene=dict(
            aspectmode='data',
            xaxis=dict(visible=False),
            yaxis=dict(visible=False),
            zaxis=dict(visible=False)
        ),
        template="plotly_white",
        legend=dict(font=dict(size=16), x=0.99, y=1.0)
    )
    
    fig.update_layout(updatemenus=[dict(
      type="buttons", direction="right", active=0, showactive=True,
      x=0.5, y=0.0, xanchor="center", yanchor="bottom",
      buttons=list([
        dict(args=['template', pio.templates['plotly_white']], label="White Theme", method="relayout"),   
        dict(args=['template', pio.templates['plotly_dark']], label="Black Theme", method="relayout")
      ]), 
      font=dict(color="black")
    )])
    
    title=f"<b>{bdf_name}</b><br>Fastener representation"
        
    fig.update_layout(margin=dict(r=0,l=0,t=0,b=0),
                      title_text=title,title_x=0.003,title_y=0.98)
    
    os.chdir(os.path.dirname(excel_file))
    
    try:
        fig.write_html("TTB_fastener_plot.html",config={"displayModeBar":False})
        return 0
    except Exception as e:
        print(f"ERROR F-Plot: {e}")
        return 1


# =============================================================================
# SUMMARY PLOT - ELEMENT-BASED COLORING (NO VERTEX INTERPOLATION)
# =============================================================================

def extract_mesh_data(df, bdf):
    """Extract mesh data - ELEMENT-BASED (each element gets one value)"""
    
    df.rename(columns={"Min RF":"RF (min)", "RF min":"RF (min)", "RF min sized":"RF (min) sized"},inplace=True)
    excluded_columns = []
    
    # Get all columns except excluded ones
    intensity_columns = [col for col in df.columns if col not in excluded_columns]
    
    # Store per-element data
    element_data = []  # List of dicts: {pid, elid, coords, hover_text, intensity_values}
    
    global pid_centroids
    pid_centroids = {}
    
    for elid, element in bdf.elements.items():
        pid = element.pid
        row = df[df['Property ID'] == pid]
        if row.empty:
            continue
        
        rf_data = row.iloc[0]
        
        # Build hover info
        hover_info = []
        for col in df.columns:
            if col in row.columns and col not in ['Property ID', 'LCID', 'Default Failur(E)', 'Optimized Failur(E)']:
                if col in ["RF (min)", "RF min"]:
                    try: hover_info.append(f"<b>âš«</b><br>{col}: {rf_data[col]:0.2f}")
                    except: hover_info.append(f"<b>âš«</b><br>{col}: {rf_data[col]}")
                else:
                    try: hover_info.append(f"{col}: {rf_data[col]:0.2f}")
                    except: hover_info.append(f"{col}: {rf_data[col]}")
            elif col=="Property ID":
                hover_info.append(f"PID: {rf_data[col]:0.0f}")
            elif col=="LCID":
                try: hover_info.append(f"{col}: {rf_data[col]:0.0f}<br><b>âš«</b>")
                except: hover_info.append(f"{col}: {rf_data[col]}<br><b>âš«</b>")
                
        hover_text = "<br>".join(hover_info)
        
        # Get element coordinates
        elem_coords = []
        if element.type == 'CQUAD4':
            for nid in element.nodes:
                node_xyz = bdf.nodes[nid].xyz
                elem_coords.append(node_xyz)
                pid_centroids.setdefault(pid, []).append(node_xyz)
                
        elif element.type == 'CTRIA3':
            for nid in element.nodes:
                node_xyz = bdf.nodes[nid].xyz
                elem_coords.append(node_xyz)
                pid_centroids.setdefault(pid, []).append(node_xyz)
                
        elif element.type == "CBAR":
            try:
                prop=bdf.properties[pid]
                width=max(prop.dim)
            except:
                n1,n2=element.nodes
                p1=np.array(bdf.nodes[n1].get_position())
                p2=np.array(bdf.nodes[n2].get_position())
                bar_length=np.linalg.norm(p2-p1)
                width=bar_length*0.05
            
            original_bars,left_offset_bars,right_offset_bars = offset_cbar_elements(bdf,element,width/2)
            
            left_p1,left_p2=left_offset_bars[0]
            right_p1,right_p2=right_offset_bars[0]
            
            all_points=[left_p1, right_p1, right_p2, left_p2]  # Form quad
            for point in all_points:
                elem_coords.append(point)
                pid_centroids.setdefault(pid, []).append(point)
        
        # Store element data
        if elem_coords:
            intensity_vals = {col: rf_data[col] for col in intensity_columns}
            element_data.append({
                'pid': pid,
                'elid': elid,
                'coords': elem_coords,
                'hover_text': hover_text,
                'intensities': intensity_vals,
                'elem_type': element.type
            })
    
    return element_data, intensity_columns


def plot_coordinate_system(bdf, element_data):
    """Plot X-Y-Z coordinate system axes at the model origin or offset location."""
    
    # Find the minimum coordinates from element data
    all_x, all_y, all_z = [], [], []
    for elem in element_data:
        for coord in elem['coords']:
            all_x.append(coord[0])
            all_y.append(coord[1])
            all_z.append(coord[2])
    
    x_min = np.min(all_x) - np.std(all_x)
    y_min = np.min(all_y) - np.std(all_y)
    z_min = np.min(all_z) - np.std(all_z)
    
    # Calculate axis length (5% of model size)
    x_range = np.max(all_x) - np.min(all_x)
    y_range = np.max(all_y) - np.min(all_y)
    z_range = np.max(all_z) - np.min(all_z)
    axis_length = max(x_range, y_range, z_range) * 0.05
    
    axes = []
    for axis_name, delta in [('X', [axis_length, 0, 0]), 
                              ('Y', [0, axis_length, 0]), 
                              ('Z', [0, 0, axis_length])]:
        axes.append(go.Scatter3d(
            x=[x_min, x_min + delta[0]],
            y=[y_min, y_min + delta[1]],
            z=[z_min, z_min + delta[2]],
            mode='lines+text',
            line=dict(color='black', width=4),
            text=['', axis_name],
            textposition='top center',
            textfont=dict(size=12, color='black', family='Arial Black'),
            showlegend=False,
            hoverinfo='skip',
            name=f'{axis_name}_axis'
        ))
    
    return axes


def create_mesh_visualization(df, element_data, intensity_columns):

    def is_discrete_column(col, df):
        col_data = df[col]
        numeric_data = pd.to_numeric(col_data, errors='coerce')
        valid_numbers = numeric_data.dropna()
        if len(valid_numbers) == 0:
            return True
        if valid_numbers.max() < 100:
            return False
        else:
            return True

    discrete_columns = [col for col in intensity_columns if is_discrete_column(col, df)]

    print(f"\nðŸ“Š Column Classification:")
    print(f"   Discrete:   {discrete_columns}")
    print(f"   Continuous: {[col for col in intensity_columns if col not in discrete_columns]}\n")

    all_traces = []
    centroids = {}

    # ===== BUILD GEOMETRY ONCE (shared across all columns) =====
    total_verts = sum(len(elem['coords']) for elem in element_data)
    total_faces = sum(2 if len(elem['coords']) == 4 else 1 for elem in element_data)

    x_coords         = [None] * total_verts
    y_coords         = [None] * total_verts
    z_coords         = [None] * total_verts
    i_faces          = [None] * total_faces
    j_faces          = [None] * total_faces
    k_faces          = [None] * total_faces
    hover_texts_face = [None] * total_faces
    elem_to_faces    = []

    vert_idx = 0
    face_idx = 0
    for elem in element_data:
        coords = elem['coords']
        n_verts = len(coords)
        faces_for_elem = []

        for coord in coords:
            x_coords[vert_idx] = coord[0]
            y_coords[vert_idx] = coord[1]
            z_coords[vert_idx] = coord[2]
            vert_idx += 1

        if n_verts == 4:
            offset = vert_idx - 4
            i_faces[face_idx]=offset;   j_faces[face_idx]=offset+1; k_faces[face_idx]=offset+2
            hover_texts_face[face_idx]=elem['hover_text']; faces_for_elem.append(face_idx); face_idx+=1
            i_faces[face_idx]=offset;   j_faces[face_idx]=offset+2; k_faces[face_idx]=offset+3
            hover_texts_face[face_idx]=elem['hover_text']; faces_for_elem.append(face_idx); face_idx+=1
        elif n_verts == 3:
            offset = vert_idx - 3
            i_faces[face_idx]=offset;   j_faces[face_idx]=offset+1; k_faces[face_idx]=offset+2
            hover_texts_face[face_idx]=elem['hover_text']; faces_for_elem.append(face_idx); face_idx+=1

        elem_to_faces.append(faces_for_elem)

    for col_idx, col in enumerate(intensity_columns):
        is_discrete = col in discrete_columns
        axis_key    = f"coloraxis{col_idx + 1}"

        # ===== BUILD CENTROIDS =====
        if col not in centroids:
            centroids[col] = {"cx": [], "cy": [], "cz": [], "t": [], "colors": [], "sizes": []}

            if not is_discrete:
                try:
                    numeric_col = df[col].astype(float)
                    max_pid = df.loc[numeric_col.idxmax(), 'Property ID']
                    min_pid = df.loc[numeric_col.idxmin(), 'Property ID']
                except:
                    max_pid = min_pid = None
            else:
                max_pid = min_pid = None

            for pid, coords_list in pid_centroids.items():
                row = df[df["Property ID"] == pid]
                if row.empty:
                    continue
                intensity_row = row.iloc[0]
                coords_arr = np.array(coords_list)
                centroids[col]["cx"].append(coords_arr[:, 0].mean())
                centroids[col]["cy"].append(coords_arr[:, 1].mean())
                centroids[col]["cz"].append(coords_arr[:, 2].mean())

                try:    text_val = f"<b>{intensity_row[col]:0.2f}</b>"
                except: text_val = f"<b>{intensity_row[col]}</b>"

                is_max = (pid == max_pid) if not is_discrete else False
                is_min = (pid == min_pid) if not is_discrete else False

                if is_max:
                    centroids[col]["t"].append(text_val); centroids[col]["colors"].append("red");   centroids[col]["sizes"].append(16)
                elif is_min:
                    centroids[col]["t"].append(text_val); centroids[col]["colors"].append("blue");  centroids[col]["sizes"].append(16)
                else:
                    centroids[col]["t"].append(text_val); centroids[col]["colors"].append("black"); centroids[col]["sizes"].append(4)

        # ===== BUILD CELL INTENSITY ARRAY =====
        cell_intensities = [None] * total_faces

        if is_discrete:
            # --- Step 1: Build processed_values ---
            raw_values = [elem['intensities'][col] for elem in element_data]
            processed_values = []
            for v in raw_values:
                try:    is_na = pd.isna(v)
                except: is_na = False
                if is_na or str(v).strip().lower() in ['nan', 'n/a', '', 'none', 'null']:
                    processed_values.append("N/A")
                else:
                    processed_values.append(str(v))

            # --- Step 2: Build initial unique_cats (ordered by appearance) ---
            if "N/A" in set(processed_values):
                unique_cats = ["N/A"]
                unique_cats.extend([cat for cat in dict.fromkeys(processed_values) if cat != "N/A"])
            else:
                unique_cats = list(dict.fromkeys(processed_values))

            # --- Step 3: Cap to MAX_CATS ---
            MAX_CATS = 120
            n_cats = len(unique_cats)

            if n_cats > MAX_CATS:
                value_counts_all = Counter(processed_values)
                na_count_cap = value_counts_all.pop("N/A", None)
                top_cats = [
                    cat for cat, _ in value_counts_all.most_common(
                        MAX_CATS - (1 if na_count_cap else 0)
                    )
                ]
                capped_cats = (["N/A"] if na_count_cap else []) + top_cats
                capped_set  = set(capped_cats)
            
                # Remap excluded values to the closest frequent category instead of "Other"
                # Build a fallback: excluded â†’ most frequent cat that IS in capped_set
                fallback = top_cats[0] if top_cats else (["N/A"] if na_count_cap else [None])[0]
                processed_values = [
                    v if v in capped_set else fallback
                    for v in processed_values
                ]
            
                unique_cats = capped_cats  # no "Other" appended
                n_cats      = len(unique_cats)

            # --- Step 4: Build cat_to_int from FINAL unique_cats ---
            cat_to_int = {cat: float(idx) for idx, cat in enumerate(unique_cats)}

            # --- Step 5: Build distinct_colors (single loop) ---
            def build_palette():
                import matplotlib.cm as cm
                import matplotlib.colors as mcolors
                base = [
                    '#FF0000','#0000FF','#00FF00','#FFA500','#FF00FF','#00FFFF',
                    '#FFFF00','#800080','#FFC0CB','#A52A2A','#000080','#8B4513',
                    '#2F4F4F','#FF1493','#00CED1','#FF4500','#DA70D6','#32CD32',
                    '#FFD700','#4169E1','#FF6347','#40E0D0','#EE82EE','#F0E68C',
                    '#90EE90','#ADD8E6','#F08080','#E0FFFF','#FAFAD2'
                ]
                
                # tab20 = 20, tab20b = 20, tab20c = 20 â†’ 60 more
                for cmap_name in ['tab20', 'tab20b', 'tab20c']:
                    cmap = cm.get_cmap(cmap_name)
                    for i in range(20):
                        hex_color = mcolors.to_hex(cmap(i))
                        if hex_color not in base:
                            base.append(hex_color)
                
                # Set3, Paired add ~24 more
                for cmap_name in ['Set3', 'Paired']:
                    cmap = cm.get_cmap(cmap_name)
                    for i in range(cmap.N):
                        hex_color = mcolors.to_hex(cmap(i))
                        if hex_color not in base:
                            base.append(hex_color)
                
                return base  # ~110 distinct colors
            
            base_palette = build_palette()

            # base_palette = [
            #     '#FF0000','#0000FF','#00FF00','#FFA500','#FF00FF','#00FFFF',
            #     '#FFFF00','#800080','#FFC0CB','#A52A2A','#000080','#8B4513',
            #     '#2F4F4F','#FF1493','#00CED1','#FF4500','#DA70D6','#32CD32',
            #     '#FFD700','#4169E1','#FF6347','#40E0D0','#EE82EE','#F0E68C',
            #     '#90EE90','#ADD8E6','#F08080','#E0FFFF','#FAFAD2'
            # ]
            has_na = "N/A" in unique_cats

            distinct_colors = []
            non_special_idx = 0
            for cat in unique_cats:
                if cat == "N/A":
                    distinct_colors.append('#808080')
                else:
                    distinct_colors.append(base_palette[non_special_idx % len(base_palette)])
                    non_special_idx += 1
            
            # --- Step 6: Build colorscale ---
            colorscale = []
            for idx in range(n_cats):
                lower = idx / n_cats
                upper = (idx + 1) / n_cats
                colorscale.append([lower, distinct_colors[idx]])
                colorscale.append([upper, distinct_colors[idx]])

            # --- Step 7: Build cell_intensities ---
            for elem_idx, elem in enumerate(element_data):
                val = cat_to_int[processed_values[elem_idx]] + 0.5
                for fi in elem_to_faces[elem_idx]:
                    cell_intensities[fi] = val

            # --- Step 8: Build top_8 for colorbar ---
            value_counts_top = Counter(processed_values)
            na_count_top = value_counts_top.pop("N/A", None)
            top_8 = [cat for cat, _ in value_counts_top.most_common(8)]
            if na_count_top is not None:
                top_8 = ["N/A"] + top_8

            top_8_valid = [cat for cat in top_8 if cat in cat_to_int]
            n_show = len(top_8_valid)

            top8_colorscale = []
            for i, cat in enumerate(top_8_valid):
                color = distinct_colors[int(cat_to_int[cat])]
                top8_colorscale.append([i / n_show, color])
                top8_colorscale.append([(i + 1) / n_show, color])

            print(f"col_idx={col_idx} | col={col} | n_cats={n_cats} | cmin=0 | cmax={n_cats}")

            mesh_trace = go.Mesh3d(
                x=x_coords, y=y_coords, z=z_coords,
                i=i_faces, j=j_faces, k=k_faces,
                intensity=cell_intensities,
                intensitymode='cell',
                colorscale=colorscale,
                cmin=0, cmax=n_cats,
                showscale=False,
                opacity=1,
                lighting=dict(ambient=1.0, diffuse=0.0, specular=0.0, roughness=1.0, fresnel=0.0),
                flatshading=True,
                text=hover_texts_face,
                hovertemplate='%{text}<extra></extra>',
                hoverlabel=dict(
                    bgcolor="rgba(20, 20, 40, 0.95)",
                    bordercolor="rgba(100, 150, 255, 0.6)",
                    font=dict(color="#E0E7FF", size=13, family="'Segoe UI', Roboto, sans-serif")
                ),
                visible=(col_idx == 0),
                showlegend=False,
                name=col
            )
            all_traces.append(mesh_trace)

            colorbar_trace = go.Scatter3d(
                x=[None], y=[None], z=[None], mode='markers',
                marker=dict(
                    size=0.001,
                    color=list(range(n_show)),
                    colorscale=top8_colorscale,
                    cmin=0, cmax=n_show,
                    colorbar=dict(
                        title=dict(text=col, side='top'),
                        tickmode='array',
                        tickvals=[i + 0.5 for i in range(n_show)],
                        ticktext=top_8_valid,
                        len=0.82, thickness=15, x=1.02
                    )
                ),
                visible=(col_idx == 0),
                showlegend=False,
                hoverinfo='skip',
                name=f"{col}_colorbar"
            )
            all_traces.append(colorbar_trace)

        else:
            # ===== CONTINUOUS =====
            all_intensities = []
            for elem in element_data:
                try:    all_intensities.append(float(elem['intensities'][col]))
                except: all_intensities.append(0.0)

            color_min = min(all_intensities)
            color_max = max(all_intensities)

            for elem_idx, elem in enumerate(element_data):
                val = all_intensities[elem_idx]
                for fi in elem_to_faces[elem_idx]:
                    cell_intensities[fi] = val

            mesh_trace = go.Mesh3d(
                x=x_coords, y=y_coords, z=z_coords,
                i=i_faces, j=j_faces, k=k_faces,
                intensity=cell_intensities,
                intensitymode='cell',
                colorscale="Jet",
                cmin=color_min, cmax=color_max,
                showscale=False,
                opacity=1,
                lighting=dict(ambient=1.0, diffuse=0.0, specular=0.0, roughness=1.0, fresnel=0.0),
                flatshading=True,
                text=hover_texts_face,
                hovertemplate='%{text}<extra></extra>',
                hoverlabel=dict(
                    bgcolor="rgba(0, 0, 55, 0.9)",
                    bordercolor="rgba(255, 255, 255, 0.8)",
                    font=dict(color="white", size=14)
                ),
                visible=(col_idx == 0),
                showlegend=False,
                name=col
            )
            all_traces.append(mesh_trace)

            colorbar_trace = go.Scatter3d(
                x=[None], y=[None], z=[None], mode='markers',
                marker=dict(
                    size=0.001,
                    color=[color_min, color_max],
                    colorscale="Jet",
                    cmin=color_min, cmax=color_max,
                    colorbar=dict(
                        title=dict(text=col, side='top'),
                        len=0.82, thickness=15, x=1.02
                    )
                ),
                visible=(col_idx == 0),
                showlegend=False,
                hoverinfo='skip',
                name=f"{col}_colorbar"
            )
            all_traces.append(colorbar_trace)

        # ===== LABEL TRACE =====
        label_trace = go.Scatter3d(
            x=centroids[col]["cx"], y=centroids[col]["cy"], z=centroids[col]["cz"],
            mode="text+markers",
            text=centroids[col]["t"],
            textfont=dict(size=11, color=centroids[col]["colors"]),
            marker=dict(color=centroids[col]["colors"], symbol="diamond", size=centroids[col]["sizes"]),
            name="Labels ON/OFF", showlegend=True, hoverinfo="skip",
            visible=(col_idx == 0), textposition="top center"
        )
        all_traces.append(label_trace)

    # ===== BUTTONS â€” 3 traces per column =====
    n_col_traces   = len(all_traces)
    n_total_traces = n_col_traces + 5  # edges + free_edges + 3 coord axes

    buttons = []
    for col_idx, col in enumerate(intensity_columns):
        visible = [False] * n_total_traces
        visible[3 * col_idx]     = True  # mesh
        visible[3 * col_idx + 1] = True  # colorbar
        visible[3 * col_idx + 2] = True  # labels
        for i in range(5):
            visible[n_col_traces + i] = True
        label = col if len(col) <= 25 else col[:22] + "..."
        buttons.append({'label': f'ðŸ“Š {label}', 'method': "update", 'args': [{"visible": visible}]})

    updatemenus = [{'buttons': buttons, 'direction': 'down', 'showactive': True,
                    'x': 1.01, 'xanchor': "right", 'y': 0.989, 'yanchor': "top",
                    'font': {'color': 'black', 'size': 11}}]

    # ===== EDGE TRACES =====
    total_edge_segments = sum(4 if len(e['coords']) == 4 else 3 for e in element_data)
    edge_size = total_edge_segments * 3
    edges_x = [None] * edge_size
    edges_y = [None] * edge_size
    edges_z = [None] * edge_size
    idx = 0
    for elem in element_data:
        coords = elem['coords']
        edges  = [[0,1],[1,2],[2,3],[3,0]] if len(coords) == 4 else [[0,1],[1,2],[2,0]]
        for edge in edges:
            edges_x[idx]=coords[edge[0]][0]; edges_y[idx]=coords[edge[0]][1]; edges_z[idx]=coords[edge[0]][2]; idx+=1
            edges_x[idx]=coords[edge[1]][0]; edges_y[idx]=coords[edge[1]][1]; edges_z[idx]=coords[edge[1]][2]; idx+=1
            idx += 1  # None slot already initialized

    edges_trace = go.Scatter3d(
        x=edges_x, y=edges_y, z=edges_z, mode='lines',
        line=dict(color='black', width=1), hoverinfo="none",
        showlegend=False, name="edge_traces"
    )

    return all_traces, edges_trace, updatemenus


def splot(bdf_file, excel_file):
    print("\nPLOTTING the TTB_summary...\n")
    df = pd.read_excel(excel_file)
    bdf_model = my_read_bdf(bdf_file)
    
    mass_default, mass_optimized = "n/a", "n/a"
    if "mass (kg) default" in df.columns:
        mass_default = df["mass (kg) default"].sum()
    if "mass (kg) optimized" in df.columns:
        mass_optimized = df["mass (kg) optimized"].sum()
    
    element_data, intensity_columns = extract_mesh_data(df, bdf_model)
    mesh_traces, edges_trace, updatemenus = create_mesh_visualization(df, element_data, intensity_columns)
    
    free_edges_trace = plot_free_edges(bdf_model)
    coord_system_traces = plot_coordinate_system(bdf_model, element_data)
    
    fig = go.Figure(data=mesh_traces + [edges_trace, free_edges_trace] + coord_system_traces)
    
    # Opacity â€” 3 traces per column
    n_columns = len(intensity_columns)
    opacity_on = []
    for i in range(n_columns * 3):
        opacity_on.append(0.5 if i % 3 == 0 else 1.0)
    opacity_on.extend([1, 1, 1, 1, 1])
    opacity_off = [1] * len(fig.data)
    
    # Theme toggle
    updatemenus.append(dict(
        type="buttons", active=0, showactive=True,
        xanchor="left", yanchor="bottom", x=0.031, y=0.012,
        buttons=[dict(
            label=" ðŸŒ— ",
            method="relayout",
            args=[{"template": pio.templates['plotly_white']}],
            args2=[{"template": pio.templates['plotly_dark']}]
        )],
        font=dict(color="black", size=10), bordercolor="gray", borderwidth=1
    ))
    
    # Reset camera
    updatemenus.append(dict(
        type="buttons", showactive=False,
        buttons=[dict(
            args=[{'scene.camera.center':{'x':0,'y':0,'z':0},
                   'scene.camera.eye':   {'x':1.5,'y':1.5,'z':1.5},
                   'scene.camera.up':    {'x':0,'y':0,'z':1}}],
            label="ðŸ”²", method='relayout'
        )],
        direction="down", x=0.003, y=0.012,
        xanchor="left", yanchor="bottom", bordercolor="gray", borderwidth=1
    ))
    
    # Edge visibility toggle
    updatemenus.append(dict(
        type="buttons", direction="right", active=0, showactive=True,
        xanchor="left", yanchor="bottom", x=0.059, y=0.012,
        buttons=[dict(
            label=" ðŸ’  ",
            method="restyle",
            args= [{"mode": ['lines' if t.name=="edge_traces" else getattr(t,'mode',None) for t in fig.data]}],
            args2=[{"mode": ['text'  if t.name=="edge_traces" else getattr(t,'mode',None) for t in fig.data]}]
        )],
        font=dict(color="black", size=10), bordercolor="gray", borderwidth=1
    ))
    
    # Transparency toggle
    updatemenus.append(dict(
        type="buttons", showactive=True, active=1,
        xanchor="left", yanchor="bottom", x=0.087, y=0.012,
        buttons=[dict(
            label=" ðŸ‘â€ðŸ—¨ ",
            method="restyle",
            args= [{"opacity": opacity_on}],
            args2=[{"opacity": opacity_off}]
        )],
        font=dict(color="black", size=10), bordercolor="gray", borderwidth=1
    ))
    
    bdf_name = os.path.basename(bdf_file)
    ll = bdf_model.get_bdf_stats().split()
    no_nodes      = ll[ll.index('bdf.nodes:')      + 1]
    no_elements   = ll[ll.index('bdf.elements:')   + 1]
    no_properties = ll[ll.index('bdf.properties:') + 1]
    
    try:
        title = (f"<b style='color:#1F2937;'>{bdf_name}</b><br>"
                 f"<span style='font-size:11px; color:#6B7280;'>Nodes: {no_nodes} | Elements: {no_elements} | Properties: {no_properties}</span><br>"
                 f"<span style='font-size:11px; color:#059669;'>Default: {mass_default:0.2f} kg</span> "
                 f"<span style='font-size:11px; color:#DC2626;'>â†’</span> "
                 f"<span style='font-size:11px; color:#2563EB;'>Optimized: {mass_optimized:0.2f} kg</span>")
    except:
        title = (f"<b style='color:#1F2937;'>{bdf_name}</b><br>"
                 f"<span style='font-size:11px; color:#6B7280;'>Nodes: {no_nodes} | Elements: {no_elements} | Properties: {no_properties}</span><br>"
                 f"<span style='font-size:11px; color:#059669;'>Default: {mass_default}</span> "
                 f"<span style='font-size:11px; color:#DC2626;'>â†’</span> "
                 f"<span style='font-size:11px; color:#2563EB;'>Optimized: {mass_optimized}</span>")
    
    fig.update_layout(
        margin=dict(r=0, l=0, t=0, b=0),
        title_text=title, title_x=0.003, title_y=0.98,
        scene=dict(aspectmode='data',
                   xaxis=dict(visible=False),
                   yaxis=dict(visible=False),
                   zaxis=dict(visible=False)),
        template="plotly_white",
        updatemenus=updatemenus,
        hovermode="closest",
        legend=dict(x=1.01, y=0.012, xanchor="right", yanchor="bottom",
                    bordercolor="gray", borderwidth=1)
    )
    
    os.chdir(os.path.dirname(excel_file))
    
    try:
        fig.write_html("TTB_summary_plot.html", config={"displayModeBar": False})
        print(f"âœ“ HTML saved: {len(fig.data)} traces total (3 per column + 5 fixed)")
        print(f"âœ“ intensitymode='cell' + per-face text: flat coloring with correct hover")
        return 0
    except Exception as e:
        print(f"ERROR S-Plot: {e}")
        return 1


# Example usage (uncomment to run):
bdf = r'C:\Users\User\Desktop\VSCODE\97_TTBPLOT/updated_statics.bdf'
xls = r'C:\Users\User\Desktop\VSCODE\97_TTBPLOT/updated_statics_misc.xlsx'
splot(bdf, xls)
