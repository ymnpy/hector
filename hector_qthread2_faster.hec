import os
import sys
import numpy as np
import pandas as pd
import subprocess
import shutil
import time
import psutil
import ast
from typing import Set, List, Dict, Optional, Tuple

from pyNastran.bdf.bdf import read_bdf
from pyNastran.op2.op2 import read_op2
from pyNastran.bdf.mesh_utils.mass_properties import mass_properties

from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,
                             QHBoxLayout, QLabel, QLineEdit, QPushButton,
                             QTextEdit, QProgressBar, QGroupBox, QSplitter,
                             QFileDialog, QMessageBox, QSpinBox, QDoubleSpinBox,
                             QComboBox, QRadioButton, QButtonGroup)
from PyQt5.QtCore import QThread, pyqtSignal, Qt
from PyQt5.QtGui import QFont

import matplotlib
matplotlib.use('Qt5Agg')
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure

# Optional for Gaussian optimization
try:
    from skopt import gp_minimize
    from skopt.space import Real
    SKOPT_AVAILABLE = True
except ImportError:
    SKOPT_AVAILABLE = False


# Create a Worker class BEFORE the PCOMPOptimizerGUI class
class OptimizationWorker(QThread):
    """Worker thread for running optimization without freezing GUI"""
    
    # Signals to communicate with main thread
    log_signal = pyqtSignal(str)
    progress_signal = pyqtSignal(int, int, int, list, object, str, str)  # iteration, max_iter, n_crit, rf_values, mass
    status_signal = pyqtSignal(str, str)  # status text, color
    finished_signal = pyqtSignal(bool, str)  # success, message
    
    def __init__(self, gui_instance):
        super().__init__()
        self.gui = gui_instance
        self.algorithm = None  # 'lazy' or 'gaussian'
        
    def run(self):
        """This runs in separate thread"""
        try:
            if self.algorithm == 'lazy':
                ok, msg = self.gui.run_lazy_optimization_thread()
            elif self.algorithm == 'sensitivity':
                ok, msg = self.gui.run_sensitivity_optimization_thread()
            else:  # gaussian
                ok, msg = self.gui.run_gaussian_optimization_thread()
            
            self.finished_signal.emit(ok, msg)
        except Exception as e:
            import traceback
            self.log_signal.emit(f"<span style='color:#e57373'>ERROR: {e}</span>")
            self.log_signal.emit(f"<span style='color:#e57373'>{traceback.format_exc()}</span>")
            self.finished_signal.emit(False, str(e))
            
class PCOMPOptimizerGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("PCOMP Thickness Optimizer v2.0")
        self.resize(1400, 900)
        self.apply_modern_style()
        
        # State variables
        self.iteration_data = []
        self.initial_mass = None
        self.node_to_shells_cache = None
        self.target_pcomp_ids = None
        self.angle_tolerance = 30
        self.worker = None
        
        # Build UI
        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        splitter = QSplitter(Qt.Horizontal)
        QHBoxLayout(main_widget).addWidget(splitter)
        
        splitter.addWidget(self.create_left_panel())
        splitter.addWidget(self.create_right_panel())
        splitter.setSizes([450, 950])
        
    
    def apply_modern_style(self):
        """Half-Life HEV Suit inspired compact theme"""
        self.setStyleSheet("""
            QMainWindow, QWidget {
                background-color: #0a0a0a;
                color: #d4d4d4;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 9pt;
            }
            QGroupBox {
                border: 1px solid #ff6600;
                border-radius: 3px;
                margin-top: 8px;
                padding-top: 8px;
                font-weight: bold;
                color: #ff8800;
                font-size: 8pt;
            }
            QGroupBox::title { 
                subcontrol-origin: margin; 
                left: 8px; 
                padding: 0 3px;
                background-color: #0a0a0a;
            }
            QLineEdit, QSpinBox, QDoubleSpinBox, QComboBox {
                background-color: #1a1a1a;
                border: 1px solid #444444;
                border-radius: 2px;
                padding: 3px 5px;
                color: #00ff00;
                selection-background-color: #ff6600;
                font-size: 9pt;
            }
            QLineEdit:focus, QSpinBox:focus, QDoubleSpinBox:focus, QComboBox:focus {
                border: 1px solid #ff6600;
                background-color: #222222;
            }
            QLineEdit:disabled, QSpinBox:disabled, QDoubleSpinBox:disabled {
                background-color: #0f0f0f;
                color: #555555;
                border: 1px solid #2a2a2a;
            }
            QComboBox::drop-down { 
                border: none;
                width: 20px;
            }
            QComboBox::down-arrow { 
                image: none;
                border-left: 3px solid transparent;
                border-right: 3px solid transparent;
                border-top: 5px solid #ff6600;
                margin-right: 5px;
            }
            QPushButton {
                background-color: #2a2a2a;
                color: #ff8800;
                border: 1px solid #ff6600;
                border-radius: 2px;
                padding: 5px 12px;
                font-weight: bold;
                font-size: 9pt;
            }
            QPushButton:hover { 
                background-color: #3a3a3a;
                border: 1px solid #ff8800;
                color: #ffaa00;
            }
            QPushButton:pressed { 
                background-color: #ff6600;
                color: #000000;
            }
            QPushButton:disabled { 
                background-color: #1a1a1a;
                color: #444444;
                border: 1px solid #2a2a2a;
            }
            QRadioButton { 
                color: #d4d4d4;
                spacing: 5px;
                font-size: 9pt;
            }
            QRadioButton::indicator { 
                width: 12px;
                height: 12px;
            }
            QRadioButton::indicator::unchecked { 
                border: 1px solid #555555;
                border-radius: 6px;
                background: #1a1a1a;
            }
            QRadioButton::indicator::checked { 
                border: 1px solid #ff6600;
                border-radius: 6px;
                background: qradialgradient(cx:0.5, cy:0.5, radius:0.5,
                    fx:0.5, fy:0.5, stop:0 #ff6600, stop:0.5 #ff8800, stop:1 #ff6600);
            }
            QRadioButton::indicator::checked:hover {
                background: qradialgradient(cx:0.5, cy:0.5, radius:0.5,
                    fx:0.5, fy:0.5, stop:0 #ff8800, stop:0.5 #ffaa00, stop:1 #ff8800);
            }
            QTextEdit {
                background-color: #0f0f0f;
                border: 1px solid #444444;
                border-radius: 2px;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 8pt;
                color: #00ff00;
                selection-background-color: #ff6600;
            }
            QProgressBar {
                border: 1px solid #444444;
                border-radius: 2px;
                text-align: center;
                background-color: #1a1a1a;
                height: 18px;
                color: #d4d4d4;
                font-weight: bold;
                font-size: 8pt;
            }
            QProgressBar::chunk {
                background-color: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #ff4400, stop:0.5 #ff6600, stop:1 #ff8800);
                border-radius: 1px;
            }
            QLabel { 
                color: #aaaaaa;
                font-size: 9pt;
            }
            QScrollBar:vertical {
                border: none;
                background: #1a1a1a;
                width: 10px;
                margin: 0;
            }
            QScrollBar::handle:vertical {
                background: #ff6600;
                min-height: 20px;
                border-radius: 2px;
            }
            QScrollBar::handle:vertical:hover {
                background: #ff8800;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
            QScrollBar:horizontal {
                border: none;
                background: #1a1a1a;
                height: 10px;
                margin: 0;
            }
            QScrollBar::handle:horizontal {
                background: #ff6600;
                min-width: 20px;
                border-radius: 2px;
            }
            QScrollBar::handle:horizontal:hover {
                background: #ff8800;
            }
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
                width: 0px;
            }
        """)
        
    def create_left_panel(self):
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setSpacing(12)
        
        # FILES GROUP
        files = QGroupBox("FILES")
        fl = QVBoxLayout()
        fl.setSpacing(3)
        
        for name, attr in [("BDF", "bdf_path"), ("OP2", "op2_path"), 
                          ("Excel", "excel_path"), ("Nastran", "nastran_path")]:
            hl = QHBoxLayout()
            
            label = QLabel(f"{name}:")
            label.setMinimumWidth(60)
            label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            hl.addWidget(label)
            
            le = QLineEdit()
            setattr(self, attr, le)
            if name == "Nastran":
                le.setText(r"C:\MSC.Software\MSC_Nastran\20180\bin\nastran.exe")
            hl.addWidget(le, 1)
            
            btn = QPushButton("λ")
            btn.setMinimumWidth(30)
            btn.setToolTip(f"Browse for {name} file")
            btn.clicked.connect(getattr(self, f"browse_{attr.split('_')[0]}"))
            hl.addWidget(btn)
            
            fl.addLayout(hl)
        
        files.setLayout(fl)
        layout.addWidget(files)
        
        # PROPERTY SELECTION GROUP
        prop_group = QGroupBox("PROPERTY SELECTION")
        pg_layout = QVBoxLayout()
        
        self.prop_method_group = QButtonGroup()
        
        self.prop_neighbor_radio = QRadioButton("Neighbor Approach (auto-detect)")
        self.prop_method_group.addButton(self.prop_neighbor_radio, 0)
        self.prop_neighbor_radio.setChecked(True)
        pg_layout.addWidget(self.prop_neighbor_radio)
        
        manual_layout = QHBoxLayout()
        self.prop_manual_radio = QRadioButton("Manual Property IDs:")
        self.prop_method_group.addButton(self.prop_manual_radio, 1)
        manual_layout.addWidget(self.prop_manual_radio)
        
        self.prop_ids_input = QLineEdit()
        self.prop_ids_input.setPlaceholderText("e.g., all / 101,102 / 101:201")
        self.prop_ids_input.setEnabled(False)
        manual_layout.addWidget(self.prop_ids_input, 1)
        
        pg_layout.addLayout(manual_layout)
        
        self.prop_manual_radio.toggled.connect(
            lambda checked: self.prop_ids_input.setEnabled(checked)
        )
        
        prop_group.setLayout(pg_layout)
        layout.addWidget(prop_group)
        
        # ALGORITHM SELECTION GROUP
        algo_group = QGroupBox("ALGORITHM")
        ag_layout = QVBoxLayout()
        
        self.algo_method_group = QButtonGroup()
        
        self.algo_lazy_radio = QRadioButton("Lazy (uniform thickness addition)")
        self.algo_sensitivity_radio = QRadioButton("Sensitivity-Based (smart targeting)")
        self.algo_gauss_radio = QRadioButton("Gaussian Process (optimization)")
        
        self.algo_method_group.addButton(self.algo_lazy_radio, 0)
        self.algo_method_group.addButton(self.algo_sensitivity_radio, 1)
        self.algo_method_group.addButton(self.algo_gauss_radio, 2)
        self.algo_sensitivity_radio.setChecked(True)  # Default to sensitivity
        
        ag_layout.addWidget(self.algo_lazy_radio)
        ag_layout.addWidget(self.algo_sensitivity_radio)
        ag_layout.addWidget(self.algo_gauss_radio)
        
        if not SKOPT_AVAILABLE:
            self.algo_gauss_radio.setEnabled(False)
            self.algo_gauss_radio.setToolTip("Install scikit-optimize: pip install scikit-optimize")
        
        algo_group.setLayout(ag_layout)
        layout.addWidget(algo_group)
        
        # SETTINGS GROUP
        settings = QGroupBox("SETTINGS")
        sl = QVBoxLayout()
        
        hl = QHBoxLayout()
        self.thickness_label = QLabel("Thickness (mm):")
        hl.addWidget(self.thickness_label)
        self.thickness_addition = QDoubleSpinBox()
        self.thickness_addition.setRange(0.1, 50.0)
        self.thickness_addition.setValue(0.736)
        self.thickness_addition.setDecimals(3)
        hl.addWidget(self.thickness_addition)
        sl.addLayout(hl)
        
        self.algo_lazy_radio.toggled.connect(self.update_thickness_mode)
        self.algo_sensitivity_radio.toggled.connect(self.update_thickness_mode)
        self.algo_gauss_radio.toggled.connect(self.update_thickness_mode)

        hl = QHBoxLayout()
        hl.addWidget(QLabel("Target RF:"))
        self.target_rf = QDoubleSpinBox()
        self.target_rf.setRange(1.0, 5.0)
        self.target_rf.setValue(1.0)
        self.target_rf.setDecimals(2)
        hl.addWidget(self.target_rf)
        sl.addLayout(hl)
        
        hl = QHBoxLayout()
        hl.addWidget(QLabel("Max Iterations:"))
        self.max_iterations = QSpinBox()
        self.max_iterations.setRange(1, 100)
        self.max_iterations.setValue(20)
        hl.addWidget(self.max_iterations)
        sl.addLayout(hl)
        
        settings.setLayout(sl)
        layout.addWidget(settings)
        
        # STATUS GROUP
        status = QGroupBox("STATUS")
        stl = QVBoxLayout()
        
        self.progress = QProgressBar()
        stl.addWidget(self.progress)
        
        for lbl, attr, clr in [("Status", "status_label", "#ff8800"),
                               ("Iteration", "iteration_label", "#00ff00"),
                               ("Critical", "critical_label", "#ff4400")]:
            hl = QHBoxLayout()
            hl.addWidget(QLabel(f"{lbl}:"))
            label = QLabel("Ready" if lbl == "Status" else ("0/0" if lbl == "Iteration" else "---"))
            label.setStyleSheet(f"color: {clr}; font-weight: bold;")
            setattr(self, attr, label)
            hl.addWidget(label, 1)
            stl.addLayout(hl)
        
        status.setLayout(stl)
        layout.addWidget(status)
        
        # START BUTTON
        self.start_btn = QPushButton("▶ Start Optimization")
        self.start_btn.setMinimumHeight(40)
        self.start_btn.clicked.connect(self.start_optimization)
        layout.addWidget(self.start_btn)
        
        # LOG
        log = QGroupBox("LOG")
        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        QVBoxLayout(log).addWidget(self.log_text)
        layout.addWidget(log, 1)
        
        return widget
    
    def update_thickness_mode(self):
        """Update thickness input label and range based on selected algorithm"""
        if self.algo_lazy_radio.isChecked() or self.algo_sensitivity_radio.isChecked():
            self.thickness_label.setText("Thickness (mm):")
            self.thickness_addition.setRange(0.1, 50.0)
            self.thickness_addition.setValue(0.736)
            self.thickness_addition.setDecimals(3)
            self.thickness_addition.setSuffix("")
        else:
            self.thickness_label.setText("Multiplier:")
            self.thickness_addition.setRange(1.0, 10.0)
            self.thickness_addition.setValue(3.0)
            self.thickness_addition.setDecimals(1)
        
    def parse_property_ids(self, input_str: str, bdf) -> Set[int]:
        """Parse property ID input string and return set of property IDs"""
        input_str = input_str.strip().lower()
        
        if input_str == 'all':
            all_props = set()
            for pid, prop in bdf.properties.items():
                if prop.type in ['PCOMP', 'PCOMPG', 'PSHELL']:
                    all_props.add(pid)
            self.log(f"Selected ALL properties: {len(all_props)} found")
            return all_props
        
        prop_ids = set()
        parts = input_str.split(',')
        
        for part in parts:
            part = part.strip()
            if ':' in part:
                try:
                    start, end = part.split(':')
                    start, end = int(start), int(end)
                    prop_ids.update(range(start, end + 1))
                except ValueError:
                    self.log(f"<span style='color:#ffb74d'>Warning: Invalid range '{part}'</span>")
            else:
                try:
                    prop_ids.add(int(part))
                except ValueError:
                    self.log(f"<span style='color:#ffb74d'>Warning: Invalid ID '{part}'</span>")
        
        valid_props = set()
        for pid in prop_ids:
            if pid in bdf.properties:
                prop = bdf.properties[pid]
                if prop.type in ['PCOMP', 'PCOMPG', 'PSHELL']:
                    valid_props.add(pid)
                else:
                    self.log(f"<span style='color:#ffb74d'>Warning: PID {pid} not composite/shell</span>")
            else:
                self.log(f"<span style='color:#ffb74d'>Warning: PID {pid} not found in BDF</span>")
        
        self.log(f"Selected {len(valid_props)} properties: {sorted(list(valid_props))[:10]}{'...' if len(valid_props) > 10 else ''}")
        return valid_props
        
    
    def log(self, msg):
        self.log_text.append(f"<span style='color:#808080'>{time.strftime('%H:%M:%S')}</span> {msg}")
        QApplication.processEvents()
    
    def my_read_bdf(self, path):
        """Try reading BDF with different parameter combinations"""
        for punch in [False, True]:
            for xref in [False, True]:
                try:
                    return read_bdf(path, xref=xref, punch=punch)
                except:
                    continue
        raise IOError(f"Failed to read BDF: {path}")
    
    def browse_bdf(self):
        f, _ = QFileDialog.getOpenFileName(self, "Select BDF", "", "BDF (*.bdf)")
        if f: self.bdf_path.setText(f)
    
    def browse_op2(self):
        f, _ = QFileDialog.getOpenFileName(self, "Select OP2", "", "OP2 (*.op2)")
        if f: self.op2_path.setText(f)
    
    def browse_excel(self):
        f, _ = QFileDialog.getOpenFileName(self, "Select Excel", "", "Excel (*.xlsx *.xls)")
        if f: self.excel_path.setText(f)
    
    def browse_nastran(self):
        f, _ = QFileDialog.getOpenFileName(self, "Select Nastran", "", "EXE (*.exe)")
        if f: self.nastran_path.setText(f)
    
    def _cleanup_previous_run(self):
        """Cleanup memory from previous optimization run"""
        if hasattr(self, 'node_to_shells_cache') and self.node_to_shells_cache:
            self.node_to_shells_cache.clear()
        self.node_to_shells_cache = None
        
        if hasattr(self, 'target_pcomp_ids') and self.target_pcomp_ids:
            self.target_pcomp_ids.clear()
        self.target_pcomp_ids = None
        
        if hasattr(self, 'iteration_data'):
            self.iteration_data.clear()
        self.iteration_data = []
        
        import gc
        gc.collect()
    
    def start_optimization(self):
        """Main entry point for optimization - starts worker thread"""
        # Validate file paths
        self._cleanup_previous_run()
        
        for p, n in [(self.bdf_path, "BDF"), (self.op2_path, "OP2"),
                     (self.excel_path, "Excel"), (self.nastran_path, "Nastran")]:
            if not os.path.exists(p.text()):
                QMessageBox.critical(self, "Error", f"{n} not found!")
                return
        
        if self.algo_gauss_radio.isChecked() and not SKOPT_AVAILABLE:
            QMessageBox.critical(self, "Error", 
                "Gaussian Process requires scikit-optimize.\nInstall with: pip install scikit-optimize")
            return
        
        if self.prop_manual_radio.isChecked():
            if not self.prop_ids_input.text().strip():
                QMessageBox.critical(self, "Error", "Please enter property IDs!")
                return
        
        # Disable button and reset state
        self.start_btn.setEnabled(False)
        self.status_label.setText("Running...")
        self.iteration_data = []
        self.node_to_shells_cache = None
        self.target_pcomp_ids = None
        
        # Calculate initial mass
        try:
            bdf = self.my_read_bdf(self.bdf_path.text())
            self.initial_mass, _, _ = mass_properties(bdf)
            self.log(f"<span style='color:#81c784'>Initial mass: {self.initial_mass:.2f} kg</span>")
        except Exception as e:
            self.log(f"<span style='color:#ffb74d'>Warning: Could not calculate mass - {e}</span>")
            self.initial_mass = None
        
        # Create and configure worker thread
        self.worker = OptimizationWorker(self)
        if self.algo_lazy_radio.isChecked():
            self.worker.algorithm = 'lazy'
        elif self.algo_sensitivity_radio.isChecked():
            self.worker.algorithm = 'sensitivity'
        else:
            self.worker.algorithm = 'gaussian'
        
        # Connect signals
        self.worker.log_signal.connect(self.log)
        self.worker.progress_signal.connect(self.update_progress)
        self.worker.status_signal.connect(self.update_status)
        self.worker.finished_signal.connect(self.optimization_finished)
        
        # Start the thread
        self.worker.start()
    
    def update_status(self, text, color):
        """Update status label from thread"""
        self.status_label.setText(text)
        self.status_label.setStyleSheet(f"color: {color}; font-weight: bold;")
    
    
    def optimization_finished(self, success, message):
        """Called when optimization thread completes"""
        self.status_label.setText("✓ Done" if success else "⚠ Stopped")
        self.status_label.setStyleSheet(f"color: {'#81c784' if success else '#ffb74d'}; font-weight: bold;")
        
        (QMessageBox.information if success else QMessageBox.warning)(self, "Result", message)
        
        self.start_btn.setEnabled(True)
        self.worker = None
    
    
    def calculate_sensitivities_neighbor(self, df_crit: pd.DataFrame, target_rf: float) -> Dict[int, float]:
        """Calculate property sensitivities based on RF deficits - Neighbor mode"""
        pid_deficits = {}
        
        for _, row in df_crit.iterrows():
            rf_deficit = max(0, target_rf - row['RF'])
            
            # Parse neighbors
            try:
                neighbors = ast.literal_eval(row['neighbors']) if pd.notna(row['neighbors']) else []
            except:
                neighbors = []
            
            # Distribute deficit to neighbors
            if neighbors:
                deficit_per_prop = rf_deficit / len(neighbors)
                for pid in neighbors:
                    pid_deficits[pid] = pid_deficits.get(pid, 0) + deficit_per_prop
        
        # Normalize sensitivities to [0, 1]
        if pid_deficits:
            max_deficit = max(pid_deficits.values())
            if max_deficit > 0:
                pid_sensitivities = {pid: deficit / max_deficit for pid, deficit in pid_deficits.items()}
            else:
                pid_sensitivities = {pid: 1.0 for pid in pid_deficits}
            
            self.worker.log_signal.emit(f"<span style='color:#81c784'>Calculated sensitivities for {len(pid_sensitivities)} properties</span>")
            
            # Show top 5 most sensitive
            top_5 = sorted(pid_sensitivities.items(), key=lambda x: -x[1])[:5]
            for pid, sens in top_5:
                self.worker.log_signal.emit(f"  PID {pid}: sensitivity = {sens:.3f}")
            
            return pid_sensitivities
        
        return {}
    
    def calculate_sensitivities_unified(self, bdf, df_crit, target_rf, target_pids):
        """Smart sensitivity for both neighbor and manual modes"""
        pid_sensitivities = {}
        
        for _, row in df_crit.iterrows():
            rf_deficit = max(0, target_rf - row['RF'])
            cbar_elem = bdf.elements[row['elid']]
            
            # Find connected shell properties
            connected_pids = []
            if self.prop_neighbor_radio.isChecked():
                # Use pre-calculated neighbors
                try:
                    connected_pids = ast.literal_eval(row['neighbors'])
                except:
                    pass
            else:
                # Find which manual PIDs are connected to this CBAR
                for nid in cbar_elem.nodes:
                    for shell_eid in self.node_to_shells_cache.get(nid, []):
                        shell = bdf.elements[shell_eid]
                        if shell.pid in target_pids:
                            connected_pids.append(shell.pid)
            
            # Distribute deficit weighted by number of connections
            if connected_pids:
                for pid in set(connected_pids):
                    # More occurrences = more influence
                    influence = connected_pids.count(pid) / len(connected_pids)
                    pid_sensitivities[pid] = pid_sensitivities.get(pid, 0) + rf_deficit * influence
        
        # Normalize
        if pid_sensitivities:
            self.worker.log_signal.emit(f"<span style='color:#81c784'>Calculated sensitivities for {len(pid_sensitivities)} properties</span>")
            
            # Show top 5 most sensitive
            top_5 = sorted(pid_sensitivities.items(), key=lambda x: -x[1])[:5]
            for pid, sens in top_5:
                self.worker.log_signal.emit(f"  PID {pid}: sensitivity = {sens:.3f}")
        
        return pid_sensitivities

    def update_pcomp_sensitivity(self, bdf, pid_sensitivities: Dict[int, float], 
                                base_thickness: float, learning_rate: float) -> List[int]:
        """Update PCOMP/PSHELL thicknesses based on sensitivities"""
        upd = []
        
        for pid, sensitivity in sorted(pid_sensitivities.items()):
            if pid in bdf.properties:
                prop = bdf.properties[pid]
                
                # Calculate thickness addition based on sensitivity
                thickness_add = base_thickness * sensitivity * learning_rate
                
                if prop.type in ['PCOMP', 'PCOMPG']:
                    old_thick = prop.thicknesses[0]
                    prop.thicknesses[0] += thickness_add
                    new_thick = prop.thicknesses[0]
                    total = sum(prop.thicknesses)
                    
                    upd.append(pid)
                    self.worker.log_signal.emit(
                        f"  PID {pid}: {old_thick:.3f} → {new_thick:.3f} mm "
                        f"(+{thickness_add:.3f}, sens={sensitivity:.2f}, total={total:.3f})"
                    )
                    
                elif prop.type == 'PSHELL':
                    old_thick = prop.t
                    prop.t += thickness_add
                    new_thick = prop.t
                    
                    upd.append(pid)
                    self.worker.log_signal.emit(
                        f"  PID {pid}: {old_thick:.3f} → {new_thick:.3f} mm "
                        f"(+{thickness_add:.3f}, sens={sensitivity:.2f})"
                    )
        
        return upd
    
    def run_sensitivity_optimization_thread(self):
        """Sensitivity-based optimization algorithm - OPTIMIZED VERSION"""
        bdf_orig = self.bdf_path.text()
        op2_orig = self.op2_path.text()
        excel = self.excel_path.text()
        nastran = self.nastran_path.text()
        base_thick_add = self.thickness_addition.value()
        target = self.target_rf.value()
        max_iter = self.max_iterations.value()
        
        work_dir = os.path.dirname(bdf_orig)
        base = os.path.splitext(os.path.basename(bdf_orig))[0]
        
        # Read Excel
        self.worker.log_signal.emit("Reading Excel...")
        df_in = pd.read_excel(excel).sort_values('elid').reset_index(drop=True)
        given_list = df_in["elid"].tolist()
        
        use_neighbor = self.prop_neighbor_radio.isChecked()
        
        self.worker.log_signal.emit("Property selection: NEIGHBOR APPROACH" if use_neighbor else "Property selection: MANUAL IDs")
        self.worker.log_signal.emit(f"<span style='color:#4fc3f7'>SENSITIVITY-BASED ALGORITHM</span>")
        self.worker.log_signal.emit(f"Monitoring {len(df_in)} elements | RF: {target} | Base: {base_thick_add}mm")
        self.worker.log_signal.emit("="*60)
        
        # ========== KEY OPTIMIZATION: Load BDF once, keep in memory ==========
        self.worker.log_signal.emit("Loading BDF into memory...")
        bdf = self.my_read_bdf(bdf_orig)
        
        # Build connectivity ONCE before loop
        self.worker.log_signal.emit("Building connectivity cache...")
        self.node_to_shells_cache = self.build_connectivity(bdf)
        
        # Parse manual properties if needed
        if not use_neighbor:
            self.target_pcomp_ids = self.parse_property_ids(self.prop_ids_input.text(), bdf)
            if not self.target_pcomp_ids:
                return False, "No valid property IDs specified!"
        else:
            self.target_pcomp_ids = set()
        
        current_op2 = op2_orig
        iteration = 0
        all_updated = set()
        learning_rate = 1.0
        prev_crit_count = float('inf')
        
        while iteration < max_iter:
            iteration += 1
            self.worker.log_signal.emit(f"\n<span style='color:#4fc3f7;font-weight:bold'>ITERATION {iteration}</span>")
            
            iter_dir = os.path.join(work_dir, f"iteration_{iteration}")
            os.makedirs(iter_dir, exist_ok=True)
            
            # Read OP2
            op2 = read_op2(current_op2, build_dataframe=True)
            
            # Calculate RF (using in-memory BDF)
            if use_neighbor:
                df_res = self.calc_rf_with_neighbors(bdf, op2, df_in, given_list)
            else:
                df_res = self.calc_rf_simple(bdf, op2, df_in, given_list)
            
            df_crit = df_res[df_res['RF'] < target]
            n_crit = len(df_crit)
            
            # Calculate mass
            try:
                mass, _, _ = mass_properties(bdf)
                self.worker.log_signal.emit(f"Mass: {mass:.2f} kg")
            except Exception as e:
                self.worker.log_signal.emit(f"<span style='color:#ffb74d'>Mass calculation failed: {e}</span>")
                mass = None
            
            # Emit progress
            thick_str = df_res['neighbors_thicks'].iloc[0] if 'neighbors_thicks' in df_res.columns else df_res['chosen_thicks'].iloc[0]
            prop_str = str(sorted(list(self.target_pcomp_ids)))
            
            self.worker.progress_signal.emit(iteration, max_iter, n_crit, 
                                df_res['RF'].dropna().tolist(), mass, thick_str, prop_str)
                        
            # Check convergence
            if n_crit == 0:
                final_bdf = os.path.join(work_dir, f"{base}_optimized_sensitivity.bdf")
                bdf.write_bdf(final_bdf)  # Write once at end
                res_file = self.save_results(work_dir, base, iteration, df_res, all_updated)
                return True, f"✓ Optimization converged!\n\nAll elements meet RF ≥ {target}\n\nResults: {res_file}\nBDF: {final_bdf}"
            
            self.worker.log_signal.emit(f"<span style='color:#e57373'>Critical elements: {n_crit}</span>")
            
            # Adaptive learning rate
            if n_crit < prev_crit_count:
                learning_rate = min(learning_rate * 1.1, 2.0)
                self.worker.log_signal.emit(f"<span style='color:#81c784'>Progress! LR increased to {learning_rate:.2f}</span>")
            else:
                learning_rate = max(learning_rate * 0.7, 0.3)
                self.worker.log_signal.emit(f"<span style='color:#ffb74d'>Stalled. LR decreased to {learning_rate:.2f}</span>")
            prev_crit_count = n_crit
            
            # Calculate sensitivities
            pid_sensitivities = self.calculate_sensitivities_unified(bdf, df_crit, target, self.target_pcomp_ids)
            
            if not pid_sensitivities:
                return False, "No properties identified for update!"
            
            # ========== KEY: Update properties IN MEMORY (no file I/O) ==========
            upd = self.update_pcomp_sensitivity(bdf, pid_sensitivities, base_thick_add, learning_rate)
            all_updated.update(upd)
            
            # Track properties
            if use_neighbor:
                self.target_pcomp_ids.update(pid_sensitivities.keys())
            
            # ========== Write BDF only when needed (for Nastran run) ==========
            iter_bdf = os.path.join(iter_dir, f"{base}_iteration{iteration}.bdf")
            bdf.write_bdf(iter_bdf)
            self.worker.log_signal.emit(f"Saved: {iter_bdf}")
            
            # Save Excel results
            iter_excel = os.path.join(iter_dir, f"iteration{iteration}_results.xlsx")
            with pd.ExcelWriter(iter_excel) as w:
                df_res.to_excel(w, 'All', index=False)
                df_crit.to_excel(w, 'Critical', index=False)
                
                df_sens = pd.DataFrame([
                    {'PropertyID': pid, 'Sensitivity': sens, 'ThicknessAdded': sens * base_thick_add * learning_rate}
                    for pid, sens in sorted(pid_sensitivities.items(), key=lambda x: -x[1])
                ])
                df_sens.to_excel(w, 'Sensitivities', index=False)
            
            self.worker.log_signal.emit(f"Saved: {iter_excel}")
            
            # Run Nastran
            self.worker.log_signal.emit("Running Nastran...")
            if not self.run_nastran(nastran, iter_bdf):
                return False, "Nastran analysis failed!"
            
            # Update OP2 path for next iteration
            iter_op2 = iter_bdf.replace('.bdf', '.op2')
            
            if os.path.exists(iter_op2):
                current_op2 = iter_op2
                self.worker.log_signal.emit(f"Using OP2: {current_op2}")
            else:
                self.worker.log_signal.emit("<span style='color:#ffb74d'>Warning: OP2 not found, using original</span>")
                current_op2 = op2_orig
            
            # ========== KEY: Don't reload BDF - continue with in-memory version ==========
            # The BDF object already has the updates from update_pcomp_sensitivity
        
        # Max iterations reached
        final_bdf = os.path.join(work_dir, f"{base}_optimized_sensitivity_maxiter.bdf")
        bdf.write_bdf(final_bdf)
        res_file = self.save_results(work_dir, base, iteration, df_res, all_updated)
        return False, f"⚠ Max iterations reached\n\nCritical elements: {n_crit}\n\nResults: {res_file}\nBDF: {final_bdf}"

    def run_lazy_optimization_thread(self):
        """Iterative thickness addition algorithm - OPTIMIZED VERSION"""
        bdf_orig = self.bdf_path.text()
        op2_orig = self.op2_path.text()
        excel = self.excel_path.text()
        nastran = self.nastran_path.text()
        thick_add = self.thickness_addition.value()
        target = self.target_rf.value()
        max_iter = self.max_iterations.value()
        
        work_dir = os.path.dirname(bdf_orig)
        base = os.path.splitext(os.path.basename(bdf_orig))[0]
        
        # Read Excel
        self.worker.log_signal.emit("Reading Excel...")
        df_in = pd.read_excel(excel).sort_values('elid').reset_index(drop=True)
        given_list = df_in["elid"].tolist()
        
        use_neighbor = self.prop_neighbor_radio.isChecked()
        
        self.worker.log_signal.emit("Property selection: NEIGHBOR APPROACH" if use_neighbor else "Property selection: MANUAL IDs")
        self.worker.log_signal.emit(f"Monitoring {len(df_in)} elements | RF: {target} | +{thick_add}mm")
        self.worker.log_signal.emit("="*60)
        
        # ========== KEY OPTIMIZATION: Load BDF once, keep in memory ==========
        self.worker.log_signal.emit("Loading BDF into memory...")
        bdf = self.my_read_bdf(bdf_orig)
        
        # Build connectivity ONCE before loop
        self.worker.log_signal.emit("Building connectivity cache...")
        self.node_to_shells_cache = self.build_connectivity(bdf)
        
        # Parse manual properties if needed
        if not use_neighbor:
            self.target_pcomp_ids = self.parse_property_ids(self.prop_ids_input.text(), bdf)
            if not self.target_pcomp_ids:
                return False, "No valid property IDs specified!"
        else:
            self.target_pcomp_ids = set()
        
        current_op2 = op2_orig
        iteration = 0
        all_updated = set()
        
        while iteration < max_iter:
            iteration += 1
            self.worker.log_signal.emit(f"\n<span style='color:#4fc3f7;font-weight:bold'>ITERATION {iteration}</span>")
            
            iter_dir = os.path.join(work_dir, f"iteration_{iteration}")
            os.makedirs(iter_dir, exist_ok=True)
            
            
            # Read OP2
            op2 = read_op2(current_op2, build_dataframe=True)
            
            # Calculate RF (using in-memory BDF)
            if use_neighbor:
                df_res = self.calc_rf_with_neighbors(bdf, op2, df_in, given_list)
            else:
                df_res = self.calc_rf_simple(bdf, op2, df_in, given_list)
            
            df_crit = df_res[df_res['RF'] < target]
            n_crit = len(df_crit)
            
            # Calculate mass
            try:
                mass, _, _ = mass_properties(bdf)
                self.worker.log_signal.emit(f"Mass: {mass:.2f} kg")
            except Exception as e:
                self.worker.log_signal.emit(f"<span style='color:#ffb74d'>Mass calculation failed: {e}</span>")
                mass = None
            
            # Emit progress
            thick_str = df_res['neighbors_thicks'].iloc[0] if 'neighbors_thicks' in df_res.columns else df_res['chosen_thicks'].iloc[0]
            prop_str = str(sorted(list(self.target_pcomp_ids)))
            
            self.worker.progress_signal.emit(iteration, max_iter, n_crit, 
                                df_res['RF'].dropna().tolist(), mass, thick_str, prop_str)
            
            # Check convergence
            if n_crit == 0:
                final_bdf = os.path.join(work_dir, f"{base}_optimized.bdf")
                bdf.write_bdf(final_bdf)  # Write once at end
                res_file = self.save_results(work_dir, base, iteration, df_res, all_updated)
                return True, f"✓ Optimization converged!\n\nAll elements meet RF ≥ {target}\n\nResults: {res_file}\nBDF: {final_bdf}"
            
            self.worker.log_signal.emit(f"<span style='color:#e57373'>Critical elements: {n_crit}</span>")
            
            # Determine which properties to update
            if use_neighbor:
                pcomp_upd = set()
                for ns in df_crit['neighbors']:
                    if pd.notna(ns) and ns != '[]':
                        try:
                            pcomp_upd.update(ast.literal_eval(ns))
                        except:
                            pass
                
                if not pcomp_upd:
                    return False, "No PCOMP neighbors found for critical elements!"
                
                self.target_pcomp_ids.update(pcomp_upd)
            else:
                pcomp_upd = self.target_pcomp_ids.copy()
            
            self.worker.log_signal.emit(f"Updating {len(pcomp_upd)} properties")
            
            # ========== KEY: Update properties IN MEMORY (no file I/O) ==========
            upd = self.update_pcomp(bdf, pcomp_upd, thick_add)
            all_updated.update(upd)
            
            # ========== Write BDF only when needed (for Nastran run) ==========
            iter_bdf = os.path.join(iter_dir, f"{base}_iteration{iteration}.bdf")
            bdf.write_bdf(iter_bdf)
            self.worker.log_signal.emit(f"Saved: {iter_bdf}")
            
            # Save Excel results
            iter_excel = os.path.join(iter_dir, f"iteration{iteration}_results.xlsx")
            with pd.ExcelWriter(iter_excel) as w:
                df_res.to_excel(w, 'All', index=False)
                df_crit.to_excel(w, 'Critical', index=False)
            self.worker.log_signal.emit(f"Saved: {iter_excel}")
            
            # Run Nastran
            self.worker.log_signal.emit("Running Nastran...")
            if not self.run_nastran(nastran, iter_bdf):
                return False, "Nastran analysis failed!"
            
            # Update OP2 path for next iteration
            iter_op2 = iter_bdf.replace('.bdf', '.op2')
            
            if os.path.exists(iter_op2):
                current_op2 = iter_op2
                self.worker.log_signal.emit(f"Using OP2: {current_op2}")
            else:
                self.worker.log_signal.emit("<span style='color:#ffb74d'>Warning: OP2 not found, using original</span>")
                current_op2 = op2_orig
            
            # ========== KEY: Don't reload BDF - continue with in-memory version ==========
        
        # Max iterations reached
        final_bdf = os.path.join(work_dir, f"{base}_optimized_maxiter.bdf")
        bdf.write_bdf(final_bdf)
        res_file = self.save_results(work_dir, base, iteration, df_res, all_updated)
        return False, f"⚠ Max iterations reached\n\nCritical elements: {n_crit}\n\nResults: {res_file}\nBDF: {final_bdf}"


    # ==============================================================================
    # FIX 6: GAUSSIAN OPTIMIZATION - OPTIMIZED VERSION
    # ==============================================================================
    
    def run_gaussian_optimization_thread(self):
        """Gaussian Process optimization - OPTIMIZED VERSION"""
        bdf_orig = self.bdf_path.text()
        op2_orig = self.op2_path.text()
        excel = self.excel_path.text()
        nastran = self.nastran_path.text()
        target_rf = self.target_rf.value()
        max_iter = self.max_iterations.value()
        
        work_dir = os.path.dirname(bdf_orig)
        base = os.path.splitext(os.path.basename(bdf_orig))[0]
        
        # Read Excel
        self.worker.log_signal.emit("Reading Excel...")
        df_in = pd.read_excel(excel).sort_values('elid').reset_index(drop=True)
        given_list = df_in["elid"].tolist()
        
        # Determine property selection
        use_neighbor = self.prop_neighbor_radio.isChecked()
        
        # ========== KEY OPTIMIZATION: Load BDF once ==========
        self.worker.log_signal.emit("Loading BDF into memory...")
        bdf_base = self.my_read_bdf(bdf_orig)
        
        # Build connectivity ONCE
        self.worker.log_signal.emit("Building connectivity cache...")
        self.node_to_shells_cache = self.build_connectivity(bdf_base)
        
        if use_neighbor:
            self.worker.log_signal.emit("Property selection: NEIGHBOR APPROACH")
            
            # Use base BDF to identify target properties
            op2 = read_op2(op2_orig, build_dataframe=True)
            
            self.target_pcomp_ids = set()
            df_res = self.calc_rf_with_neighbors(bdf_base, op2, df_in, given_list)
            df_crit = df_res[df_res['RF'] < target_rf]
            
            pcomp_target = set()
            for ns in df_crit['neighbors']:
                if pd.notna(ns) and ns != '[]':
                    try:
                        pcomp_target.update(ast.literal_eval(ns))
                    except:
                        pass
            
            if not pcomp_target:
                return False, "No PCOMP neighbors found!"
            
            self.target_pcomp_ids = pcomp_target
        else:
            self.worker.log_signal.emit("Property selection: MANUAL IDs")
            self.target_pcomp_ids = self.parse_property_ids(self.prop_ids_input.text(), bdf_base)
            if not self.target_pcomp_ids:
                return False, "No valid property IDs specified!"
        
        self.worker.log_signal.emit(f"Optimizing {len(self.target_pcomp_ids)} properties")
        self.worker.log_signal.emit(f"Target RF: {target_rf}")
        self.worker.log_signal.emit("="*60)
        
        # Store original thicknesses
        original_thicknesses = {}
        for pid in self.target_pcomp_ids:
            prop = bdf_base.properties[pid]
            if prop.type in ['PCOMP', 'PCOMPG']:
                original_thicknesses[pid] = prop.thicknesses[0]
            elif prop.type == 'PSHELL':
                original_thicknesses[pid] = prop.t
        
        # ========== KEY OPTIMIZATION: Keep BDF in memory for objective function ==========
        iteration_count = [0]
        
        def objective(thickness_multipliers):
            iteration_count[0] += 1
            iteration = iteration_count[0]
            
            self.worker.log_signal.emit(f"\n<span style='color:#4fc3f7;font-weight:bold'>GP ITERATION {iteration}</span>")
            
            # Create iteration directory
            iter_dir = os.path.join(work_dir, f"gp_iteration_{iteration}")
            os.makedirs(iter_dir, exist_ok=True)
            
            # ========== KEY: Create fresh BDF copy in memory (fast) ==========
            # Instead of reading from disk, copy the base object
            bdf = self.my_read_bdf(bdf_orig)  # Still need to read for GP iterations
            
            # Apply thickness multipliers IN MEMORY
            for i, pid in enumerate(sorted(self.target_pcomp_ids)):
                multiplier = thickness_multipliers[i]
                prop = bdf.properties[pid]
                
                if prop.type in ['PCOMP', 'PCOMPG']:
                    prop.thicknesses[0] = original_thicknesses[pid] * multiplier
                elif prop.type == 'PSHELL':
                    prop.t = original_thicknesses[pid] * multiplier
            
            # Write BDF for Nastran
            iter_bdf = os.path.join(iter_dir, f"{base}_gp{iteration}.bdf")
            bdf.write_bdf(iter_bdf)
            
            # Run Nastran
            self.worker.log_signal.emit("Running Nastran...")
            if not self.run_nastran(nastran, iter_bdf):
                self.worker.log_signal.emit("<span style='color:#e57373'>Nastran failed, returning penalty</span>")
                return 1e6
            
            # Wait briefly for file system
            time.sleep(0.5)
            
            # Find OP2
            iter_op2 = iter_bdf.replace('.bdf', '.op2')
            if not os.path.exists(iter_op2):
                self.worker.log_signal.emit("<span style='color:#e57373'>OP2 not found, returning penalty</span>")
                return 1e6
            
            # Calculate RF
            try:
                op2 = read_op2(iter_op2, build_dataframe=True)
                
                # Use optimized RF calculation
                if use_neighbor:
                    df_res = self.calc_rf_with_neighbors(bdf, op2, df_in, given_list)
                else:
                    df_res = self.calc_rf_simple(bdf, op2, df_in, given_list)
                
                df_crit = df_res[df_res['RF'] < target_rf]
                n_crit = len(df_crit)
                
                # Calculate mass
                try:
                    mass, _, _ = mass_properties(bdf)
                except:
                    mass = None
                
                # Update UI via signal
                thick_str = df_res['neighbors_thicks'].iloc[0] if 'neighbors_thicks' in df_res.columns else df_res['chosen_thicks'].iloc[0]
                prop_str = str(sorted(list(self.target_pcomp_ids)))
                
                self.worker.progress_signal.emit(iteration, max_iter, n_crit, 
                                df_res['RF'].dropna().tolist(), mass, thick_str, prop_str)
                
                # Objective: minimize critical count + mass penalty
                mass_penalty = 0
                if mass and self.initial_mass:
                    mass_increase = (mass - self.initial_mass) / self.initial_mass
                    mass_penalty = max(0, mass_increase * 100)
                
                objective_value = n_crit + mass_penalty
                
                self.worker.log_signal.emit(f"Critical: {n_crit}, Mass penalty: {mass_penalty:.2f}, Objective: {objective_value:.2f}")
                
                # Save results
                with pd.ExcelWriter(os.path.join(iter_dir, f"gp{iteration}_results.xlsx")) as w:
                    df_res.to_excel(w, 'All', index=False)
                    df_crit.to_excel(w, 'Critical', index=False)
                
                return objective_value
                
            except Exception as e:
                self.worker.log_signal.emit(f"<span style='color:#e57373'>Error in evaluation: {e}</span>")
                return 1e6
        
        # Define search space
        n_props = len(self.target_pcomp_ids)
        max_multi = self.thickness_addition.value()
        space = [Real(1.0, max_multi, name=f'mult_{i}') for i in range(n_props)]
        x0 = [1.0] * n_props
        
        self.worker.log_signal.emit(f"Starting Gaussian Process optimization...")
        self.worker.log_signal.emit(f"Search space: {n_props} properties, multipliers [1.0, {max_multi:.1f}]")
        
        # Run optimization
        try:
            result = gp_minimize(
                objective,
                space,
                x0=[x0],
                n_calls=min(max_iter, 30),
                random_state=42,
                verbose=False
            )
            
            self.worker.log_signal.emit(f"\n<span style='color:#81c784'>GP Optimization complete!</span>")
            self.worker.log_signal.emit(f"Best objective: {result.fun:.2f}")
            self.worker.log_signal.emit(f"Best multipliers: {[f'{x:.3f}' for x in result.x]}")
            
            # ========== Apply best solution to fresh BDF ==========
            bdf = self.my_read_bdf(bdf_orig)
            
            for i, pid in enumerate(sorted(self.target_pcomp_ids)):
                multiplier = result.x[i]
                prop = bdf.properties[pid]
                
                if prop.type in ['PCOMP', 'PCOMPG']:
                    new_thick = original_thicknesses[pid] * multiplier
                    prop.thicknesses[0] = new_thick
                    self.worker.log_signal.emit(f"  PID {pid}: {original_thicknesses[pid]:.3f} → {new_thick:.3f} mm (×{multiplier:.3f})")
                elif prop.type == 'PSHELL':
                    new_thick = original_thicknesses[pid] * multiplier
                    prop.t = new_thick
                    self.worker.log_signal.emit(f"  PID {pid}: {original_thicknesses[pid]:.3f} → {new_thick:.3f} mm (×{multiplier:.3f})")
            
            # Save final BDF
            final_bdf = os.path.join(work_dir, f"{base}_optimized_gp.bdf")
            bdf.write_bdf(final_bdf)
            
            # Run Nastran on final BDF
            self.worker.log_signal.emit("Running final Nastran analysis...")
            if not self.run_nastran(nastran, final_bdf):
                return False, "Final Nastran analysis failed!"
            
            time.sleep(0.5)
            
            # Final evaluation
            final_op2 = final_bdf.replace('.bdf', '.op2')
            if os.path.exists(final_op2):
                op2 = read_op2(final_op2, build_dataframe=True)
                
                if use_neighbor:
                    df_res = self.calc_rf_with_neighbors(bdf, op2, df_in, given_list)
                else:
                    df_res = self.calc_rf_simple(bdf, op2, df_in, given_list)
                
                res_file = self.save_results(work_dir, base, iteration_count[0], 
                                            df_res, self.target_pcomp_ids)
                
                n_crit_final = len(df_res[df_res['RF'] < target_rf])
                
                if n_crit_final == 0:
                    return True, f"✓ GP Optimization converged!\n\nResults: {res_file}\nBDF: {final_bdf}"
                else:
                    return False, f"⚠ GP completed but {n_crit_final} critical elements remain\n\nResults: {res_file}\nBDF: {final_bdf}"
            else:
                return False, "Could not perform final evaluation - OP2 not found"
                
        except Exception as e:
            import traceback
            self.worker.log_signal.emit(f"<span style='color:#e57373'>GP optimization error: {e}</span>")
            self.worker.log_signal.emit(f"<span style='color:#e57373'>{traceback.format_exc()}</span>")
            return False, f"GP optimization failed: {str(e)}"
    
        
    def calc_rf_with_neighbors(self, bdf, op2, df_in, given_list):
        """Calculate RF WITH neighbor detection - OPTIMIZED"""
        cbar = getattr(op2.op2_results.force, 'cbar_force', None) or op2.cbar_force
        
        # Pre-filter BEFORE concatenation to reduce memory
        dataframes = []
        for lc, df in cbar.items():
            df_reset = df.dataframe.reset_index()
            df_filtered = df_reset[df_reset['ElementID'].isin(given_list)]
            dataframes.append(df_filtered.assign(LoadCase=lc))
        
        df_f = pd.concat(dataframes, ignore_index=True)
        
        # Vectorized envelope - use transform for better performance
        df_env = df_f.loc[df_f.groupby('ElementID')['axial'].idxmax(), 
                 ['ElementID', 'axial', 'LoadCase']].reset_index(drop=True)
        
        df_res = df_in.merge(df_env, left_on='elid', right_on='ElementID', how='left')
        df_res.drop(columns=['ElementID'], inplace=True)
        
        dims, neighs, strs, rfs = [], [], [], []
        
        # Cache property lookups
        prop_cache = {}
        for elid in df_res['elid'].unique():
            elem = bdf.elements[elid]
            prop_cache[elid] = bdf.properties[elem.pid]
        
        target_rf = self.target_rf.value()
        
        for _, row in df_res.iterrows():
            prop = prop_cache[row['elid']]
            
            if prop.type == "PBARL":
                w, t = prop.dim[0], prop.dim[1]
                dims.append([w, t])
                
                # OPTIMIZATION: Only find neighbors for critical elements
                if row['RF'] < target_rf if 'RF' in df_res.columns else True:
                    neighs.append(self.find_neighbors(bdf, row['elid'], self.angle_tolerance))
                else:
                    neighs.append([])
                
                stress = row['axial'] / (w * t)
                strs.append(stress)
                rfs.append(abs(row['allowable'] / (stress + 1e-6)))
            else:
                dims.append(None)
                neighs.append([])
                strs.append(np.nan)
                rfs.append(np.nan)
        
        # Get thicknesses
        thicknesses = []
        if self.target_pcomp_ids:
            for pid in sorted(list(self.target_pcomp_ids)):
                if pid in bdf.properties:
                    if bdf.properties[pid].type == "PCOMP":
                        thicknesses.append(bdf.properties[pid].thicknesses[0])
                    elif bdf.properties[pid].type == "PSHELL":
                        thicknesses.append(bdf.properties[pid].t)
                
        df_res['dim'] = [str(d) for d in dims]
        df_res['neighbors'] = [str(n) for n in neighs]
        df_res['neighbors_thicks'] = str(thicknesses)
        df_res['stress'] = strs
        df_res['RF'] = rfs
        
        return df_res
    
    def calc_rf_simple(self, bdf, op2, df_in, given_list):
        """Calculate RF WITHOUT neighbor detection"""
        cbar = getattr(op2.op2_results.force, 'cbar_force', None) or op2.cbar_force
        
        df_f = pd.concat([df.dataframe.reset_index().assign(LoadCase=lc) 
                         for lc, df in cbar.items()], ignore_index=True)
        
        df_f = df_f[df_f['ElementID'].isin(given_list)]
        df_env = df_f.loc[df_f.groupby('ElementID')['axial'].idxmax(), 
                 ['ElementID', 'axial', 'LoadCase']].reset_index(drop=True)
        
        df_res = df_in.merge(df_env, left_on='elid', right_on='ElementID', how='left')
        df_res.drop(columns=['ElementID'], inplace=True)
        
        dims, strs, rfs = [], [], []
        
        for _, row in df_res.iterrows():
            elem = bdf.elements[row['elid']]
            prop = bdf.properties[elem.pid]
            
            if prop.type == "PBARL":
                w, t = prop.dim[0], prop.dim[1]
                dims.append([w, t])
                
                stress = row['axial'] / (w * t)
                strs.append(stress)
                rfs.append(abs(row['allowable'] / (stress + 1e-6)))
            else:
                dims.append(None)
                strs.append(np.nan)
                rfs.append(np.nan)
        
        # Get thicknesses (handle empty target_pcomp_ids)
        thicknesses = []
        if self.target_pcomp_ids:
            for pid in sorted(list(self.target_pcomp_ids)):
                if pid in bdf.properties:
                    if bdf.properties[pid].type == "PCOMP":
                        thicknesses.append(bdf.properties[pid].thicknesses[0])
                    elif bdf.properties[pid].type == "PSHELL":
                        thicknesses.append(bdf.properties[pid].t)
                
        df_res['dim'] = [str(d) for d in dims]
        df_res['chosen_pids'] = str(sorted(list(self.target_pcomp_ids))) if self.target_pcomp_ids else "[]"
        df_res['chosen_thicks'] = str(thicknesses)
        df_res['stress'] = strs
        df_res['RF'] = rfs
        
        return df_res
    
    
    def find_neighbors(self, bdf, elid: int, tol: float = 30.0) -> List[int]:
        """Find neighboring PCOMP/PSHELL properties connected to a CBAR element"""
        bar = bdf.elements[elid]
        
        p1 = np.array(bdf.nodes[bar.nodes[0]].get_position())
        p2 = np.array(bdf.nodes[bar.nodes[1]].get_position())
        
        bar_x = (p2 - p1)
        bar_x /= np.linalg.norm(bar_x)
        
        v = (np.array(bdf.nodes[bar.g0].get_position()) - p1 if bar.g0 
             else np.array(bar.x))
        
        if np.abs(np.dot(v/np.linalg.norm(v), bar_x)) > 0.99:
            v = np.array([1,0,0]) if np.abs(bar_x[0]) < 0.9 else np.array([0,1,0])
        
        v_proj = v - np.dot(v, bar_x) * bar_x
        bar_y = v_proj / np.linalg.norm(v_proj)
        bar_z = np.cross(bar_x, bar_y)
        
        cands = set()
        for nid in bar.nodes:
            cands.update(self.node_to_shells_cache.get(nid, []))
        
        neighs = []
        bar_set = set(bar.nodes)
        
        for eid in cands:
            elem = bdf.elements[eid]
            
            if len(set(elem.nodes) & bar_set) >= 2:
                prop = bdf.properties.get(elem.pid)
                
                if prop and prop.type in ['PCOMP', 'PCOMPG', 'PSHELL']:
                    nodes = (elem.nodes[:4] if elem.type in ['CQUAD4','CQUAD8'] 
                            else elem.nodes[:3])
                    
                    p0 = np.array(bdf.nodes[nodes[0]].get_position())
                    p1 = np.array(bdf.nodes[nodes[1]].get_position())
                    p2 = np.array(bdf.nodes[nodes[2]].get_position())
                    
                    norm = np.cross(p1-p0, p2-p0)
                    norm /= np.linalg.norm(norm)
                    
                    ang = np.arccos(np.clip(np.abs(np.dot(bar_z, norm)), 0, 1)) * 180/np.pi
                    
                    if ang <= tol and elem.pid not in neighs:
                        neighs.append(elem.pid)
        
        return neighs
    
    def build_connectivity(self, bdf) -> Dict[int, List[int]]:
        """Build node-to-shell-element connectivity map - OPTIMIZED"""
        node_to_elems = {}
        
        # Pre-filter by type to avoid checking every element
        shell_types = {'CQUAD4', 'CTRIA3', 'CQUAD8', 'CTRIA6'}
        
        for eid, elem in bdf.elements.items():
            if elem.type in shell_types:
                for nid in elem.nodes:
                    if nid not in node_to_elems:
                        node_to_elems[nid] = []
                    node_to_elems[nid].append(eid)
        
        self.worker.log_signal.emit(f"Built connectivity: {len(node_to_elems)} nodes")
        return node_to_elems
    
    def update_pcomp(self, bdf, pids: Set[int], add_mm: float) -> List[int]:
        """Update PCOMP/PSHELL thicknesses by adding specified amount"""
        upd = []
        
        for pid in sorted(pids):
            if pid in bdf.properties:
                prop = bdf.properties[pid]
                
                if prop.type in ['PCOMP', 'PCOMPG']:
                    old_thick = prop.thicknesses[0]
                    prop.thicknesses[0] += add_mm
                    new_thick = prop.thicknesses[0]
                    total = sum(prop.thicknesses)
                    
                    upd.append(pid)
                    self.log(f"  PID {pid}: {old_thick:.3f} → {new_thick:.3f} mm (total: {total:.3f} mm)")
                    
                elif prop.type == 'PSHELL':
                    old_thick = prop.t
                    prop.t += add_mm
                    new_thick = prop.t
                    
                    upd.append(pid)
                    self.log(f"  PID {pid}: {old_thick:.3f} → {new_thick:.3f} mm")
        
        return upd
    
    def run_nastran_hpc(self, exe: str, bdf: str) -> bool:
        """Run Nastran analysis - HPC-COMPATIBLE VERSION"""
        try:
            from pathlib import Path
            import glob
            
            bdf_path = Path(bdf)
            work_dir = bdf_path.parent
            base_name = bdf_path.stem
            
            # Expected output files
            op2_file = work_dir / f"{base_name}.op2"
            f06_file = work_dir / f"{base_name}.f06"
            log_file = work_dir / f"{base_name}.log"
            
            # Delete old output files to avoid false positives
            for old_file in [op2_file, f06_file, log_file]:
                if old_file.exists():
                    try:
                        old_file.unlink()
                    except:
                        pass
            
            self.worker.log_signal.emit(f"Starting Nastran: {bdf_path.name}")
            
            # Start Nastran with proper flags
            process = subprocess.Popen(
                [exe, bdf_path.name, "scr=yes", "old=no", "batch=no"],
                cwd=work_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.DEVNULL,  # Important for HPC!
                creationflags=subprocess.CREATE_NO_WINDOW if os.name == 'nt' else 0
            )
            
            # Method 1: Wait for process with timeout
            try:
                stdout, stderr = process.communicate(timeout=3600)  # 1 hour max
                return_code = process.returncode
            except subprocess.TimeoutExpired:
                self.worker.log_signal.emit("<span style='color:#e57373'>Nastran timeout (1 hour)</span>")
                process.kill()
                return False
            
            # Method 2: Poll for output files (handles HPC file system delays)
            self.worker.log_signal.emit("Waiting for Nastran outputs...")
            max_wait = 300  # 5 minutes for file system sync
            wait_interval = 2
            elapsed = 0
            
            while elapsed < max_wait:
                time.sleep(wait_interval)
                elapsed += wait_interval
                
                # Check if OP2 exists and is stable (size not changing)
                if op2_file.exists():
                    # Wait for file to be fully written
                    size1 = op2_file.stat().st_size
                    time.sleep(1)
                    size2 = op2_file.stat().st_size
                    
                    if size1 == size2 and size1 > 0:
                        self.worker.log_signal.emit(f"<span style='color:#81c784'>✓ OP2 found: {op2_file.name} ({size1:,} bytes)</span>")
                        break
                
                # Alternative: Check F06 for completion message
                if f06_file.exists():
                    try:
                        with open(f06_file, 'r', encoding='latin-1', errors='ignore') as f:
                            content = f.read()
                            if "FATAL" in content.upper():
                                self.worker.log_signal.emit("<span style='color:#e57373'>Nastran FATAL error detected</span>")
                                return False
                            if "USER INFORMATION MESSAGE" in content or "END OF JOB" in content:
                                # Job completed, wait a bit more for OP2
                                time.sleep(5)
                                break
                    except:
                        pass
                
                if elapsed % 10 == 0:
                    self.worker.log_signal.emit(f"  Waiting for outputs... ({elapsed}s)")
            
            # Final check
            if not op2_file.exists():
                self.worker.log_signal.emit("<span style='color:#e57373'>OP2 file not found after waiting</span>")
                
                # Try to find any .op2 files in directory (in case of naming issues)
                op2_files = list(work_dir.glob("*.op2"))
                if op2_files:
                    self.worker.log_signal.emit(f"<span style='color:#ffb74d'>Found other OP2: {op2_files[0].name}</span>")
                
                return False
            
            self.worker.log_signal.emit("<span style='color:#81c784'>✓ Nastran completed successfully</span>")
            return True
            
        except Exception as e:
            import traceback
            self.worker.log_signal.emit(f"<span style='color:#e57373'>Nastran error: {e}</span>")
            self.worker.log_signal.emit(f"<span style='color:#e57373'>{traceback.format_exc()}</span>")
            return False
    
    def run_nastran(self, exe: str, bdf: str) -> bool:
        """Run Nastran analysis - OPTIMIZED VERSION"""
        try:
            from pathlib import Path
            
            bdf_path = Path(bdf)
            work_dir = bdf_path.parent
            
            # Start Nastran process and WAIT for it (more efficient than polling)
            process = subprocess.Popen(
                [exe, bdf_path.name, "scr=yes", "old=no"],
                cwd=work_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                creationflags=subprocess.CREATE_NO_WINDOW if os.name == 'nt' else 0
            )
            
            # Wait for process completion instead of polling all system processes
            return_code = process.wait()
            
            # Brief delay for file system sync
            time.sleep(0.5)
            
            if return_code != 0:
                self.worker.log_signal.emit(f"<span style='color:#e57373'>Nastran returned code: {return_code}</span>")
                return False
            
            self.worker.log_signal.emit("<span style='color:#81c784'>✓ Nastran completed</span>")
            return True
            
        except Exception as e:
            self.worker.log_signal.emit(f"<span style='color:#e57373'>Nastran error: {e}</span>")
            return False
        
    def update_progress(self, iteration: int, max_iter: int, 
                   n_crit: int, rf_values: List[float], mass: Optional[float],
                   thickness_str: str = "", prop_ids: str = ""):
        """Update progress bar, labels, and store iteration data"""
        self.progress.setValue(int(iteration / max_iter * 100))
        self.iteration_label.setText(f"{iteration}/{max_iter}")
        self.critical_label.setText(str(n_crit))
        
        self.iteration_data.append({
            'iteration': iteration,
            'critical_count': n_crit,
            'rf_values': rf_values,
            'mass': mass,
            'thickness_str': thickness_str,  # Already formatted string
            'prop_ids_str': prop_ids
        })
        
        self.update_plots()
    
    def update_plots(self):
        """Update convergence and mass plots"""
        if not self.iteration_data:
            return
        
        iters = [d['iteration'] for d in self.iteration_data]
        crits = [d['critical_count'] for d in self.iteration_data]
        
        # Plot 1 - Convergence
        self.ax1.clear()
        self.ax1.plot(iters, crits, 'o-', color='#ff4400', lw=1.5, ms=4, label='Critical')
        self.ax1.axhline(0, color='#00ff00', ls='--', lw=1, label='Target', alpha=0.7)
        self.ax1.set_xlabel('Iteration', color='#888888', fontsize=9, family='monospace')
        self.ax1.set_ylabel('Critical Elements', color='#888888', fontsize=9, family='monospace')
        self.ax1.set_title('CONVERGENCE', color='#ff8800', fontweight='bold', fontsize=10, family='monospace')
        self.ax1.grid(True, alpha=0.15, color='#444444', linestyle='-', linewidth=0.5)
        self.ax1.tick_params(colors='#666666', labelsize=8)
        self.ax1.legend(facecolor='#1a1a1a', edgecolor='#ff6600', loc='best', framealpha=0.9, fontsize=8)
        self.ax1.set_facecolor('#0f0f0f')
        for spine in ['bottom', 'left']:
            self.ax1.spines[spine].set_color('#ff6600')
        for spine in ['top', 'right']:
            self.ax1.spines[spine].set_color('#444444')
        self.ax1.xaxis.set_major_locator(plt.MaxNLocator(integer=True))
        
        # Plot 2 - Mass
        self.ax2.clear()
        
        mass_data = [(d['iteration'], d['mass']) for d in self.iteration_data 
                     if d.get('mass') is not None]
        
        if mass_data:
            mass_iters, mass_vals = zip(*mass_data)
            
            self.ax2.plot(mass_iters, mass_vals, 'o-', color='#ff6600', lw=1.5, ms=4, label='Mass')
            
            if self.initial_mass:
                self.ax2.axhline(self.initial_mass, color='#ffaa00', ls='--', lw=1, 
                               label=f'Initial ({self.initial_mass:.1f} kg)', alpha=0.7)
            
            self.ax2.set_xlabel('Iteration', color='#888888', fontsize=9, family='monospace')
            self.ax2.set_ylabel('Mass (kg)', color='#888888', fontsize=9, family='monospace')
            self.ax2.set_title('MASS', color='#ff8800', fontweight='bold', fontsize=10, family='monospace')
            self.ax2.grid(True, alpha=0.15, color='#444444', linestyle='-', linewidth=0.5)
            self.ax2.tick_params(colors='#666666', labelsize=8)
            self.ax2.legend(facecolor='#1a1a1a', edgecolor='#ff6600', loc='best', framealpha=0.9, fontsize=8)
            self.ax2.set_facecolor('#0f0f0f')
            for spine in ['bottom', 'left']:
                self.ax2.spines[spine].set_color('#ff6600')
            for spine in ['top', 'right']:
                self.ax2.spines[spine].set_color('#444444')
            self.ax2.xaxis.set_major_locator(plt.MaxNLocator(integer=True))
            
            if self.initial_mass and len(mass_vals) > 0:
                final_mass = mass_vals[-1]
                pct_change = ((final_mass - self.initial_mass) / self.initial_mass) * 100
                color = '#ff4400' if pct_change > 0 else '#00ff00'
                self.ax2.text(0.02, 0.98, f'Δ {pct_change:+.1f}%', 
                            transform=self.ax2.transAxes, verticalalignment='top',
                            color=color, fontweight='bold', fontsize=9, family='monospace',
                            bbox=dict(boxstyle='round,pad=0.3', facecolor='#1a1a1a', 
                                    edgecolor=color, linewidth=1))
        else:
            self.ax2.text(0.5, 0.5, 'Mass data unavailable', 
                        transform=self.ax2.transAxes,
                        ha='center', va='center', color='#888888', 
                        fontsize=10, family='monospace')
            self.ax2.set_facecolor('#0f0f0f')
            for spine in self.ax2.spines.values():
                spine.set_color('#444444')
        
        self.ax3.clear()
        
        # Extract thickness data directly from iteration_data
        thickness_by_pid = {}
        for d in self.iteration_data:
            try:
                pids = ast.literal_eval(d.get('prop_ids_str', '[]'))
                thicks = ast.literal_eval(d.get('thickness_str', '[]'))
                
                if len(pids) == len(thicks):
                    for pid, thick in zip(pids, thicks):
                        if pid not in thickness_by_pid:
                            thickness_by_pid[pid] = []
                        thickness_by_pid[pid].append(thick)
            except:
                pass
        
        if thickness_by_pid:
            colors = ['#ff4400', '#ff6600', '#ff8800', '#ffaa00', '#00ff00', 
                      '#00ffaa', '#00aaff', '#0066ff', '#6600ff', '#ff00ff']
            
            for i, (pid, thicks) in enumerate(sorted(thickness_by_pid.items())[:10]):
                self.ax3.plot(iters[:len(thicks)], thicks, 'o-', 
                             color=colors[i % len(colors)], lw=1.2, ms=3, 
                             label=f'PID {pid}', alpha=0.8)
            
            self.ax3.set_xlabel('Iteration', color='#888888', fontsize=9, family='monospace')
            self.ax3.set_ylabel('Thickness (mm)', color='#888888', fontsize=9, family='monospace')
            self.ax3.set_title('THICKNESS EVOLUTION', color='#ff8800', fontweight='bold', fontsize=10, family='monospace')
            self.ax3.grid(True, alpha=0.15, color='#444444', linestyle='-', linewidth=0.5)
            self.ax3.tick_params(colors='#666666', labelsize=8)
            self.ax3.legend(facecolor='#1a1a1a', edgecolor='#ff6600', loc='best', framealpha=0.9, fontsize=7, ncol=2)
            self.ax3.set_facecolor('#0f0f0f')
            for spine in ['bottom', 'left']:
                self.ax3.spines[spine].set_color('#ff6600')
            for spine in ['top', 'right']:
                self.ax3.spines[spine].set_color('#444444')
            self.ax3.xaxis.set_major_locator(plt.MaxNLocator(integer=True))
        else:
            self.ax3.text(0.5, 0.5, 'Thickness data unavailable', 
                        transform=self.ax3.transAxes, ha='center', va='center', 
                        color='#888888', fontsize=10, family='monospace')
            self.ax3.set_facecolor('#0f0f0f')
        
        # ==================== END NEW ====================
        
        self.fig.tight_layout(pad=2.0)
        self.canvas.draw()
        QApplication.processEvents()
    
    def create_right_panel(self):
        """Create right panel with plots"""
        widget = QWidget()
        
        plt.style.use('dark_background')
        
        self.fig = Figure(figsize=(10, 12), facecolor='#0a0a0a')  # Increased height
        self.ax1 = self.fig.add_subplot(311, facecolor='#0f0f0f')  # Changed to 311
        self.ax2 = self.fig.add_subplot(313, facecolor='#0f0f0f')  # Changed to 312
        self.ax3 = self.fig.add_subplot(312, facecolor='#0f0f0f')  # NEW: Third plot
        
        for ax, ylabel, title in [
            (self.ax1, 'Critical Elements', 'CONVERGENCE'),
            (self.ax2, 'Mass (kg)', 'MASS'),
            (self.ax3, 'Thickness (mm)', 'THICKNESS')  # NEW
        ]:
            ax.set_xlabel('Iteration', color='#888888', fontsize=9, family='monospace')
            ax.set_ylabel(ylabel, color='#888888', fontsize=9, family='monospace')
            ax.set_title(title, color='#ff8800', fontweight='bold', fontsize=10, family='monospace')
            ax.grid(True, alpha=0.15, color='#444444', linestyle='-', linewidth=0.5)
            ax.tick_params(colors='#666666', labelsize=8)
            ax.spines['bottom'].set_color('#ff6600')
            ax.spines['top'].set_color('#444444')
            ax.spines['left'].set_color('#ff6600')
            ax.spines['right'].set_color('#444444')
            ax.set_facecolor('#0f0f0f')
        
        self.fig.tight_layout(pad=2.0)
        self.canvas = FigureCanvasQTAgg(self.fig)
        QVBoxLayout(widget).addWidget(self.canvas)
        
        return widget
        
    def save_results(self, work_dir: str, base: str, iteration: int,
                    df_res: pd.DataFrame, updated_pids: Set[int]) -> str:
        """Save optimization results to Excel file"""
        res_file = os.path.join(work_dir, f"{base}_RESULTS.xlsx")
        
        algo_name = (
            "Lazy (Iterative)" if self.algo_lazy_radio.isChecked() 
            else "Sensitivity-Based" if self.algo_sensitivity_radio.isChecked()
            else "Gaussian Process"
        )
        prop_method = "Neighbor Approach" if self.prop_neighbor_radio.isChecked() else "Manual IDs"
        
        target_rf = self.target_rf.value()
        n_crit_final = len(df_res[df_res['RF'] < target_rf])
        converged = (n_crit_final == 0)
        
        final_mass = None
        if self.iteration_data and self.iteration_data[-1].get('mass'):
            final_mass = self.iteration_data[-1]['mass']
        
        mass_change_str = "N/A"
        if self.initial_mass and final_mass:
            mass_change_pct = ((final_mass - self.initial_mass) / self.initial_mass) * 100
            mass_change_str = f"{mass_change_pct:+.2f}%"
        
        df_sum = pd.DataFrame({
            'Parameter': [
                'Algorithm',
                'Property Selection',
                'Status',
                'Converged',
                'Total Iterations',
                'Critical Elements (Final)',
                'Target RF',
                'Initial Mass',
                'Final Mass',
                'Mass Change',
                'Thickness Addition (Lazy)',
                'Angle Tolerance',
                'Properties Modified',
                'Modified Property IDs'
            ],
            'Value': [
                algo_name,
                prop_method,
                'Complete' if converged else 'Max Iterations Reached',
                'Yes' if converged else 'No',
                iteration,
                n_crit_final,
                f"{target_rf:.2f}",
                f"{self.initial_mass:.2f} kg" if self.initial_mass else "N/A",
                f"{final_mass:.2f} kg" if final_mass else "N/A",
                mass_change_str,
                f"{self.thickness_addition.value():.3f} mm" if self.algo_lazy_radio.isChecked() else "N/A",
                f"{self.angle_tolerance:.1f}°",
                len(updated_pids),
                ', '.join(map(str, sorted(list(updated_pids))[:20])) + 
                    ('...' if len(updated_pids) > 20 else '')
            ]
        })
        
        df_hist = pd.DataFrame([{
            'Iteration': d['iteration'],
            'Critical_Elements': d['critical_count'],
            'Min_RF': min(d['rf_values']) if d['rf_values'] else None,
            'Max_RF': max(d['rf_values']) if d['rf_values'] else None,
            'Avg_RF': np.mean(d['rf_values']) if d['rf_values'] else None,
            'Std_RF': np.std(d['rf_values']) if d['rf_values'] else None,
            'Mass_kg': d.get('mass'),
            'Property_IDs': d.get('prop_ids_str', ''),
            'Thicknesses_mm': d.get('thickness_str', '')} for d in self.iteration_data])
        
        df_crit_final = df_res[df_res['RF'] < target_rf].copy()
    
        with pd.ExcelWriter(res_file, engine='openpyxl') as writer:
            df_sum.to_excel(writer, sheet_name='Summary', index=False)
            df_hist.to_excel(writer, sheet_name='History', index=False)
            df_res.to_excel(writer, sheet_name='All_Elements', index=False)
            df_crit_final.to_excel(writer, sheet_name='Critical_Elements', index=False)
            
            for sheet_name in writer.sheets:
                worksheet = writer.sheets[sheet_name]
                for column in worksheet.columns:
                    max_length = 0
                    column_letter = column[0].column_letter
                    for cell in column:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(str(cell.value))
                        except:
                            pass
                    adjusted_width = min(max_length + 2, 50)
                    worksheet.column_dimensions[column_letter].width = adjusted_width
        
        self.log(f"<span style='color:#81c784'>Results saved: {res_file}</span>")
        return res_file
    
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = PCOMPOptimizerGUI()
    window.showMaximized()
    window.show()
    sys.exit(app.exec_())
    
    
"""
*add maybe iter 0


"""
