from tatobin_plotter import splot,fplot
from pyNastran.bdf.bdf import read_bdf
import os, platform, psutil, getpass, shutil, sys
import time,datetime
import numpy as np
import pandas as pd
import xlwings as xw
import random
import joblib
import pickle
import threading
import tkinter as tk
from tkinter import filedialog, ttk, messagebox,Toplevel
from collections import Counter
import cowsay
import pyfiglet

#-----
from sklearn.model_selection import train_test_split, GridSearchCV, RandomizedSearchCV, learning_curve
from sklearn.metrics import r2_score,mean_squared_error,mean_absolute_error,mean_absolute_percentage_error
from sklearn.linear_model import LinearRegression
from sklearn.neural_network import MLPRegressor
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
#----

import warnings
warnings.filterwarnings('ignore')

# =============================================================================
# COMPOSITES
# =============================================================================

def rf_openhole(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    
    ttb_sheet="Open Hole Strength - Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # rows = rows+start-1 if rows>=9 else start+1 #necessary tweak, rows makes the stop
    rows = rows+start-1
    ws.range(f"B{start+1}:AF2000").clear_contents() #clearing
    ws.range(f'B{start}:AF{start}').api.AutoFill(Destination=ws.range(f'B{start}:AF{rows}').api,Type=0) #filling
    
    # writing specifics
    ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'K{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    ws.range(f'L{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
    ws.range(f'M{start}:M{rows}').value="HW"
                                                         
    #writing holes
    ws.range(f'N{start}').value=np.array(df_join["Dhole (mm)"]).reshape(-1,1)
    ws.range(f'O{start}').value=np.array(df_join["Dhole (mm)"]).reshape(-1,1)
    ws.range(f'P{start}:P{rows}').value=0
    ws.range(f'V{start}:V{rows}').value="Open Hole - Circle"
    
    #forcing stuff
    for i in ["W","X","Y","Z","AA"]:
        ws.range(f'{i}{start}:{i}{rows}').value="Y"
        
    #writing edges, if ex<0, hata verecek önlem almadım
    # df_join["ex"]=df_join["X-Length (mm)"]-df_join["Dhole (mm)"]
    # df_join["ey"]=df_join["Y-Length (mm)"]-df_join["Dhole (mm)"]
    ws.range(f'Q{start}').value=np.array(df_join["Panel Length X"]).reshape(-1,1)
    ws.range(f'R{start}').value=np.array(df_join["Panel Length Y"]).reshape(-1,1)
    
    #writing loads
    ws.range(f'S{start}').value=np.array(df_join["Nx Average"]).reshape(-1,1)
    ws.range(f'T{start}').value=np.array(df_join["Ny Average"]).reshape(-1,1)
    ws.range(f'U{start}').value=np.array(df_join["Nxy Average"]).reshape(-1,1)
    
    wb.app.calculate()
    end=time.time()
    
    columns=ws.range(f'B{start-1}:AF{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:AF{rows}').value),columns=columns)
    
    if start==rows:  ws.range(f"B{start+1}:AF{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:AF{rows}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt


def rf_local_buckling(wb,rows,df_join,df_misc_joint,matmat): #-> bar average
    start=10 if df_join.shape[0]!=0 else 12
    begin=time.time()
    if ml_choice.get()==1:
        return None
    
    ttb_sheet="Local Buckling-Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
        
    #PREPP------------------------------------------------
    #pshell matı ve thickness'ı almak için bu yolu seçtim :(
    if matmat=="metal":
        df_misc_joint=df_misc_joint[~df_misc_joint["MAT"].str.contains('m21|m91|quartz',regex=True,case=False,na=False)]
        ttb_sheet="LocalBuckling_Metal"
    else:
        df_misc_joint=df_misc_joint[df_misc_joint["MAT"].str.contains('m21|m91|quartz',regex=True,case=False,na=False)]
        ttb_sheet="LocalBuckling_Composite"
        
    df_misc_joint=df_misc_joint.loc[df_misc_joint.groupby("Property ID (PBARL)")["T"].idxmin()] #returns 1 instance no worries
    df_misc_joint=df_misc_joint[["Property ID (PBARL)", "MAT", "T","n1","n2","n3","n4"]]
    df_misc_joint.rename(columns={"Property ID (PBARL)":"Property ID", "MAT":"MAT (PSHELL)", "T": "T (PSHELL)",
                                  "n1":"n1 (PSHELL)", "n2":"n2 (PSHELL)", "n3":"n3 (PSHELL)", "n4":"n4 (PSHELL)"} ,inplace=True)
    df_join=pd.merge(df_join,df_misc_joint,on="Property ID").reset_index(drop=True)
    df_join=df_join[df_join["W"]>2]
    #PREPP------------------------------------------------
    
    rows=df_join.shape[0]
    rows = rows+start-1
    last_row = ws.range("B" + str(ws.cells.last_cell.row)).end('up').row
    if start==last_row: ws.range(f"B{start+1}:AG{last_row+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:AG{last_row}").clear_contents() #clearing
    
    # writing constants
    ws.range(f'B{start}:B{rows}').value="One Edge Free / Other SS" #unloaded edges
    ws.range(f'C{start}:C{rows}').value="Simply Supported" #loaded edges
    ws.range(f'G{start}:G{rows}').value=0 #Nx,web
    ws.range(f'H{start}:H{rows}').value="NO" #Transverse Shear
    ws.range(f'I{start}:I{rows}').value="T or Integral Section Web" #stiffener type
    ws.range(f'J{start}:J{rows}').value=50 #web height, 1 eleman dummy

    #writing variables
    ws.range(f'D{start}').value=np.array(df_join["Length"]).reshape(-1,1) #a uzunlugu
    ws.range(f'E{start}').value=np.array(df_join["W"]).reshape(-1,1) #b uzunlugu
    ws.range(f'F{start}').value=np.array(df_join["Axial Force"]/df_join["W"]).reshape(-1,1) #Nx,flange F/width (N/mm)
    ws.range(f'K{start}').value=np.array(df_join["MAT"]).reshape(-1,1) #bar material
    ws.range(f'L{start}').value=np.array(df_join["MAT (PSHELL)"]).reshape(-1,1) #shell material
    ws.range(f'U{start}').value=np.array(df_join["Axial Force"]).reshape(-1,1) #axial load on the section, doesnt matter
    
    #BARZ
    ws.range(f'M{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'N{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'O{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'P{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    
    #ATTACHED SHELL
    ws.range(f'Q{start}').value=np.array(df_join["n1 (PSHELL)"]).reshape(-1,1)
    ws.range(f'R{start}').value=np.array(df_join["n2 (PSHELL)"]).reshape(-1,1)
    ws.range(f'S{start}').value=np.array(df_join["n3 (PSHELL)"]).reshape(-1,1)
    ws.range(f'T{start}').value=np.array(df_join["n4 (PSHELL)"]).reshape(-1,1)
    
    ws.range(f'V{start}:AG{start}').api.AutoFill(Destination=ws.range(f'V{start}:AG{rows}').api,Type=0) #filling
    wb.app.calculate()
    end=time.time()
    
    columns=ws.range(f'B{start-1}:AG{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:AG{rows}').value),columns=columns)
    
    df_out["t (mm)"]=np.array(df_join["T"]).reshape(-1,1) #ekleme
    df_addition=df_join[["Property ID","Subcase ID"]].reset_index().drop("index",axis=1)
    df_out=pd.concat((df_addition,df_out),axis=1)
    
    #n1,n2,n3,n4 kolonlarini degistirmek icin, ayni isimde kalinca RF min sheetinde problem cikiyor
    df_out.columns=[f"{col}_{i}" if i>0 else col for col, i in \
                    zip(df_out.columns, [Counter(df_out.columns[:i]).get(col,0) for i, col in enumerate(df_out.columns)])]
                               
    last_row = ws.range("B" + str(ws.cells.last_cell.row)).end('up').row
    if start==last_row: ws.range(f"B{start+1}:AG{last_row+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:AG{last_row}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt

def rf_sandwich(wb,rows,df_join_all,df_join_avg):
    """
    Using sandwich analysis tab
    taking all and average load both
    combine them on all based on pid and lcid match
    
    """
    #-----------BUCKBUCK--------------------------------------------------------#
    if sandwich_inputs[-1]=="YES":
        ttb_sheet="Panel Buckling Ritz-Autom"
        ws=wb.sheets(ttb_sheet)
        button_name="CommandButton1" #browse
        for shape in ws.shapes:
            if shape.name==button_name and shape.api.OLEFormat.Object.Object.Enabled:
                shape.api.OLEFormat.Object.Object.Value=True
    #-----------BUCKBUCK--------------------------------------------------------#
    
    def get_coreid(x):
        if "syn" in x.lower():
            return 58
        elif "3.2-48" in x.lower():
            return 59
        elif "4.8-32" in x.lower():
            return 60
        elif "4.8-96" in x.lower():
            return 61
        elif "4.0-96" in x.lower():
            return 62
        else:
            return "Missing"
    
    start=11 if rows!=0 else 13
    begin=time.time()
    
    ttb_sheet="Sandwich Analysis"
    ws=wb.sheets(ttb_sheet)
    ws.api.Unprotect(Password="TAT2530TFX")
    ws.range(f"Y{start+1}:FO{20000}").clear_contents() #clearing
    
    #necessary addition
    df_join_avg_buck=df_join_avg.copy()
    df_join_avg["Panel width min"]=df_join_avg.apply(lambda row: max(row["Panel Length X"],row["Panel Length Y"]) \
                                          if row["CAI fwidth"]>min(row["Panel Length X"],row["Panel Length Y"]) \
                                          else min(row["Panel Length X"],row["Panel Length Y"]),axis=1)
    df_join_avg["Core T"].fillna(6.35,inplace=True)
    df_join_avg=df_join_avg[["Property ID","Subcase ID","Nx Average","Ny Average","Nxy Average",
                             "Mx Average","My Average","Mxy Average","Panel width min","Panel Length X","Panel Length Y",
                             "Radius of Curvature X","Radius of Curvature Y"]]
    
    df_out_merged_all=pd.merge(df_join_all, df_join_avg, on=["Property ID","Subcase ID"], how="left")
    df_out_merged_all["Total T"]=df_out_merged_all["T"]+df_out_merged_all["Core T"]
    # for r in range(3):
    #     for c in range(3):
    #         df_out_merged_all[f"A{r+1}{c+1}"]=None
    #         df_out_merged_all[f"D{r+1}{c+1}"]=None
    
    ll=[]
    for pid in df_out_merged_all["Property ID"].unique():
        print(f"SANDWICH - analyzing property ..... {pid}")
        df_out_merged=df_out_merged_all[df_out_merged_all["Property ID"]==pid]
        df_out_merged["Ramp Direction"]=np.where(abs(df_out_merged["Nx"]) >= abs(df_out_merged["Ny"]), "Nx", "Ny")
        
        rows=len(df_out_merged)
        rows = rows+start-1 #necessary tweak, rows makes the stop
        
        ### AVERAGE LOADS ###########################################################################
        ws.range(f'Y{start}').value=np.array(df_out_merged["Subcase ID"]).reshape(-1,1)
        ws.range(f'Z{start}').value=np.array(df_out_merged["Nx Average"]).reshape(-1,1)
        ws.range(f'AA{start}').value=np.array(df_out_merged["Ny Average"]).reshape(-1,1)
        ws.range(f'AB{start}').value=np.array(df_out_merged["Nxy Average"]).reshape(-1,1)
        ws.range(f'AC{start}').value=np.array(df_out_merged["Mx Average"]).reshape(-1,1)
        ws.range(f'AD{start}').value=np.array(df_out_merged["My Average"]).reshape(-1,1)
        ws.range(f'AE{start}').value=np.array(df_out_merged["Mxy Average"]).reshape(-1,1)
        ###############################################################################################
        
        ### ALL LOADS ###########################################################################
        ws.range(f'AG{start}').value=np.array(df_out_merged["Subcase ID"]).reshape(-1,1)
        ws.range(f'AH{start}').value=np.array(df_out_merged["Nx"]).reshape(-1,1)
        ws.range(f'AI{start}').value=np.array(df_out_merged["Ny"]).reshape(-1,1)
        ws.range(f'AJ{start}').value=np.array(df_out_merged["Nxy"]).reshape(-1,1)
        ws.range(f'AK{start}').value=np.array(df_out_merged["Mx"]).reshape(-1,1)
        ws.range(f'AL{start}').value=np.array(df_out_merged["My"]).reshape(-1,1)
        ws.range(f'AM{start}').value=np.array(df_out_merged["Mxy"]).reshape(-1,1)
        ws.range(f'AN{start}').value=np.array(df_out_merged["Tx"]).reshape(-1,1)
        ws.range(f'AO{start}').value=np.array(df_out_merged["Ty"]).reshape(-1,1)
        
        ws.range(f'AP{start}').value=np.array(df_out_merged["Ramp Direction"]).reshape(-1,1)
        ws.range(f'AQ{start}').value=np.array(df_out_merged["Temperature (C)"]).reshape(-1,1)
        ws.range(f'AR{start}:AR{rows}').value="HW"
        ###############################################################################################
        
        ### PLIES ###########################################################################
        mat_name=df_out_merged["MAT"].iloc[0]
        core_t=df_out_merged["Core T"].min()
        
        ws.range(f'B{23}:G{200}').clear_contents() #filling
        ws.range("C10").value=mat_name
        n1,n2,n3,n4=df_out_merged["n1"].iloc[0],df_out_merged["n2"].iloc[0],\
                    df_out_merged["n3"].iloc[0],df_out_merged["n4"].iloc[0] 
        ws.range("C12:C15").value=np.array([n1,n2,n3,n4]).reshape(-1,1)
        mater = ws.range("C10")
        plycount1 = ws.range("C12")
        plycount2 = ws.range("C13").value + ws.range("C14").value
        plycount3 = ws.range("C15")
        Clear_Range = "b22"
        wb.macro("Layup_Gen_SS")(mater, plycount1, plycount2, plycount3, Clear_Range, ttb_sheet)
        
        last_row=ws.range("C"+str(ws.cells.last_cell.row)).end("up").row
        ws.range(f"F22:F{last_row}").value="Top Facesheet"
        ws.range(f"G22:G{last_row}").value=mat_name
        
        cols=ws.range('B21:G21').value
        df_plies=pd.DataFrame((ws.range(f'B22:G{last_row}').value),columns=cols)
        mid=len(df_plies)//2
        
        df_top=df_plies.iloc[:mid].copy()
        core_mat,core_t=df_out_merged["Core MAT"].iloc[0],df_out_merged["Core T"].min()
        core_id=get_coreid(core_mat)
        core_stuff=[("",core_id,core_t,0,"Core",core_mat)]
        df_mid=pd.DataFrame(core_stuff,columns=cols)
        df_bottom=df_plies.iloc[mid:].copy()
        df_bottom["Layer Type"]="Bottom Facesheet"
        df_new=pd.concat([df_top,df_mid,df_bottom],ignore_index=True)
        
        ws.range("B22").options(index=False).value=df_new.values
        ###############################################################################################
        
        ### OTHERS ###########################################################################
        ws.range("K10").value=df_out_merged["Panel width min"].min()
        ws.range("K11").value=df_out_merged["CAI fwidth"].max()
        ws.range("K13").value=sandwich_inputs[2] #ENERGY
        ws.range("K17").value="L" #ribbon direction
        ws.range("G10").value=df_out_merged["Radius of Curvature X"].max()
        ws.range("G11").value=df_out_merged["Radius of Curvature Y"].max()
        ws.range("G14").value=sandwich_inputs[1] #RAD
        ws.range("G15").value=sandwich_inputs[1] #RAD
        ws.range("G16").value=df_out_merged["MAT"].iloc[0]
        ws.range("G17").value=sandwich_inputs[0] #ANGLE
        ###############################################################################################
        
        #ABD MATRIX################################################################## 
        abd_matrix=ws.range("P51:U56").value #compressive
        for r in range(3):
            for c in range(3):
                df_out_merged_all.loc[df_out_merged_all["Property ID"]==pid,f"A{r+1}{c+1}"]=abd_matrix[r][c]
                df_out_merged_all.loc[df_out_merged_all["Property ID"]==pid,f"D{r+1}{c+1}"]=abd_matrix[r+3][c+3]
                # df_out_merged_all[f"D{r+1}{c+1}"]=abd_matrix[r+3][c+3]
        #############################################################################
        
        ws.range(f'AT{start}:FO{start}').api.AutoFill(Destination=ws.range(f'AT{start}:FO{rows+1}').api,Type=0) #filling
        wb.app.calculate()
        
        columns=ws.range(f'Y{start-1}:FO{start-1}').value[:-10] + ["Min RF (TFace)","Fail Mode (TFace)","Min RF (BFace)", 
                                                                   "Fail Mode (BFace)", "Min RF (Core)", "Fail Mode (Core)",
                                                                   "Min RF (Ramp)", "Fail Mode (Ramp)", "RF", "Component Failed"]
        df_out=pd.DataFrame(ws.range(f'Y{start}:FO{rows}').options(ndim=2).value,columns=columns)
        df_out["RF"]=df_out["RF"].fillna(df_out[["Min RF (TFace)","Min RF (BFace)","Min RF (Core)","Min RF (Ramp)"]].min(axis=1))
        
        #some additional OUTPUTS
        df_out_merged["Ramp Angle"]=sandwich_inputs[0]
        df_out_merged["Radius"]=sandwich_inputs[1]
        df_out_merged["Ribbon Direction"]=ws.range("K17").value
        df_out_merged["Plies"]=df_out_merged[["n1","n2","n3","n4"]].astype(str).agg("/".join, axis=1)
        
        # df_out.rename(columns={df_out.columns[6]:"RF"},inplace=True) #RF column has weird spaces, renaming it as simple RF
        df_addition=df_out_merged[["Property ID","Element ID","Subcase ID","MAT","T","Core MAT", "Core T", "Total T","Plies",
                                   "Panel width min","Radius","Ramp Angle","Ribbon Direction"]].reset_index().drop("index",axis=1)
        # df_addition2=df_join_all_filtered[["Element ID"]].reset_index().drop("index",axis=1)
        df_out=pd.concat((df_addition,df_out),axis=1)
        ll.append(df_out)
        
        if start==rows: ws.range(f"Y{start+1}:FO{(rows+1)*2}").clear_contents() #clearing
        else: ws.range(f"Y{start+1}:FO{rows*2}").clear_contents() #clearing
    
    df_out=pd.concat(ll)
    end=time.time()
    dt=end-begin
    
    #ayni kolonlar icin trick
    df_out.columns=[f"{col}_{i}" if i>0 else col for col, i in \
                    zip(df_out.columns, [Counter(df_out.columns[:i]).get(col,0) for i, col in enumerate(df_out.columns)])]
        
    ws.range(f"Y{start+1}:FO{rows*2}").clear_contents() #clearing
    ws.api.Protect(Password="TAT2530TFX")
    
    #-----------BUCKBUCK--------------------------------------------------------#
    if sandwich_inputs[-1]=="YES":
        print("SANDWICH - Ritz buckling is starting.")
        df_sandwich_buck=df_out_merged_all.drop_duplicates(subset=["Property ID","Subcase ID"]).reset_index(drop=True)
        try:
            sheet_name,df_out_buck,dt_buck=rf_buckling_ritz(wb,len(df_sandwich_buck),df_sandwich_buck,"sandwich")
            df_addition=df_sandwich_buck[["Property ID","Subcase ID","Core T","Core MAT"]] #joining with some input cols
            df_out_final=pd.concat((df_addition,df_out_buck),axis=1).reset_index().drop("index",axis=1)
            
            write_stuff(sheet_name,df_out_buck,df_out_final,dt_buck) #making the output
        except Exception as e:
            print(f"ERROR - Something went wrong in Sandwich-Buckling. ({e})")
    #-----------BUCKBUCK--------------------------------------------------------#
    
    return ttb_sheet,df_out,dt


def rf_ils(wb,rows,df_join):
    try:
        wb.app.api.Calculation=xw.constants.Calculation.xlCalculationManual
    except:
        pass
    
    start=11 if df_join.shape[0]!=0 else 13
    begin=time.time()
    if ml_choice.get()==1:
        return None
    
    ttb_sheet="Interlaminar Shear"
    ws=wb.sheets(ttb_sheet)
    ws.api.Unprotect(Password="TAT2530TFX")
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    df_origin=df_join.copy()
    ll=[]
    # for thickness in df_join["T"].unique():
    for pid in df_origin["Property ID"].unique():
        print(f"ILS - analyzing property ..... {pid}")
        # df_join=df_origin[df_origin["T"]==thickness]
        df_join=df_origin[df_origin["Property ID"]==pid]
        rows=df_join.shape[0]
        rows = rows+start-1 #necessary tweak, rows makes the stop
        
        ws.range(f"U{start+1}:AJ{rows}").clear_contents() #clearing
        # ws.range(f'B{start}:Y{start}').api.AutoFill(Destination=ws.range(f'B{start}:Y{rows}').api,Type=0) #filling
        ws.range(f'U{start}').value=np.array(df_join["Subcase ID"]).reshape(-1,1)
        ws.range(f'V{start}').value=np.array(df_join["Tx"]).reshape(-1,1)
        ws.range(f'W{start}').value=np.array(df_join["Ty"]).reshape(-1,1)
        
        # #df_join["Temperature (C)"].fillna(100,inplace=True)
        ws.range(f'X{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
        ws.range(f'Y{start}:Y{rows}').value="HW"
        
        #calling command_button in vba-----------------------------------------------------
        n1,n2,n3,n4=df_join["n1"].iloc[0],df_join["n2"].iloc[0],df_join["n3"].iloc[0],df_join["n4"].iloc[0] 
        ws.range("C10").value=df_join["MAT"].iloc[0] #.loc index ile cagırıyor, sakıncalı
        ws.range("C12:C15").value=np.array([n1,n2,n3,n4]).reshape(-1,1)
        mater = ws.range("C10")
        plycount1 = ws.range("C12")
        plycount2 = ws.range("C13").value * 2
        plycount3 = ws.range("C15")
        Clear_Range = "b22"
        wb.macro("Layup_Gen_SS")(mater, plycount1, plycount2, plycount3, Clear_Range, "Interlaminar Shear")
        
        
        """
        button_name="CommandButton1"
        for shape in ws.shapes:
            if shape.name==button_name and shape.api.OLEFormat.Object.Object.Enabled:
                shape.api.OLEFormat.Object.Object.Value=True 
                
        """
        #--------------------------------------------------------------------------------
        
        ws.range(f'AA{start}:AJ{start}').api.AutoFill(Destination=ws.range(f'AA{start}:AJ{rows+1}').api,Type=0) #filling
        
        #I dont know why this is necessary exactly but otherwise RF just gives #VALUE, thus refreshing loads
        ws.range(f'V{start}').value=np.array(df_join["Tx"]).reshape(-1,1)
        ws.range(f'W{start}').value=np.array(df_join["Ty"]).reshape(-1,1)
        wb.app.calculate()
        
        columns=ws.range(f'V{start-1}:AJ{start-1}').value
        df_out=pd.DataFrame((ws.range(f'V{start}:AJ{rows}').options(ndim=2).value),columns=columns)
        
        # df_out.rename(columns={df_out.columns[6]:"RF"},inplace=True) #RF column has weird spaces, renaming it as simple RF
        df_addition=df_join[["Element ID", "Property ID","Subcase ID","MAT","T","n1","n2","n3","n4"]].reset_index().drop("index",axis=1)
        df_out=pd.concat((df_addition,df_out),axis=1)
        ll.append(df_out)
        
        ws.range(f"U{start+1}:AJ{rows}").clear_contents() #clearing
        
    df_out=pd.concat(ll)
    end=time.time()
    dt=end-begin
    
    if start==rows:  ws.range(f"U{start+1}:AJ{rows+1}").clear_contents() #clearing
    else: ws.range(f"U{start+1}:AJ{rows}").clear_contents() #clearing
    
    ws.api.Protect(Password="TAT2530TFX")
    return ttb_sheet,df_out,dt


def rf_unnotched(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    
    if ml_choice.get()==1:
        ttb_sheet="Unnotched Strength - AI"
        # models=joblib.load(ml_file.get())
        models=joblib.load(ml_path)
        
        result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
        root.update_idletasks()
        
        #some preprocessing
        #df_join["Temperature (C)"].fillna(100,inplace=True)
        inputs=["Nx","Ny","Nxy","Mx","My","Mxy","n1","n2","n3","n4","Temperature (C)"]
        addition=["T"]
        
        #prediction
        df_out=df_join[addition+inputs]
        df_out.rename(columns={"T" : "t (mm)"}, inplace=True)
        df_out["RF"]=models["Unnotched"].predict(np.array(df_join[inputs]))
        dt=time.time()-start
        
        return ttb_sheet,df_out,dt
    
    ttb_sheet="Unnotched Strength - Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # rows = rows+start-1 if rows>=9 else start+1 #necessary tweak, rows makes the stop
    rows = rows+start-1
    
    ws.range(f"B{start+1}:Y200").clear_contents() #clearing
    ws.range(f'B{start}:Y{start}').api.AutoFill(Destination=ws.range(f'B{start}:Y{rows}').api,Type=0) #filling
    
    # writing specifics
    ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'K{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    ws.range(f'L{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
    ws.range(f'M{start}:M{rows}').value="HW"
                                                         
    #writing loads
    ws.range(f'N{start}').value=np.array(df_join["Nx"]).reshape(-1,1)
    ws.range(f'O{start}').value=np.array(df_join["Ny"]).reshape(-1,1)
    ws.range(f'P{start}').value=np.array(df_join["Nxy"]).reshape(-1,1)
    ws.range(f'Q{start}').value=np.array(df_join["Mx"]).reshape(-1,1)
    ws.range(f'R{start}').value=np.array(df_join["My"]).reshape(-1,1)
    ws.range(f'S{start}').value=np.array(df_join["Mxy"]).reshape(-1,1)
    
    wb.app.calculate()
    end=time.time()
    
    columns=ws.range(f'B{start-1}:Y{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:Y{rows}').value),columns=columns)
    
    if start==rows:  ws.range(f"B{start+1}:Y{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:Y{rows}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt


def rf_cai(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    if ml_choice.get()==1:
        ttb_sheet="Transverse Residual - AI"
        models=joblib.load(ml_path)
        
        #some preprocessing
        #df_join["Temperature (C)"].fillna(100,inplace=True)
        inputs=["Nx Average","Ny Average","Nxy Average","Mx Average","My Average","Mxy Average",
                "Panel Length X","Panel Length Y","CAI fwidth","Temperature (C)","n1","n2","n3","n4"]
        addition=["T"]
        
        #prediction
        df_out=df_join[addition+inputs]
        df_out.rename(columns={"T" : "t (mm)"}, inplace=True)
        df_out["RF"]=models["T-Residual"].predict(np.array(df_join[inputs]))
        dt=time.time()-start
        
        return ttb_sheet,df_out,dt
    
    ttb_sheet="TR Residual Str. - Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    rows = rows+start-1
    
    ws.range(f"B{start+1}:AT200").clear_contents() #clearing
    ws.range(f'B{start}:AT{start}').api.AutoFill(Destination=ws.range(f'B{start}:AT{rows}').api,Type=0) #filling
    
    # writing specifics
    ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'K{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    #misc
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    ws.range(f'L{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
    ws.range(f'M{start}:M{rows}').value="HW"
    ws.range(f'N{start}:N{rows}').value="Average Modulus"
    # ws.range(f'S{start}:S{rows}').value=55
    ws.range(f'S{start}:S{rows}').value=energy_value
    
    #writing loads
    """! get min values here somehow, without loop preferably"""
    # df_join["Panel width mod"]=df_join.apply(lambda row: max(row["Panel Length X"],row["Panel Length Y"]) \
    #                                           if row["CAI fwidth"]>min(row["Panel Length X"],row["Panel Length Y"]) \
    #                                           else min(row["Panel Length X"],row["Panel Length Y"]),axis=1)
    
    df_join["Panel width mod"]=df_join.apply(lambda row: row["CAI fwidth"]+1 if row["CAI fwidth"]>=min(row["Panel Length X"],row["Panel Length Y"]) \
                                             else min(row["Panel Length X"],row["Panel Length Y"]),axis=1)
        
    #panel width > flange width olmali ama bazen max(panel1,panel2) < flange width kaliyor, burada 40 mm aliyorum direkt width'i
    # df_join["CAI fwidth"]=df_join.apply(lambda row: 40 if row["Panel width mod"]<row["CAI fwidth"] else row["CAI fwidth"],axis=1)
    
    ws.range(f'O{start}').value=np.array(df_join["Panel width mod"]).reshape(-1,1)
    # ws.range(f'O{start}').value=np.array(df_join["Panel Length Y"]).reshape(-1,1) #width
    ws.range(f'P{start}').value=np.array(df_join["CAI fwidth"]).reshape(-1,1)
    ws.range(f'U{start}').value=np.array(df_join["Nx Average"]).reshape(-1,1)
    ws.range(f'V{start}').value=np.array(df_join["Ny Average"]).reshape(-1,1)
    ws.range(f'W{start}').value=np.array(df_join["Nxy Average"]).reshape(-1,1)
    ws.range(f'X{start}').value=np.array(df_join["Mx Average"]).reshape(-1,1)
    ws.range(f'Y{start}').value=np.array(df_join["My Average"]).reshape(-1,1)
    ws.range(f'Z{start}').value=np.array(df_join["Mxy Average"]).reshape(-1,1)
    
    wb.app.calculate()
    end=time.time()
    
    columns=ws.range(f'B{start-1}:AT{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:AT{rows}').value),columns=columns)
    
    #for 1 row input, rows 9 and 10 filled, 10 with na property so drop it
    df_out.reset_index(drop=True,inplace=True)
    
    if start==rows:  ws.range(f"B{start+1}:AT{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:AT{rows}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt


def rf_ei(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    if ml_choice.get()==1:
        ttb_sheet="Edge Residual - AI"
        models=joblib.load(ml_path)
        
        #some preprocessing
        #df_join["Temperature (C)"].fillna(100,inplace=True)
        inputs=["Nx","Ny","Nxy","Mx","My","Mxy","n1","n2","n3","n4","Temperature (C)"]
        addition=["T"]
        
        #prediction
        df_out=df_join[addition+inputs]
        df_out.rename(columns={"T" : "t (mm)"}, inplace=True)
        df_out["RF"]=models["E-Residual"].predict(np.array(df_join[inputs]))
        dt=time.time()-start
        
        return ttb_sheet,df_out,dt
    
    ttb_sheet="Edge Residual Str-Autom"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    rows = rows+start-1
    ws.range(f"B{start+1}:AF200").clear_contents() #clearing
    ws.range(f'B{start}:AF{start}').api.AutoFill(Destination=ws.range(f'B{start}:AF{rows}').api,Type=0) #filling
    
    # writing specifics
    ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'K{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    #misc
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    ws.range(f'L{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
    ws.range(f'M{start}:M{rows}').value="HW"
    ws.range(f'N{start}:N{rows}').value=1000 #curvature
    
    #writing loads
    ws.range(f'O{start}').value=np.array(df_join["Nx Average"]).reshape(-1,1)
    ws.range(f'P{start}').value=np.array(df_join["Ny Average"]).reshape(-1,1)
    ws.range(f'Q{start}').value=np.array(df_join["Nxy Average"]).reshape(-1,1)

    wb.app.calculate()
    end=time.time()
    
    columns=ws.range(f'B{start-1}:AF{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:AF{rows}').value),columns=columns)
    
    if start==rows:  ws.range(f"B{start+1}:AF{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:AF{rows}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt


# =============================================================================
# BUCKLING
# =============================================================================

def rf_buckling(wb,rows,df_join,mat):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    ttb_sheet="Panel Buckling-Automation"
    ws=wb.sheets(ttb_sheet)
    ttb_sheet=ttb_sheet.split()[-1]+"_"+mat
    
    rows = rows+start-1
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    ws.range(f"B{start+1}:Z200").clear_contents() #clearing
    ws.range(f'B{start}:Z{start}').api.AutoFill(Destination=ws.range(f'B{start}:Z{rows}').api,Type=0) #filling
    
    # writing specifics
    ws.range(f'B{start}').value=np.array(df_join["Unloaded edges"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["Loaded edges"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["Panel Length X"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["Panel Length Y"]).reshape(-1,1)
    ws.range(f'L{start}:L{rows}').value=0
    
    ws.range(f'F{start}').value=np.array(df_join["Nx Average"]).reshape(-1,1)
    ws.range(f'G{start}').value=np.array(df_join["Ny Average"]).reshape(-1,1)
    ws.range(f'H{start}').value=np.array(df_join["Nxy Average"]).reshape(-1,1)
    ws.range(f'I{start}').value=np.array(df_join["Mx Average"]).reshape(-1,1)
    ws.range(f'J{start}').value=np.array(df_join["My Average"]).reshape(-1,1)
    
    ws.range(f'M{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'N{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'O{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'P{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'Q{start}').value=np.array(df_join["n4"]).reshape(-1,1)

    wb.app.calculate()
    end=time.time()
    
    columns=ws.range(f'B{start-1}:Z{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:Z{rows}').value),columns=columns)
    
    if start==rows:  ws.range(f"B{start+1}:Z{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:Z{rows}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt


def rf_buckling_ritz(wb,rows,df_join,mat):
    try: os.chdir(os.path.dirname(ttb_path))
    except: pass
    start=11 if df_join.shape[0]!=0 else 13
    
    if ml_choice.get()==1:
        print("Ritz - Using ML prediction.")
        ttb_sheet="Ritz-ML"
        # df_addition=df_join[["Property ID","Subcase ID"]].reset_index(drop=True) #Element ID header avg'da yok
        
        df_join_default=df_join.copy()
        df_join.rename(columns={'Edge restraint (Ritz)':'Edge Restraint Definition','Percent Fixity (Ritz)':'Percent Fixity',
                                'X Boundary (Ritz)':'X Boundary Condition', 'Y Boundary (Ritz)':'Y Boundary Condition', 
                                'Panel Length X': 'a (mm)', 'Panel Length Y': 'b (mm)',
                                'Radius of Curvature X': 'Rx (mm)', 'Radius of Curvature Y': 'Ry (mm)',
                                'Nx Average':'NxU', 'Ny Average':'NyU', 'Nxy Average': 'Nxy', 
                                'MAT':'Shell Material','n1':'Shell n1 (ply1)','n2':'Shell n2 (ply2)','n3':'Shell n3 (ply3)',
                                'n4':'Shell n4 (ply4)', 'aoff (deg)': 'aoff (°)'}, inplace=True)
        
        model_data=joblib.load(ml_path)
        model=model_data['ritz'][0]
        feature_names=model_data['ritz'][1]
        
        for col in feature_names:
            if col not in df_join.columns: 
                df_join[col]=np.nan
        
        categorical_features = df_join.select_dtypes(include=['object','category']).columns.tolist()
        for col in categorical_features:
            df_join[col]=df_join[col].astype('category')
        
        df_join=df_join[feature_names]
        prediction=model.predict(df_join) #prediction
        df_join["RF"]=prediction.reshape(-1,1)
        df_join["RF"]=df_join["RF"].abs()
              
        #--optimizasyon icin-------------------------------------------
        df_join['Rotational Edge Fixity X (N/mm)']=0
        df_join['Rotational Edge Fixity Y (N/mm)']=0
        df_join['X Stiffener Material']="2050-T84 (L,LT,45)  (0.5-1.5 in.) "
        df_join['X Stiffener Type']="Single Sided"
        df_join['X Flange Definition for Restrained Condition']="Single Flange"
        df_join['X Flange Width (mm)']=0
        df_join['n1\n(ply1)']=2
        df_join['n2\n(ply2)']=2
        df_join['n3\n(ply3)']=2
        df_join['n4\n(ply4)']=2
        df_join['X Web Width (mm)']=0
        df_join['n1\n(ply1).1']=2
        df_join['n2\n(ply2).1']=2
        df_join['n3\n(ply3).1']=2
        df_join['n4\n(ply4).1']=2
        df_join['Y Stiffener Material']="2050-T84 (L,LT,45)  (0.5-1.5 in.) "
        df_join['Y Stiffener Type']="Single Sided"
        df_join['Y Flange Definition for Restrained Condition']="Single Flange"
        df_join['Y Flange Width (mm)']=0
        df_join['n1\n(ply1).2']=2
        df_join['n2\n(ply2).2']=2
        df_join['n3\n(ply3).2']=2
        df_join['n4\n(ply4).2']=2
        df_join['Y Web Width (mm)']=0
        df_join['n1\n(ply1).3']=2
        df_join['n2\n(ply2).3']=2
        df_join['n3\n(ply3).3']=2
        df_join['n4\n(ply4).3']=2
        df_join['NxL']=df_join['NxU']
        df_join['NyL']=df_join['NyU']
        df_join['Dhole (mm)']=0
        df_join['t (mm)']=df_join_default["T"]
        df_join['Load Case Name']=df_join_default["Subcase ID"]
        
        new_order=['X Boundary Condition',
               'Y Boundary Condition', 'Edge Restraint Definition',
               'Rotational Edge Fixity X (N/mm)', 'Rotational Edge Fixity Y (N/mm)',
               'X Stiffener Material', 'X Stiffener Type',
               'X Flange Definition for Restrained Condition', 'X Flange Width (mm)',
               'n1\n(ply1)', 'n2\n(ply2)', 'n3\n(ply3)', 'n4\n(ply4)',
               'X Web Width (mm)', 'n1\n(ply1).1', 'n2\n(ply2).1', 'n3\n(ply3).1',
               'n4\n(ply4).1', 'Y Stiffener Material', 'Y Stiffener Type',
               'Y Flange Definition for Restrained Condition', 'Y Flange Width (mm)',
               'n1\n(ply1).2', 'n2\n(ply2).2', 'n3\n(ply3).2', 'n4\n(ply4).2',
               'Y Web Width (mm)', 'n1\n(ply1).3', 'n2\n(ply2).3', 'n3\n(ply3).3',
               'n4\n(ply4).3', 'Percent Fixity', 'a (mm)', 'b (mm)', 'Rx (mm)',
               'Ry (mm)', 'Load Case Name', 'NxU', 'NxL', 'NyU', 'NyL', 'Nxy',
               'Dhole (mm)', 'Shell Material', 'Shell n1 (ply1)', 'Shell n2 (ply2)',
               'Shell n3 (ply3)', 'Shell n4 (ply4)', 'aoff (°)', 't (mm)','RF']
        #--------------------------------------------------------------
        
        df_out=df_join.copy()
        try:
            df_out=df_out[new_order]
        except Exception as e:
            print(e)
            
        dt=time.time()-start
        return ttb_sheet,df_out,dt
    
    
    def wait_process(process_name):
        while not any(proc.name().lower()==process_name.lower() for proc in psutil.process_iter()):
            time.sleep(1)
        print("the process has started.")
        
        while any(proc.name().lower()==process_name.lower() for proc in psutil.process_iter()):
            time.sleep(1)
        print("the process has finished.")
    
    begin=time.time()
    ttb_sheet="Panel Buckling Ritz-Autom"
    ws=wb.sheets(ttb_sheet)
    ttb_sheet="RitzBuckling_"+mat
    # rows = rows+start-1 if rows>=11 else start+1 #necessary tweak, rows makes the stop
    rows = rows+start-1
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    last_row = ws.range("B" + str(ws.cells.last_cell.row)).end('up').row
    # ws.range(f"B{start+1}:DW200").clear_contents() #clearing
    if start==rows: 
        ws.range(f"B{start+1}:DW{rows+1}").clear_contents() #clearing
    else: 
        ws.range(f"B{start+1}:DW{rows*2}").clear_contents() #clearing
        ws.range(f"B{start+1}:DW{last_row}").clear_contents() #clearing
    
    # writing specifics
    ws.range(f'B{start}').value=np.array(df_join["X Boundary (Ritz)"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["Y Boundary (Ritz)"]).reshape(-1,1)
    ws.range(f'D{start}:D{rows}').value=np.array(df_join["Edge restraint (Ritz)"]).reshape(-1,1)
    ws.range(f'E{start}:E{rows}').value=0
    ws.range(f'F{start}:F{rows}').value=0
    
    ws.range(f'G{start}:G{rows}').value="2050-T84 (L,LT,45)  (0.5-1.5 in.) "
    ws.range(f'H{start}:H{rows}').value="Single Sided"
    ws.range(f'I{start}:I{rows}').value="Single Flange"
    
    ws.range(f'T{start}:T{rows}').value="2050-T84 (L,LT,45)  (0.5-1.5 in.) "
    ws.range(f'U{start}:U{rows}').value="Single Sided"
    ws.range(f'V{start}:V{rows}').value="Single Flange"
    
    ll=["J","K","L","M","N","O","P","Q","R","S",
        "W","X","Y","Z","AA","AB","AC","AD","AE","AF"]
    for c in ll: 
        if c in ["J","O","W","AB"]:
            ws.range(f'{c}{start}:{c}{rows}').value=0
        else:
            ws.range(f'{c}{start}:{c}{rows}').value=2
    
    ws.range(f'AG{start}:AG{rows}').value=np.array(df_join["Percent Fixity (Ritz)"]).reshape(-1,1)
    ws.range(f'AH{start}:AH{rows}').value=np.array(df_join["Panel Length X"]).reshape(-1,1)
    ws.range(f'AI{start}:AI{rows}').value=np.array(df_join["Panel Length Y"]).reshape(-1,1)
    
    #radius of curvature fix
    def fix_radius_curve(x):
        try:
            if float(x): return x
            else: return 0
        except:
            return 0
    
    df_join["Radius of Curvature X"]=df_join["Radius of Curvature X"].apply(lambda x: fix_radius_curve(x))
    df_join["Radius of Curvature Y"]=df_join["Radius of Curvature Y"].apply(lambda x: fix_radius_curve(x))
    ws.range(f'AJ{start}:AJ{rows}').value=np.array(df_join["Radius of Curvature X"]).reshape(-1,1)
    ws.range(f'AK{start}:AK{rows}').value=np.array(df_join["Radius of Curvature Y"]).reshape(-1,1)
    
    ws.range(f'AL{start}').value=np.array(df_join["Subcase ID"]).reshape(-1,1)
    ws.range(f'AM{start}').value=np.array(df_join["Nx Average"]).reshape(-1,1)
    ws.range(f'AN{start}').value=np.array(df_join["Nx Average"]).reshape(-1,1)
    ws.range(f'AO{start}').value=np.array(df_join["Ny Average"]).reshape(-1,1)
    ws.range(f'AP{start}').value=np.array(df_join["Ny Average"]).reshape(-1,1)
    ws.range(f'AQ{start}').value=np.array(df_join["Nxy Average"]).reshape(-1,1)
    ws.range(f'AR{start}').value=np.array(df_join["Dhole (mm)"]).reshape(-1,1)
    # ws.range(f'AX{start}:AX{rows}').value=0
    ws.range(f'AX{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    ws.range(f'AS{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'AT{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'AU{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'AV{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'AW{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    
    if start!=rows:
        ws.range(f'AY{start}:DW{start}').api.AutoFill(Destination=ws.range(f'AY{start}:DW{rows}').api,Type=0) #filling
        
    #BUTTON PRESS
    button_name="OptionButton1" #buckling mode
    for shape in ws.shapes:
        if shape.name==button_name and shape.api.OLEFormat.Object.Object.Enabled:
            shape.api.OLEFormat.Object.Object.Value=True
    
    #sadece sandwich icin buraya rf_sandwich icinde ulasıyorum, kullanıcıyı bekletmemek adına
    if mat=="sandwich":
        print("SANDWICH - found the ABD matrices, proceeding...")
        ttb_sheet="Sandwich Buckling Ritz-Autom"
        df_abd=df_join[["Total T","A11","A12","A13","A21","A22","A23","A31","A32","A33",\
                        "D11","D12","D13","D21","D22","D23","D31","D32","D33"]]
        ws.range(f'AY{start}:BQ{rows}').value=df_abd.values
        # ws.range(f'AT{start}:AW{rows}').value=99
    else:
        button_name="CommandButton1" #browse
        for shape in ws.shapes:
            if shape.name==button_name and shape.api.OLEFormat.Object.Object.Enabled:
                shape.api.OLEFormat.Object.Object.Value=True
    
    print(f"...starting Ritz.exe (with {len(df_join)} properties)")
    wb.macro("Ritz_Autom")()
    wait_process("Ritz_batch.exe")
    print("...finished Ritz.exe")
        
    end=time.time()
    try: 
        df_ritz=pd.read_csv("Ritz_Buckling_Autom.csv") #toolbox yanina cikariyor, ritz exe degil
        if len(df_ritz["RF"].to_list())==0: 
            print("Ritz result .csv is empty !")
    except Exception as e: 
        print(e)
    
    columns=ws.range(f'B{start-1}:BQ{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:BQ{rows}').value),columns=columns)
    
    #http://stackoff/questions/p5.50874117
    # if start==rows: ws.range(f"B{start+1}:DW{rows+1}").clear_contents() #clearing
    # else: ws.range(f"B{start+1}:DW{rows}").clear_contents() #clearing
    df_out["RF"]=df_ritz["RF"]
    
    dt=end-begin
    return ttb_sheet,df_out,dt

# =============================================================================
# CRIPPLING
# =============================================================================

def rf_crippling_metal(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    ttb_sheet="Metallic Crippling-Automation"
    ws=wb.sheets(ttb_sheet)
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    rows = rows+start-1
    ws.range(f"B{start+1}:Z2000").clear_contents() #clearing
    ws.range(f'B{start}:Z{start}').api.AutoFill(Destination=ws.range(f'B{start}:Z{rows}').api,Type=0) #filling
    
    # writing specifics
    ws.range(f'F{start}:F{rows}').value=0
    ws.range(f'G{start}:G{rows}').value=0
    ws.range(f'H{start}:H{rows}').value=0
    ws.range(f'I{start}:I{rows}').value=0
    ws.range(f'K{start}:K{rows}').value=0
    ws.range(f'L{start}:L{rows}').value=0
    ws.range(f'M{start}:M{rows}').value=0
    ws.range(f'N{start}:N{rows}').value=0
    ws.range(f'O{start}:O{rows}').value=4
    # ws.range(f'P{start}:P{rows}').value="A"
    
    ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["Crippling Section"]).reshape(-1,1)
    df_join["t1"],df_join["b1"],df_join["t3"],df_join["b3"]=None,None,None,None
    
    #gerekti, evet gerekti
    for i,row in enumerate(df_join["Crippling Section"]):
        if "double" in row.lower():
            df_join["t1"][i]=df_join["T"][i]
            df_join["b1"][i]=df_join["W"][i]/2
            df_join["b3"][i]=df_join["W"][i]/2
            df_join["t3"][i]=df_join["T"][i]
        else:
            df_join["t1"][i]=df_join["T"][i]
            df_join["b1"][i]=df_join["W"][i]
            df_join["b3"][i]=0
            df_join["t3"][i]=0
    
    ws.range(f'E{start}').value=np.array(df_join["b1"]).reshape(-1,1) #b1
    ws.range(f'G{start}').value=np.array(df_join["b3"]).reshape(-1,1) #b3
    ws.range(f'J{start}').value=np.array(df_join["t1"]).reshape(-1,1) #t1
    ws.range(f'L{start}').value=np.array(df_join["t3"]).reshape(-1,1) #t3
    #writing loads
    # ws.range(f'Q{start}').value=np.array(df_join["Axial Force"]).reshape(-1,1)
    ws.range(f'Q{start}').value=np.array(df_join["AF"]).reshape(-1,1)
    wb.app.calculate()
    
    columns=ws.range(f'B{start-1}:Z{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:Z{rows}').value),columns=columns)
    
    #THE TRICK-------------------------------
    all_contain_error=df_out["RF"].astype(str).str.contains('ERROR', case=False, na=False).all()
    if all_contain_error:
        ws.range(f'O{start}:O{rows}').value=2
        wb.app.calculate()
        ws.range(f'O{start}:O{rows}').value=4
        wb.app.calculate()
        
        columns=ws.range(f'B{start-1}:Z{start-1}').value
        df_out=pd.DataFrame((ws.range(f'B{start}:Z{rows}').value),columns=columns)
    #THE TRICK-------------------------------    
    
    if start==rows:  ws.range(f"B{start+1}:Z{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:Z{rows}").clear_contents() #clearing
    
    end=time.time()
    dt=end-begin
    return ttb_sheet,df_out,dt


def rf_crippling_composite(wb,rows,df_join):
    start=10 if df_join.shape[0]!=0 else 12
    begin=time.time()
    ttb_sheet="Composites Crippling-Automation"
    ws=wb.sheets(ttb_sheet)
    
    cols=["Bending Moment A1","Bending Moment A2","Bending Moment B1","Bending Moment B2","Shear Force 1","Shear Force 2","Axial Force","Torque"]
    cols2=["BM1A","BM2A","BM1B","BM2B","TS1","TS2","AF","TRQ"]
    
    for i,col in enumerate(cols):
        try:
            df_join.rename(columns={cols[i]:cols2[i]},inplace=True)
        except:
            pass
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    rows = rows+start-1
    ws.range(f"B{start+1}:AW2000").clear_contents() #clearing
    ws.range(f'B{start}:AW{start}').api.AutoFill(Destination=ws.range(f'B{start}:AW{rows}').api,Type=0) #filling
    
    #gerekti, evet gerekti
    df_join["t1"],df_join["b1"],df_join["t3"],df_join["b3"]=None,None,None,None
    
    """
    single flange -> b1=W and t1=T
    double flange -> b1=W/2 and t1=T
    """
    for i,row in enumerate(df_join["Crippling Section"]):
        if "double" in row.lower():
            df_join["t1"][i]=df_join["T"][i]
            df_join["b1"][i]=df_join["W"][i]/2
            # df_join["b3"][i]=df_join["W"][i]/2
            # df_join["t3"][i]=df_join["T"][i]
            
        else:
            df_join["t1"][i]=df_join["T"][i]
            df_join["b1"][i]=df_join["W"][i]
            # df_join["b3"][i]=0
            # df_join["t3"][i]=0
      
    # writing specifics
    ws.range(f'B{start}:B{rows}').value="Single Flange"
    ws.range(f'C{start}:C{rows}').value=np.array(df_join["b1"]).reshape(-1,1) #b1
    ws.range(f'D{start}:D{rows}').value=0
    ws.range(f'E{start}:E{rows}').value=0 #b3
    ws.range(f'F{start}:F{rows}').value=0
    ws.range(f'G{start}:G{rows}').value=0
    # ws.range(f'P{start}:P{rows}').value="A"
    
    ws.range(f'H{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'I{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'J{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'K{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'L{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    
    #SECTION 1
    ws.range(f'M{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'N{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'O{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'P{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    
    #SECTION 3
    ws.range(f'U{start}:U{rows}').value=1
    ws.range(f'V{start}:V{rows}').value=1
    ws.range(f'W{start}:W{rows}').value=1
    ws.range(f'X{start}:X{rows}').value=2
    
    #SECTION 2
    ws.range(f'Q{start}:Q{rows}').value=1
    ws.range(f'R{start}:R{rows}').value=1
    ws.range(f'S{start}:S{rows}').value=1
    ws.range(f'T{start}:T{rows}').value=2
    
    #SECTION 4
    ws.range(f'Y{start}:Y{rows}').value=1
    ws.range(f'Z{start}:Z{rows}').value=1
    ws.range(f'AA{start}:AA{rows}').value=1
    ws.range(f'AB{start}:AB{rows}').value=2
    
    #SECTION 5
    ws.range(f'AC{start}:AC{rows}').value=1
    ws.range(f'AD{start}:AD{rows}').value=1
    ws.range(f'AE{start}:AE{rows}').value=1
    ws.range(f'AF{start}:AF{rows}').value=2
    
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    ws.range(f'AG{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
    ws.range(f'AH{start}:AH{rows}').value="HW"
    
    #writing loads
    ws.range(f'AI{start}').value=np.array(df_join["AF"]).reshape(-1,1)
    wb.app.calculate()
    
    columns=ws.range('B9:AI9').value + ws.range('AJ8:AW8').value
    # columns=ws.range('B9:P9').value + ws.range('AG8:AW8').value
    df_out=pd.DataFrame((ws.range(f'B{start}:AW{rows}').value),columns=columns)
    
    #THE TRICK-------------------------------
    all_contain_error=df_out["Fcc  (MPa)"].astype(str).str.contains('error', case=False, na=False).all()
    if all_contain_error:
        print("WARNING - all results are ERROR, trying again.")
        ws.range(f'M{start}:M{rows}').value=99
        wb.app.calculate()
        ws.range(f'M{start}').value=np.array(df_join["n1"]).reshape(-1,1)
        wb.app.calculate()
        
        columns=ws.range('B9:AI9').value + ws.range('AJ8:AW8').value
        df_out=pd.DataFrame((ws.range(f'B{start}:AW{rows}').value),columns=columns)
    #THE TRICK------------------------------- 
    
    if start==rows:  ws.range(f"B{start+1}:AW{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:AW{rows}").clear_contents() #clearing
    
    end=time.time()
    ttb_sheet="CompositesCrippling (BARZ)"
    dt=end-begin
    
    #DUPLICATE COLUMNS TRICK
    df_out.columns=pd.Series(df_out.columns).duplicated().cumsum().astype(str).radd(df_out.columns+'_').\
        where(pd.Series(df_out.columns).duplicated(),df_out.columns)
    
    return ttb_sheet,df_out,dt


# =============================================================================
# ADDITIONAL COMPOSITE BAR FAILURES
# =============================================================================

def rf_unfolding(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    
    if ml_choice.get()==1:
        ttb_sheet="Unnotched Strength - AI"
        models=joblib.load(ml_path)
        
        result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
        root.update_idletasks()
        
        #some preprocessing
        #df_join["Temperature (C)"].fillna(100,inplace=True)
        inputs=["Nx","Ny","Nxy","Mx","My","Mxy","n1","n2","n3","n4","Temperature (C)"]
        addition=["T"]
        
        #prediction
        df_out=df_join[addition+inputs]
        df_out.rename(columns={"T" : "t (mm)"}, inplace=True)
        df_out["RF"]=models["Unnotched"].predict(np.array(df_join[inputs]))
        dt=time.time()-start
        
        return ttb_sheet,df_out,dt
    
    ttb_sheet="Unfolding-Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # rows = rows+start-1 if rows>=9 else start+1 #necessary tweak, rows makes the stop
    rows = rows+start-1
    
    ws.range(f"B{start+1}:AD20000").clear_contents() #clearing
    ws.range(f'B{start}:AD{start}').api.AutoFill(Destination=ws.range(f'B{start}:AD{rows}').api,Type=0) #filling
    
    # writing specifics
    ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'K{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    ws.range(f'L{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
    ws.range(f'M{start}:M{rows}').value="HW"
    
    df_join["Fillet Radius (mm)"].fillna(4,inplace=True)
    ws.range(f'N{start}').value=np.array(df_join["Fillet Radius (mm)"]).reshape(-1,1)
    
    #writing loads
    df_join["M - Absolute"]=np.where(abs(df_join["M - Web Radius"]) >= abs(df_join["M - Flange Level"]), df_join["M - Web Radius"], df_join["M - Flange Level"])
    ws.range(f'O{start}').value=np.array(df_join["P - Web Radius"]).reshape(-1,1)
    ws.range(f'Q{start}').value=np.array(df_join["M - Absolute"]).reshape(-1,1)
    ws.range(f'P{start}').value=np.array(df_join["Q - Web Radius"]).reshape(-1,1)
    
    wb.app.calculate()
    end=time.time()
    
    columns=ws.range(f'B{start-1}:AD{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:AD{rows}').value),columns=columns)
    
    if start==rows:  ws.range(f"B{start+1}:AD{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:AD{rows}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt

def rf_ei_bars(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    if ml_choice.get()==1:
        ttb_sheet="Edge Residual - AI"
        models=joblib.load(ml_path)
        
        #some preprocessing
        #df_join["Temperature (C)"].fillna(100,inplace=True)
        inputs=["Nx","Ny","Nxy","Mx","My","Mxy","n1","n2","n3","n4","Temperature (C)"]
        addition=["T"]
        
        #prediction
        df_out=df_join[addition+inputs]
        df_out.rename(columns={"T" : "t (mm)"}, inplace=True)
        df_out["RF"]=models["E-Residual"].predict(np.array(df_join[inputs]))
        dt=time.time()-start
        
        return ttb_sheet,df_out,dt
    
    cols=["Bending Moment A1","Bending Moment A2","Bending Moment B1","Bending Moment B2","Shear Force 1","Shear Force 2","Axial Force","Torque"]
    cols2=["BM1A","BM2A","BM1B","BM2B","TS1","TS2","AF","TRQ"]
    
    for i,col in enumerate(cols):
        try:
            df_join.rename(columns={cols[i]:cols2[i]},inplace=True)
        except:
            pass
        
    ttb_sheet="Edge Residual Str-Autom"
    ws=wb.sheets(ttb_sheet)
    
    df_join["Nx Average"]=df_join["AF"]/df_join["W"]
    df_join["Ny Average"]=0
    df_join["Nxy Average"]=0
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    rows = rows+start-1
    ws.range(f"B{start+1}:AF200").clear_contents() #clearing
    ws.range(f'B{start}:AF{start}').api.AutoFill(Destination=ws.range(f'B{start}:AF{rows}').api,Type=0) #filling
    
    # writing specifics
    ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'K{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    #misc
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    ws.range(f'L{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
    ws.range(f'M{start}:M{rows}').value="HW"
    ws.range(f'N{start}:N{rows}').value=1000 #curvature
    
    #writing loads
    ws.range(f'O{start}').value=np.array(df_join["Nx Average"]).reshape(-1,1)
    ws.range(f'P{start}').value=np.array(df_join["Ny Average"]).reshape(-1,1)
    ws.range(f'Q{start}').value=np.array(df_join["Nxy Average"]).reshape(-1,1)

    wb.app.calculate()
    end=time.time()
    
    columns=ws.range(f'B{start-1}:AF{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:AF{rows}').value),columns=columns)
    
    if start==rows:  ws.range(f"B{start+1}:AF{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:AF{rows}").clear_contents() #clearing
    
    dt=end-begin
    ttb_sheet="Edge Residual Str-Autom (BARZ)"
    return ttb_sheet,df_out,dt


def rf_ir_buckling_composite(wb,rows,df_join,df_misc_joint):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    """
    ELS 320 -> 1.5
    ELS 420 -> 3.0
    HST 645 -> 4.0
    HST 646 -> 2.0
    BG 2082 -> 1.0
    
    NAS1151E-1158E -> 1.0 #automatin tab
    """
    
    ttb_sheet="Interrivet Buckling-Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # def change_pin(x):
    #     if x=="ELS320": return 1.5/1
    #     elif x=="ELS420": return 3.0/1
    #     elif x=="ELS645": return 4.0/1
    #     elif x=="ELS646": return 2.0/1
    #     elif x=="BG2082": return 1.0/1
    #     else: 1.0/2.0
    
    file_name=os.path.basename(path_entry9.get())
    print("(INFO) IR Buckling -> BARZ, taking the max diameter for each prop.")
    
    """
    joint sheetinde sadece metal ve onlarında max dia bırakıyorum, 1 satır yapmak icin
    daha sonra bunun diameter, pin vb. 4 kolonunu alıp
    general sheet + load sheet ' e ekliyorum Property ID üzerinden
    """
    
    # df_join.rename(columns={"Element ID":"Element ID (PBARL)", "Property ID":"Property ID (PBARL)"},inplace=True)
    df_misc_joint=df_misc_joint[df_misc_joint["MAT"].str.contains('m21|m91|quartz',regex=True,case=False,na=False)]
    df_misc_joint.dropna(subset="Diameter",inplace=True)
    df_misc_joint=df_misc_joint.loc[df_misc_joint.groupby("Property ID (PBARL)")["Diameter"].idxmax()]
    # df_misc_joint=df_misc_joint[["Property ID (PBARL)","Element ID (PBARL)", "Pin", "Diameter", "Pitch"]]
    df_misc_joint=df_misc_joint[["Property ID (PBARL)", "Pin", "Diameter", "Pitch"]]
    df_misc_joint.rename(columns={"Property ID (PBARL)":"Property ID"},inplace=True)
    
    df_join=pd.merge(df_misc_joint,df_join,on="Property ID",how="inner")
    
    # df_join=pd.merge(df_join,df_joint,on="Element ID",how="inner")
    ttb_sheet="IR Buckling (BARZ)"
    
    #burasi önemli, önce row sayarsa örneğin 1920 sayıyor ama yukarıda 1910'a iniyor, 
    #dolayısıyla 1920'ye göre autofill yapıyordu ve 10 tanesi öyle kalıyordu, şimdi ok
    rows=df_join.shape[0]
    rows = rows+start-1
    
    if start==rows: ws.range(f"B{start+1}:T{(rows+1)*2}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:T{rows*2}").clear_contents() #clearing
    
    ws.range(f'B{start}:T{start}').api.AutoFill(Destination=ws.range(f'B{start}:T{rows}').api,Type=0) #filling
    
    # df_join["Pin"].loc[df_join["Pin"]=="BG2082"]="NAS1151E-1158E"
    # df_join["factor"] = df_join["Pin"].apply(lambda x: change_pin(x)) #Cir faktörü için düzeltmeye gidiyorum
    # df_join["Pin"]="NAS1151E-1158E"
    # df_join["Pin"]=df_join["Pin"].apply(lambda x: x if x in ["ELS320","ELS420","HST645","HST646"])
    ws.range(f'B{start}').value=np.array(df_join["Pin"]).reshape(-1,1)
    
    df_join["MAT"]=df_join["MAT"].apply(lambda x: "Quartz/8552 8HS 285 g/m^2" if x=="Quartz/8552 8HS 285 g" else x) #quartz naming fix
    ws.range(f'C{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'G{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'L{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    ws.range(f'M{start}').value=np.array(df_join["Pitch"]*df_join["Diameter"]).reshape(-1,1)
    ws.range(f'N{start}:N{rows}').value="Tail side"
    
    ws.range(f'O{start}').value=np.array(df_join["AF"]/df_join["W"]).reshape(-1,1)
    
    wb.app.calculate()
    end=time.time()
    #main output
    columns=ws.range(f'B{start-1}:T{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:T{rows}').value),columns=columns)
    
    def fix_RF(x):
        try:
            if "HIGH" in x: return 1000
            else: return x
        except:
            return x
        
    df_out["RF"]=df_out["RF"].apply(lambda x: fix_RF(x)) #HIGH ise 1000 yapıyorum #HIGH ise 1000 yapıyorum
    df_addition=df_join[["Element ID","Property ID","Subcase ID"]] #joining with some input cols
    df_out=pd.concat((df_addition,df_out),axis=1) #yep doing it here
    
    if start==rows: ws.range(f"B{start+1}:T{(rows+1)*2}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:T{rows*2}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt


def rf_ils_bars(wb,rows,df_join):
    try:
        wb.app.api.Calculation=xw.constants.Calculation.xlCalculationManual
    except:
        pass
    
    start=11 if df_join.shape[0]!=0 else 13
    begin=time.time()
    if ml_choice.get()==1:
        return None
    
    cols=["Bending Moment A1","Bending Moment A2","Bending Moment B1","Bending Moment B2","Shear Force 1","Shear Force 2","Axial Force","Torque"]
    cols2=["BM1A","BM2A","BM1B","BM2B","TS1","TS2","AF","TRQ"]
    
    for i,col in enumerate(cols):
        try:
            df_join.rename(columns={cols[i]:cols2[i]},inplace=True)
        except:
            pass
    
    df_join["QX"]=df_join["TS2"]/df_join["W"]
    df_join["QY"]=0
    
    ttb_sheet="Interlaminar Shear"
    ws=wb.sheets(ttb_sheet)
    ws.api.Unprotect(Password="TAT2530TFX")
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    df_origin=df_join.copy()
    ll=[]
    for thickness in df_join["T"].unique():
        df_join=df_origin[df_origin["T"]==thickness]
        
        if df_join.shape[0]==1:
            df_join=pd.concat([df_join,df_join]) #burada 1 row var ise ikiliyorum, yoksa sacmaliyor
            print("WARNING - 1 row input")
            
        rows=df_join.shape[0]
        rows = rows+start-1 #necessary tweak, rows makes the stop
        
        if start==rows: ws.range(f"U{start+1}:AJ{(rows+1)*2}").clear_contents() #clearing
        else: ws.range(f"U{start+1}:AJ{rows*2}").clear_contents() #clearing
        
        ws.range(f'U{start}').value=np.array(df_join["Subcase ID"]).reshape(-1,1)
        ws.range(f'V{start}').value=np.array(df_join["QX"]).reshape(-1,1)
        ws.range(f'W{start}').value=np.array(df_join["QY"]).reshape(-1,1)
        
        # #df_join["Temperature (C)"].fillna(100,inplace=True)
        ws.range(f'X{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
        ws.range(f'Y{start}:Y{rows}').value="HW"
        
        #calling command_button in vba-----------------------------------------------------
        n1,n2,n3,n4=df_join["n1"].iloc[0],df_join["n2"].iloc[0],df_join["n3"].iloc[0],df_join["n4"].iloc[0] 
        ws.range("C10").value=df_join["MAT"].iloc[0] #.loc index ile cagırıyor, sakıncalı
        ws.range("C12:C15").value=np.array([n1,n2,n3,n4]).reshape(-1,1)
        mater = ws.range("C10")
        plycount1 = ws.range("C12")
        plycount2 = ws.range("C13").value * 2
        plycount3 = ws.range("C15")
        Clear_Range = "b22"
        wb.macro("Layup_Gen_SS")(mater, plycount1, plycount2, plycount3, Clear_Range, "Interlaminar Shear")
        #--------------------------------------------------------------------------------
        
        ws.range(f'AA{start}:AJ{start}').api.AutoFill(Destination=ws.range(f'AA{start}:AJ{rows+1}').api,Type=0) #filling
        
        #I dont know why this is necessary exactly but otherwise RF just gives #VALUE, thus refreshing loads
        ws.range(f'V{start}').value=np.array(df_join["QX"]).reshape(-1,1)
        ws.range(f'W{start}').value=np.array(df_join["QY"]).reshape(-1,1)
        wb.app.calculate()
        
        columns=ws.range(f'V{start-1}:AJ{start-1}').value
        df_out=pd.DataFrame((ws.range(f'V{start}:AJ{rows}').options(ndim=2).value),columns=columns)
        
        # df_out.rename(columns={df_out.columns[6]:"RF"},inplace=True) #RF column has weird spaces, renaming it as simple RF
        df_addition=df_join[["Element ID", "Property ID","Subcase ID","MAT","T","n1","n2","n3","n4"]].reset_index().drop("index",axis=1)
        df_out=pd.concat((df_addition,df_out),axis=1)
        ll.append(df_out)
        
        if start==rows: ws.range(f"U{start+1}:AJ{(rows+1)*2}").clear_contents() #clearing
        else: ws.range(f"U{start+1}:AJ{rows*2}").clear_contents() #clearing
        
    df_out=pd.concat(ll)
    end=time.time()
    dt=end-begin
    
    if start==rows:  ws.range(f"U{start+1}:AJ{rows+1}").clear_contents() #clearing
    else: ws.range(f"U{start+1}:AJ{rows}").clear_contents() #clearing
    
    ws.api.Protect(Password="TAT2530TFX")
    ttb_sheet="Interlaminar Shear (BARZ)"
    return ttb_sheet,df_out,dt


# =============================================================================
# METAL - STRENGTH
# =============================================================================

def get_kdf(x,mat):
    if "2050" or "7050" in mat: kdf = -0.0004 * x ** 2 + 0.0861 * x + 93.551
    if mat.lower().startswith("ph"): kdf = 0.000004 * x ** 2 - 0.0382 * x + 103.14
    if mat.lower().startswith("ti"): kdf = kdf = 0.00006 * x ** 2 - 0.1121 * x + 112.01
    else: kdf=100
    
    return kdf/100

def rf_strength(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    ttb_sheet="Metallic Strength"
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # writing specifics
    df_out=pd.DataFrame()
    df_out["MAT"]=df_join["MAT"]
    df_out["Temperature (C)"] = df_join["Temperature (C)"]
    
    #KDF EKLENTİSİ--------------------------------
    df_join["KDF"]=None
    for i,row in df_join.iterrows():
        temp=df_join["Temperature (C)"][i]
        mat=df_join["MAT"][i]
        df_join["KDF"][i]=get_kdf(temp,mat)
    
    df_out["KDF"]=df_join["KDF"]
    #KDF EKLENTİSİ--------------------------------
    
    df_out["S_max"]=df_join[["N-Sigma Von Mises Z1","N-Sigma Von Mises Z2",
                             "N-Sigma Max Principal Z1","N-Sigma Max Principal Z2",
                             "N-Sigma Min Principal Z1","N-Sigma Min Principal Z2"]].abs().max(axis=1)
    df_out["t (mm)"]=df_join["T"]
    
    df_out["Class"]=df_join["Class"]
    if ultimate_choice.get()==0:
        df_join["Allowable (MPa)"]=df_join.apply(lambda row: row["Ftu (A-basis)"] if row["Class"].lower()=="a" else row["Ftu (B-basis)"], axis=1)
        # df_out["Ftu"]=df_join["Ftu"]
        df_out["Allowable (MPa)"]=df_join["Allowable (MPa)"]
        df_out["RF"]=df_join["Allowable (MPa)"]*df_out["KDF"]/df_out["S_max"]
        ttb_sheet="MetallicStrength-Ultimate"
    else:
        df_join["Allowable (MPa)"]=df_join.apply(lambda row: row["Fty (A-basis)"] if row["Class"].lower()=="a" else row["Fty (B-basis)"], axis=1)
        df_out["Allowable (MPa)"]=df_join["Allowable (MPa)"]
        df_out["RF"]=df_join["Allowable (MPa)"]*df_out["KDF"]/df_out["S_max"]
        ttb_sheet="MetallicStrength-Proof"
        
    end=time.time()
    dt=end-begin
    
    return ttb_sheet,df_out,dt


def rf_durability(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    ttb_sheet="Metallic Durability"
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # writing specifics
    df_out=pd.DataFrame()
    df_out["MAT"]=df_join["MAT"]
    # #df_join["Temperature (C)"].fillna(100,inplace=True)
    # df_out["Temperature (C)"] = df_join["Temperature (C)"]
    # df_out["S_max"]=df_join[["Average Von Mises Z1","Average Von Mises Z2",
    #                              "Average Max Principal Z1","Average Max Principal Z2",
    #                              "Average Min Principal Z1","Average Min Principal Z2"]].abs().max(axis=1)
    
    df_out["S_max"]=df_join[["Average Max Principal Z1","Average Max Principal Z2"]].abs().max(axis=1)
                                 
    df_out["t (mm)"]=df_join["T"]
    df_out["Fdur"]=df_join["Fdur"]
    df_out["RF"]=df_join["Fdur"]/df_out["S_max"]
      
    end=time.time()
    dt=end-begin
    
    return ttb_sheet,df_out,dt


def rf_bar_strength(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    ttb_sheet="Metallic Strength (BARZ)"
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # writing specifics
    df_out=pd.DataFrame()
    df_out["MAT"]=df_join["MAT"]
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    df_out["Temperature (C)"] = df_join["Temperature (C)"]
    
    #KDF EKLENTİSİ--------------------------------
    df_join["KDF"]=None
    for i,row in df_join.iterrows():
        temp=df_join["Temperature (C)"][i]
        mat=df_join["MAT"][i]
        df_join["KDF"][i]=get_kdf(temp,mat)
    
    df_out["KDF"]=df_join["KDF"]
    #KDF EKLENTİSİ--------------------------------
    
    df_out["S_max"]=df_join["N-Sigma Von Mises"]
    df_out["t (mm)"]=df_join["T"]
    
    df_out["Class"]=df_join["Class"]
    if ultimate_choice.get()==0:
        df_join["Allowable (MPa)"]=df_join.apply(lambda row: row["Ftu (A-basis)"] if row["Class"].lower()=="a" else row["Ftu (B-basis)"], axis=1)
        df_out["Allowable (MPa)"]=df_join["Allowable (MPa)"]
        
        df_out["RF"]=df_join["Allowable (MPa)"]*df_out["KDF"]/df_out["S_max"]
        ttb_sheet="MetallicStrength(BARZ)-Ultimate"
    else:
        df_join["Allowable (MPa)"]=df_join.apply(lambda row: row["Fty (A-basis)"] if row["Class"].lower()=="a" else row["Fty (B-basis)"], axis=1)
        df_out["Allowable (MPa)"]=df_join["Allowable (MPa)"]
        df_out["RF"]=df_join["Allowable (MPa)"]*df_out["KDF"]/df_out["S_max"]
        ttb_sheet="MetallicStrength(BARZ)-Proof"
        
    end=time.time()
    dt=end-begin
    
    return ttb_sheet,df_out,dt


def rf_bar_durability(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    ttb_sheet="Metallic Durability (BARZ)"
     
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
       
    # writing specifics
    df_out=pd.DataFrame()
    df_out["MAT"]=df_join["MAT"]
    # #df_join["Temperature (C)"].fillna(100,inplace=True)
    # df_out["Temperature (C)"] = df_join["Temperature (C)"]
    df_out["S_max"]=df_join["Average Von Mises"]
    df_out["t (mm)"]=df_join["T"]
    df_out["Fdur"]=df_join["Fdur"]
    df_out["RF"]=df_join["Fdur"]/df_out["S_max"]
      
    end=time.time()
    dt=end-begin
    
    return ttb_sheet,df_out,dt

""" ALL LOAD CALCS - OLD """

def rf_strength_ALL(wb,rows,df_join,start=9):
    begin=time.time()
    ttb_sheet="Metallic Strength"
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
        
    # writing specifics
    df_out=pd.DataFrame()
    df_out["MAT"]=df_join["MAT"]
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    df_out["Temperature (C)"] = df_join["Temperature (C)"]
    df_out["S_max"]=abs(df_join[["S Von Mises @Z1","S Von Mises @Z2",
                             "S Max Principal @Z1","S Max Principal @Z1",
                             "S Min Principal @Z1","S Min Principal @Z2"]].max(axis=1))
    df_out["Ftu"]=df_join["Ftu"]
    df_out["RF"]=df_join["Ftu"]/df_out["S_max"]
    
    end=time.time()
    dt=end-begin
    
    return ttb_sheet,df_out,dt


def rf_durability_ALL(wb,rows,df_join,start=9):
    begin=time.time()
    ttb_sheet="Metallic Durability"
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # writing specifics
    df_out=pd.DataFrame()
    df_out["MAT"]=df_join["MAT"]
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    df_out["Temperature (C)"] = df_join["Temperature (C)"]
    df_out["S_max"]=abs(df_join[["N-Sigma Von Mises Z1","N-Sigma Von Mises Z2"]].max(axis=1))
    df_out["Fdur"]=df_join["Fdur"]
    df_out["RF"]=df_join["Fdur"]/df_out["S_max"]
      
    end=time.time()
    dt=end-begin
    
    return ttb_sheet,df_out,dt


def rf_bar_strength_ALL(wb,rows,df_join,start=9):
    begin=time.time()
    ttb_sheet="Metallic Strength (BARZ)"
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # writing specifics
    df_out=pd.DataFrame()
    df_out["MAT"]=df_join["MAT"]
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    df_out["Temperature (C)"] = df_join["Temperature (C)"]
    df_out["S_max"]=df_join["Von Mises Stress"]
    df_out["Ftu"]=df_join["Ftu"]
    df_out["RF"]=df_join["Ftu"]/df_out["S_max"]
      
    end=time.time()
    dt=end-begin
    
    return ttb_sheet,df_out,dt


def rf_bar_durability_ALL(wb,rows,df_join,start=9):
    begin=time.time()
    ttb_sheet="Metallic Durability (BARZ)"
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # writing specifics
    df_out=pd.DataFrame()
    df_out["MAT"]=df_join["MAT"]
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    df_out["Temperature (C)"] = df_join["Temperature (C)"]
    df_out["S_max"]=df_join["N-Sigma Von Mises"]
    df_out["Fdur"]=df_join["Fdur"]
    df_out["RF"]=df_join["Fdur"]/df_out["S_max"]
      
    end=time.time()
    dt=end-begin
    
    return ttb_sheet,df_out,dt


#IR BUCKLING
def rf_ir_buckling_metal(wb,rows,df_join,df_misc_joint):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    """
    ELS 320 -> 1.5
    ELS 420 -> 3.0
    HST 645 -> 4.0
    HST 646 -> 2.0
    BG 2082 -> 1.0
    
    NAS1151E-1158E -> 1.0 #automatin tab
    """
    
    ttb_sheet="Interrivet Buckling-Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # def change_pin(x):
    #     if x=="ELS320": return 1.5/1
    #     elif x=="ELS420": return 3.0/1
    #     elif x=="ELS645": return 4.0/1
    #     elif x=="ELS646": return 2.0/1
    #     elif x=="BG2082": return 1.0/1
    #     else: 1.0/2.0
    
    file_name=os.path.basename(path_entry9.get())
    print("(INFO) IR Buckling -> BARZ, taking the max diameter for each prop.")
    
    """
    joint sheetinde sadece metal ve onlarında max dia bırakıyorum, 1 satır yapmak icin
    daha sonra bunun diameter, pin vb. 4 kolonunu alıp
    general sheet + load sheet ' e ekliyorum Property ID üzerinden
    """
    
    # df_join.rename(columns={"Element ID":"Element ID (PBARL)", "Property ID":"Property ID (PBARL)"},inplace=True)
    df_misc_joint=df_misc_joint[~df_misc_joint["MAT"].str.contains('m21|m91|quartz',regex=True,case=False,na=False)]
    df_misc_joint.dropna(subset="Diameter",inplace=True)
    df_misc_joint=df_misc_joint.loc[df_misc_joint.groupby("Property ID (PBARL)")["Diameter"].idxmax()]
    
    # df_misc_joint=df_misc_joint[["Property ID (PBARL)","Element ID (PBARL)", "Pin", "Diameter", "Pitch"]]
    df_misc_joint=df_misc_joint[["Property ID (PBARL)", "Pin", "Diameter", "Pitch"]]
    df_misc_joint.rename(columns={"Property ID (PBARL)":"Property ID"},inplace=True)
    df_join=pd.merge(df_misc_joint,df_join,on="Property ID",how="inner")
    
    
    # df_join=pd.merge(df_join,df_joint,on="Element ID",how="inner")
    ttb_sheet="IR Buckling (BARZ)"
    
    #burasi önemli, önce row sayarsa örneğin 1920 sayıyor ama yukarıda 1910'a iniyor, 
    #dolayısıyla 1920'ye göre autofill yapıyordu ve 10 tanesi öyle kalıyordu, şimdi ok
    rows=df_join.shape[0]
    rows = rows+start-1
    
    if start==rows: ws.range(f"B{start+1}:T{(rows+1)*2}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:T{rows*2}").clear_contents() #clearing
    
    ws.range(f'B{start}:T{start}').api.AutoFill(Destination=ws.range(f'B{start}:T{rows}').api,Type=0) #filling
    
    # df_join["Pin"].loc[df_join["Pin"]=="BG2082"]="NAS1151E-1158E"
    # df_join["factor"] = df_join["Pin"].apply(lambda x: change_pin(x)) #Cir faktörü için düzeltmeye gidiyorum
    # df_join["Pin"]="NAS1151E-1158E"
    # df_join["Pin"]=df_join["Pin"].apply(lambda x: x if x in ["ELS320","ELS420","HST645","HST646"])
    ws.range(f'B{start}').value=np.array(df_join["Pin"]).reshape(-1,1)
    
    df_join["MAT"]=df_join["MAT"].apply(lambda x: "Quartz/8552 8HS 285 g/m^2" if x=="Quartz/8552 8HS 285 g" else x) #quartz naming fix
    ws.range(f'C{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'G{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'L{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    ws.range(f'M{start}').value=np.array(df_join["Pitch"]*df_join["Diameter"]).reshape(-1,1)
    ws.range(f'N{start}:N{rows}').value="Tail side"
    
    ws.range(f'O{start}').value=np.array(df_join["AF"]/df_join["W"]).reshape(-1,1)
    
    wb.app.calculate()
    end=time.time()
    #main output
    columns=ws.range(f'B{start-1}:T{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:T{rows}').value),columns=columns)
    
    def fix_RF(x):
        try:
            if "HIGH" in x: return 1000
            else: return x
        except:
            return x
        
    df_out["RF"]=df_out["RF"].apply(lambda x: fix_RF(x)) #HIGH ise 1000 yapıyorum #HIGH ise 1000 yapıyorum
    df_addition=df_join[["Element ID","Property ID","Subcase ID"]] #joining with some input cols
    df_out=pd.concat((df_addition,df_out),axis=1) #yep doing it here
    
    if start==rows: ws.range(f"B{start+1}:T{(rows+1)*2}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:T{rows*2}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt


def rf_fbending(wb,rows,df_join,df_misc_joint):
    start=10 if df_join.shape[0]!=0 else 12
    begin=time.time()
    ttb_sheet="Flange Bending - Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # rows = rows+start-1 if rows>=9 else start+1 #necessary tweak, rows makes the stop
    rows = rows+start-1
    
    ws.range(f"B{start+1}:AH20000").clear_contents() #clearing
    ws.range(f'B{start}:AH{start}').api.AutoFill(Destination=ws.range(f'B{start}:AH{rows}').api,Type=0) #filling
    
    df_misc_joint.dropna(subset="Diameter",inplace=True)
    df_join.rename(columns={"T":"T_flange"},inplace=True)
    df_misc_joint.rename(columns={"T":"T_web"},inplace=True)
    
    df_misc_joint=df_misc_joint[~df_misc_joint["MAT"].str.contains('m21|m91|quartz',regex=True,case=False,na=False)]
    df_misc_joint=df_misc_joint.loc[df_misc_joint.groupby("Property ID (PBARL)")["Diameter"].idxmax()]
    df_misc_joint=df_misc_joint[["Property ID (PBARL)", "Application","T_web","Pitch","Diameter"]]
    df_misc_joint.rename(columns={"Property ID (PBARL)":"Property ID"},inplace=True)
    df_join=pd.merge(df_join,df_misc_joint,on="Property ID",how="inner")
    
    df_join["Flange Type"]=None
    df_join["Number of Rows"]=None
    df_join["Flange Type"]=df_join["Application"].apply(lambda x: "Double Flange" if "multiple" in x.lower() else "Single Flange")
    df_join["Number of Rows"]=df_join["Application"].apply(lambda x: 2 if "multiple" in x.lower() else 1)
    df_join["Class"]=df_join["Class"].apply(lambda x: "B-Basis" if "b" in x.lower() else "A-Basis")
    R=4
    
    # writing specifics
    ws.range(f'B{start}').value=np.array(df_join["Flange Type"]).reshape(-1,1)
    # ws.range(f'C{start}').value=np.array(df_join["Number of Rows"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["Class"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["Diameter"]).reshape(-1,1)
    # ws.range(f'H{start}').value=np.array(df_join["Diameter"]+df_join["T_web"]/2+1+R).reshape(-1,1) #d+tweb/2+1+r
    
    WEB_LENGTH=20
    ws.range(f'G{start}').value=np.array(df_join["T_flange"]).reshape(-1,1)
    ws.range(f'H{start}').value=np.array(df_join["T_web"]).reshape(-1,1)
    ws.range(f'I{start}:I{rows}').value=WEB_LENGTH
    ws.range(f'J{start}:L{rows}').value=R
    
    #writing loads
    ws.range(f'K{start}').value=np.array(df_join["P - Web Radius"]*1.15/1.5).reshape(-1,1) #P
    ws.range(f'L{start}').value=np.array(df_join["P - Web Radius"]).reshape(-1,1) #P
    # ws.range(f'O{start}').value=np.array(df_join["Q - Web Radius"]*1.15/1.5).reshape(-1,1) #Q
    # ws.range(f'P{start}').value=np.array(df_join["Q - Web Radius"]).reshape(-1,1) #Q
    # ws.range(f'Q{start}').value=np.array(df_join["M - Web Radius"]*1.15/1.5).reshape(-1,1) #MWEB
    # ws.range(f'R{start}').value=np.array(df_join["M - Web Radius"]).reshape(-1,1) #MWEB
    ws.range(f'M{start}').value=np.array(df_join["M - Flange Level"]*1.15/1.5).reshape(-1,1) #MFLANGE
    ws.range(f'N{start}').value=np.array(df_join["M - Flange Level"]).reshape(-1,1) #MFLANGE
    ws.range(f'O{start}').value=np.array(df_join["Pitch"]).reshape(-1,1) #MFLANGE
    
    wb.app.calculate()
    end=time.time()
    
    columns=ws.range(f'B{start-1}:AH{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:AH{rows}').value),columns=columns)
    df_addition=df_join[["Element ID", "Property ID", "Subcase ID"]].reset_index(drop=True) #Element ID header avg'da yok
    df_out=pd.concat((df_addition,df_out),axis=1)
    
    df_out.columns=[f"{col}_{i}" if i>0 else col for col, i in \
                    zip(df_out.columns, [Counter(df_out.columns[:i]).get(col,0) for i, col in enumerate(df_out.columns)])]
    
    df_out.rename(columns={"RF":"RF_flange","RF_1":"RF_web","RF_2":"RF"},inplace=True)
    
    if start==rows:  ws.range(f"B{start+1}:AH{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:AH{rows}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt

# =============================================================================
# JOINT
# =============================================================================

def rf_joint_metal(wb,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    
    def mat_fix(df_join):
        df_join["MAT"]=df_join["MAT"].apply(lambda x: '2050-T84, 2050-T852, 7050-T7451' if x.startswith('2050') else x)
        df_join["MAT"]=df_join["MAT"].apply(lambda x: 'Ti-6Al-4V Plate/Forging' if x.startswith('Ti-6Al-4V') else x)
        df_join["MAT"]=df_join["MAT"].apply(lambda x: '2024-T42 Clad' if "clad" in x.lower() else x)
        df_join["MAT"]=df_join["MAT"].apply(lambda x: 'PH 13-8 Mo' if x.startswith('PH') else x)
        df_join["Side"]=df_join["Side"].apply(lambda x: 'Head Side' if x.startswith('H') else x)
        df_join["Side"]=df_join["Side"].apply(lambda x: 'Tail Side' if x.startswith('T') else x)
        return df_join
    
    if ml_choice.get()==1:
        print("MBJ - Using ML prediction.")
        ttb_sheet="MBJoint-ML"
        
        df_addition=df_join[["Element ID (PBARL)","Property ID (PBARL)","Subcase ID"]].reset_index(drop=True) #Element ID header avg'da yok
        df_addition.rename(columns={"Element ID (PBARL)":"Element ID", "Property ID (PBARL)":"Property ID"},inplace=True)
        df_join=mat_fix(df_join)
        df_join_default=df_join.copy()
        
        df_join.rename(columns={'F Bearing Z':'Tension Loading',
                                'MAT':'Plate Material','Shim':'Shim Thickness',
                                'Pin':'Pin Specification',
                                'Bar Thickness': 'Plate Thickness', 'Pitch': 'Fastener Pitch  ( xD)',
                                'Side':'Strength Calculation'}, inplace=True)
        
        df_join["Shear Loading"]=np.sqrt(df_join["F Bearing X"]**2+df_join["F Bearing Y"]**2)
        
        model_data=joblib.load(ml_path)
        model=model_data['mbj'][0]
        feature_names=model_data['mbj'][1]
            
        for col in feature_names:
            if col not in df_join.columns: 
                df_join[col]=np.nan
        
        categorical_features = df_join.select_dtypes(include=['object','category']).columns.tolist()
        for col in categorical_features:
            df_join[col]=df_join[col].astype('category')
        
        df_join=df_join[feature_names]
        
        prediction=model.predict(df_join) #prediction
        df_join["RF"]=prediction.reshape(-1,1)
        df_join["RF"]=df_join["RF"].abs()
        
        
        #--optimizasyon icin-------------------------------------------
        df_join['Collar Specification']=df_join_default['Collar']
        df_join['Edge Distance ( xD)']=2
        df_join['Fastener Installation']="Wet"
        df_join['DLS Ratio']=0
        df_join['Hole Fit']="Structural fit"
        
        try:
            df_join['Prying']=df_join_default["Prying"]
        except:
            df_join['Prying']="YES"
        
        #--------------------------------------------------------------
        
        df_out=df_join.copy()
        new_order=['Pin Specification',
               'Collar Specification', 'Diameter', 'Strength Calculation',
               'Plate Material', 'Plate Thickness', 'Edge Distance ( xD)',
               'Shim Thickness', 'Fastener Installation', 'Fastener Pitch  ( xD)',
               'Hole Fit', 'Application', 'Shear Loading', 'Tension Loading', 'Prying',
               'DLS Ratio','RF']
        try:
            df_out=df_out[new_order]
        except Exception as e:
            print(e)
            
        dt=time.time()-start
        df_out=pd.concat((df_addition,df_out),axis=1)
        
        return ttb_sheet,df_out,dt
    
    ttb_sheet="Metallic Bolted J.-Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # df_join=df_join[df_join["Element Type"]=="Cap"] #filtering
    df_join=df_join[df_join["Element Type"].str.contains('cap',regex=True,case=False,na=False)]
    df_join=df_join[~df_join["MAT"].str.contains('m21|m91|quartz',regex=True,case=False,na=False)]
    df_join=df_join[~df_join["Property ID"].astype("str").str[2].isin(['0'])] #fitting olmayanlar
    # df_join=df_join[(df_join["W"]>2) & (df_join["T"]>2)]
    df_join=df_join[df_join["W"]>2]
    
    rows=df_join.shape[0]
    
    rows = rows+start-1
    if rows<start: 
        print("WARNING: MBJ -> rows<start, check if your misc and inputs are matching.")
        rows=start+1
    
    ws.range(f"B{start+1}:AK20000").clear_contents() #clearing
    ws.range(f'B{start}:AK{start}').api.AutoFill(Destination=ws.range(f'B{start}:AK{rows}').api,Type=0) #filling
    
    #alternative mat
    df_join=mat_fix(df_join)
    
    # writing specifics
    ws.range(f'F{start}').value=np.array(df_join["MAT"]).reshape(-1,1) #malzeme isimleri değişiyor
    
    #join, joint sheetiyle oldugu için burada barlar yerine shellerin thickness var dolayısıyla load.csv den almam gerekiyor
    try:
        ws.range(f'G{start}').value=np.array(df_join["Bar Thickness"]).reshape(-1,1) 
    except Exception as e:
        print(f"ERROR {e} - can't find bar thicknesses")
    
    ws.range(f'B{start}').value=np.array(df_join["Pin"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["Collar"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["Side"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["Diameter"]).reshape(-1,1)
    
    ws.range(f'K{start}').value=np.array(df_join["Pitch"]).reshape(-1,1)
    ws.range(f'M{start}').value=np.array(df_join["Application"]).reshape(-1,1)
    
    try:
        ws.range(f'I{start}').value=np.array(df_join["Shim"]).reshape(-1,1)
    except:
        ws.range(f'I{start}').value=1.2
    
    try:        
        ws.range(f'P{start}').value=np.array(df_join["Prying"]).reshape(-1,1)
    except:
        ws.range(f'P{start}:P{rows}').value="YES"
                                    
    ws.range(f'H{start}:H{rows}').value=2
    ws.range(f'J{start}:J{rows}').value="Wet"
    ws.range(f'L{start}:L{rows}').value="Structural fit"
    ws.range(f'Q{start}:Q{rows}').value=0 #DLS ratio
                                                                    
    df_join["Shear"]=(df_join["F Bearing X"]**2+df_join["F Bearing Y"]**2)**0.5
    ws.range(f'N{start}').value=np.array(df_join["Shear"]).reshape(-1,1)
    ws.range(f'O{start}').value=np.array(df_join["F Bearing Z"]).reshape(-1,1)
    
    wb.app.calculate()
    end=time.time()
    
    #main output
    # columns=ws.range(f'B{start-1}:BL{start-1}').value
    columns=ws.range(f'B{start-1}:AK{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:AK{rows}').value),columns=columns)
    
    #THE TRICK-------------------------------
    all_contain_error=df_out["RF Combined"].astype(str).str.contains('ERROR', case=False, na=False).all()
    if all_contain_error:
        print("WARNING - all joints gave ERROR label as result, trying again.")
        ws.range(f'D{start}:D{rows}').value=6.35
        wb.app.calculate()
        ws.range(f'D{start}').value=np.array(df_join["Diameter"]).reshape(-1,1)
        wb.app.calculate()
        
        columns=ws.range(f'B{start-1}:BM{start-1}').value
        df_out=pd.DataFrame((ws.range(f'B{start}:BM{rows}').value),columns=columns)
    #THE TRICK-------------------------------  
    
    if start==rows:  ws.range(f"B{start+1}:AK{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:AK{rows}").clear_contents() #clearing
    
    df_addition=df_join[["Element ID (PBARL)", "Property ID (PBARL)", "Subcase ID"]].reset_index(drop=True) #Element ID header avg'da yok
    df_addition.rename(columns={"Element ID (PBARL)":"Element ID", "Property ID (PBARL)":"Property ID"},inplace=True)
    df_out=pd.concat((df_addition,df_out),axis=1)
    dt=end-begin
    ttb_sheet="MBJoint"
    
    return ttb_sheet,df_out,dt


def rf_joint_composite(wb,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    
    if ml_choice.get()==1:
        print("CBJ - Using ML prediction.")
        ttb_sheet="CBJoint-ML"
        df_join["Application"]=df_join["Application"].apply(lambda x: 2 if "single" in x.lower() else 1.3)
        df_addition=df_join[["Element ID (PBARL)", "Property ID (PBARL)", "Property ID","Subcase ID"]].reset_index(drop=True) #Element ID header avg'da yok
        
        df_join_default=df_join.copy()
        df_join.rename(columns={'F Bearing X':'Fx\n(N)','F Bearing Y':'Fy\n(N)','F Bearing Z':'Bolt pull through load',
                                'NX':'nx\n(N/mm)','NY':'ny\n(N/mm)','NXY':'nxy\n(N/mm)','Mx':'mx\n(Nmm/mm)','My':'my\n(Nmm/mm)','Mxy':'mxy\n(Nmm/mm)',
                                'MAT':'Material','n1':'n1\n(ply1)','n2':'n2\n(ply2)','n3':'n3\n(ply3)','n4':'n4\n(ply4)',
                                'Shim':'tshim\n(mm)','Temperature (C)':'Temperature (°C)','Pin':'Pin Specification','Collar':'Collar Specification',
                                'Diameter':'Diameter (mm)','Application':'Stress concen-tration factor for pull-through loading'}, inplace=True)
        
        model_data=joblib.load(ml_path)
        
        model=model_data['cbj'][0]
        feature_names=model_data['cbj'][1]
        
        for col in feature_names:
            if col not in df_join.columns: 
                df_join[col]=np.nan
        
        categorical_features = df_join.select_dtypes(include=['object','category']).columns.tolist()
        for col in categorical_features:
            df_join[col]=df_join[col].astype('category')
        
        df_join=df_join[feature_names]
        prediction=model.predict(df_join) #prediction
        df_join["RF"]=prediction.reshape(-1,1)
        df_join["RF"]=df_join["RF"].abs()
        
        #--optimizasyon icin-------------------------------------------
        df_join['ply angle1\n(°)']=0
        df_join['ply angle2\n(°)']=45
        df_join['ply angle3\n(°)']=-45
        df_join['ply angle4\n(°)']=90
        df_join['aoff\n(°)']=df_join_default['aoff (deg)']
        df_join['Environment']="HW"
        df_join['Collar Specification']=df_join_default['Collar']
        df_join['head or tail side']="HEAD"
        df_join['wx\n(mm)']=df_join_default["Pitch"]*df_join_default["Diameter"]
        df_join['wy\n(mm)']=df_join_default["Pitch"]*df_join_default["Diameter"]
        df_join['ex\n(mm)']=2*df_join_default["Diameter"]+1
        df_join['ey\n(mm)']=2*df_join_default["Diameter"]+1
        df_join['tshim\n(mm)']=df_join_default["Shim"]
        df_join['Type of shear loading']="SLS Supported"
        df_join['Stress concen-tration factor for pull-through loading']=1.3
        
        try:
            df_join['Prying?']=df_join_default["Prying"]
        except:
            df_join['Prying?']="YES"
            
        df_join['DLS Ratio']=0
        df_join['t (mm)']=df_join_default['T']
        
        new_order=['Material', 'n1\n(ply1)', 'n2\n(ply2)',
               'n3\n(ply3)', 'n4\n(ply4)', 'ply angle1\n(°)', 'ply angle2\n(°)',
               'ply angle3\n(°)', 'ply angle4\n(°)', 'aoff\n(°)', 'Temperature (°C)',
               'Environment', 'Pin Specification', 'Collar Specification',
               'Diameter (mm)', 'head or tail side', 'wx\n(mm)', 'wy\n(mm)',
               'ex\n(mm)', 'ey\n(mm)', 'tshim\n(mm)', 'nx\n(N/mm)', 'ny\n(N/mm)',
               'nxy\n(N/mm)', 'mx\n(Nmm/mm)', 'my\n(Nmm/mm)', 'mxy\n(Nmm/mm)',
               'Fx\n(N)', 'Fy\n(N)', 'Type of shear loading', 'Bolt pull through load',
               'Stress concen-tration factor for pull-through loading', 'Prying?',
               'DLS Ratio','t (mm)','RF']
        #--------------------------------------------------------------
        
        df_out=df_join.copy()
        try:
            df_out=df_out[new_order]
        except Exception as e:
            print(e)
            
        # df_out.rename(columns={"T" : "t (mm)"}, inplace=True)
        dt=time.time()-start
        df_out=pd.concat((df_addition,df_out),axis=1)
        
        return ttb_sheet,df_out,dt
    
    ttb_sheet="Composite Bolted J.-Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # df_join=df_join[df_join["Element Type"]=="Skin"] #filtering
    # df_join=df_join[df_join["Element Type"]=="Skin"].reset_index(drop=True,inplace=False)
    #composite capler icin bir yama
    if df_join[df_join["Element Type"].str.contains('skin',regex=True,case=False,na=False)].shape[0]!=0:
        df_join=df_join[df_join["Element Type"].str.contains('skin',regex=True,case=False,na=False)]
        
    df_join=df_join[df_join["MAT"].str.contains('m21|m91|quartz',regex=True,case=False,na=False)]
    df_join=df_join[df_join["W"]>2]
    # df_join=df_join[~df_join["Property ID"].astype("str").str[2].isin(['0'])] #fitting olmayanlar
    
    rows=df_join.shape[0]
    rows = rows+start-1
    if rows<start: 
        print("WARNING: CBJ -> rows<start, check if your misc and inputs are matching.")
        rows=start+1
    
    # try: ws.api.Unprotect(Password="TAT2530TFX")
    # except: ws.api.Unprotect(Password="UBU2530UGY")
    
    ws.range(f'B{start+1}:BM2000').clear_contents() #clearing
    ws.range(f'B{start}:BM{start}').api.AutoFill(Destination=ws.range(f'B{start}:BM{rows}').api,Type=0) #filling
    # writing specifics
    # ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    
    ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'K{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    try:
        df_join["Temperature (C)"].fillna(100,inplace=True)
        ws.range(f'L{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
    except Exception as e:
        print(f"{e} - 'Temperature (C)' column does not exist")
    
    ws.range(f'N{start}').value=np.array(df_join["Pin"]).reshape(-1,1)
    ws.range(f'O{start}').value=np.array(df_join["Collar"]).reshape(-1,1)
    ws.range(f'Q{start}').value=np.array(df_join["Side"]).reshape(-1,1)
    ws.range(f'M{start}:M{rows}').value="HW"
    
    #forcing stuff
    for i in ["AJ","AK","AL","AM","AN","AO","AP"]:
        ws.range(f'{i}{start}:{i}{rows}').value="y"
    
    ws.range(f'P{start}').value=np.array(df_join["Diameter"]).reshape(-1,1)
    ws.range(f'R{start}').value=np.array(df_join["Pitch"]*df_join["Diameter"]).reshape(-1,1)
    ws.range(f'S{start}').value=np.array(df_join["Pitch"]*df_join["Diameter"]).reshape(-1,1)
    ws.range(f'U{start}').value=np.array(2.5*df_join["Diameter"]).reshape(-1,1)
    ws.range(f'T{start}').value=np.array(2.5*df_join["Diameter"]).reshape(-1,1)
    
    try:        
        ws.range(f'AH{start}').value=np.array(df_join["Prying"]).reshape(-1,1)
    except:
        ws.range(f'AH{start}:AH{rows}').value="YES"
    
    ws.range(f'AE{start}:AE{rows}').value="SLS Supported"
    # ws.range(f'AG{start}:AG{rows}').value=1.3
    # df_join["Number of Rows"]=df_join["Number of Rows"].apply(lambda x: 2 if int(x)<2 else 1.3)
    # ws.range(f'AG{start}').value=np.array(df_join["Number of Rows"]).reshape(-1,1)
    df_join["Application"]=df_join["Application"].apply(lambda x: 2 if "single" in x.lower() else 1.3)
    ws.range(f'AG{start}').value=np.array(df_join["Application"]).reshape(-1,1)
    
    try:
        ws.range(f'V{start}').value=np.array(df_join["Shim"]).reshape(-1,1)
    except:
        ws.range(f'V{start}').value=1.2
    
    #writing loads
    ws.range(f'W{start}').value=np.array(df_join["Nx Bypass"]).reshape(-1,1)
    ws.range(f'X{start}').value=np.array(df_join["Ny Bypass"]).reshape(-1,1)
    ws.range(f'Y{start}').value=np.array(df_join["Nxy Bypass"]).reshape(-1,1)
    ws.range(f'AC{start}').value=np.array(df_join["F Bearing X"]).reshape(-1,1)
    ws.range(f'AD{start}').value=np.array(df_join["F Bearing Y"]).reshape(-1,1)
    ws.range(f'AF{start}').value=np.array(df_join["F Bearing Z"]).reshape(-1,1)
    
    try:
        ws.range(f'Z{start}').value=np.array(df_join["Mx"]).reshape(-1,1)
        ws.range(f'AA{start}').value=np.array(df_join["My"]).reshape(-1,1)
        ws.range(f'AB{start}').value=np.array(df_join["Mxy"]).reshape(-1,1)
    except Exception as e:
        print(f"WARNING - Moments are missing, using 0 instead.")
        ws.range(f'Z{start}:Z{rows}').value=0
        ws.range(f'AA{start}:AA{rows}').value=0
        ws.range(f'AB{start}:AB{rows}').value=0
    
    ws.range(f'AI{start}:AI{rows}').value=0 #DLS ratio
    wb.app.calculate()
    #main output
    columns=ws.range(f'B{start-1}:BM{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:BM{rows}').value),columns=columns)
    
    #THE TRICK-------------------------------
    all_contain_error=df_out["Failure Mode"].astype(str).str.contains('ERROR', case=False, na=False).all()
    if all_contain_error:
        print("WARNING - all joints gave ERROR label as result, trying again.")
        ws.range(f'P{start}:P{rows}').value=6.35
        wb.app.calculate()
        ws.range(f'P{start}').value=np.array(df_join["Diameter"]).reshape(-1,1)
        wb.app.calculate()
        
        columns=ws.range(f'B{start-1}:BM{start-1}').value
        df_out=pd.DataFrame((ws.range(f'B{start}:BM{rows}').value),columns=columns)
    #THE TRICK-------------------------------    
    
    if start==rows:  ws.range(f"B{start+1}:BM{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:BM{rows}").clear_contents() #clearing
    
    df_addition=df_join[["Element ID (PBARL)", "Property ID (PBARL)", "Property ID","Subcase ID"]].reset_index(drop=True) #Element ID header avg'da yok
    df_out=pd.concat((df_addition,df_out),axis=1)
    # ws.api.Protect(Password="UBU2530UGY")
    end=time.time()
    dt=end-begin
    ttb_sheet="CBJoint"
    
    return ttb_sheet,df_out,dt


def rf_joint_composite_cap(wb,df_join,df_join_general):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    
    ttb_sheet="Composite Bolted J.-Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # df_join=df_join[df_join["Element Type"]=="Cap"] #filtering
    df_join=df_join[df_join["Element Type"].str.contains('cap',regex=True,case=False,na=False)]
    df_join=df_join[df_join["MAT"].str.contains('m21|m91|quartz',regex=True,case=False,na=False)]
    # df_join=df_join[~df_join["Type"].str.contains('pshell',regex=True,case=False,na=False)] #sadece barları alıyorum
    df_join.drop_duplicates(subset="F Bearing X",inplace=True)#sadece barları alıyorum
    # df_join=df_join.loc[df_join.groupby("Element ID (PBARL)")["Diameter"].idxmax()]
    df_join=df_join[df_join["W"]>2]
    df_join.drop(["T","W","n1","n2","n3","n4"],inplace=True,axis=1)
    
    df_join_general.rename(columns={"Property ID":"Property ID (PBARL)"},inplace=True)
    df_join_general=df_join_general[["Property ID (PBARL)","T","W","n1","n2","n3","n4"]]
    df_join=pd.merge(df_join,df_join_general,on="Property ID (PBARL)",how="inner")
    
    rows=df_join.shape[0]
    rows = rows+start-1
    if rows<start: 
        print("WARNING: CBJ -> rows<start, check if your misc and inputs are matching.")
        rows=start+1
    
    # try: ws.api.Unprotect(Password="TAT2530TFX")
    # except: ws.api.Unprotect(Password="UBU2530UGY")
    
    ws.range(f'B{start+1}:BM2000').clear_contents() #clearing
    ws.range(f'B{start}:BM{start}').api.AutoFill(Destination=ws.range(f'B{start}:BM{rows}').api,Type=0) #filling
    # writing specifics
    
    ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'K{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    try:
        df_join["Temperature (C)"].fillna(100,inplace=True)
        ws.range(f'L{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
    except Exception as e:
        print(f"{e} - 'Temperature (C)' column does not exist")
    
    ws.range(f'N{start}').value=np.array(df_join["Pin"]).reshape(-1,1)
    ws.range(f'O{start}').value=np.array(df_join["Collar"]).reshape(-1,1)
    ws.range(f'Q{start}').value=np.array(df_join["Side"]).reshape(-1,1)
    ws.range(f'M{start}:M{rows}').value="HW"
    
    #forcing stuff
    for i in ["AJ","AK","AL","AM","AN","AO","AP"]:
        ws.range(f'{i}{start}:{i}{rows}').value="y"
    
    ws.range(f'P{start}').value=np.array(df_join["Diameter"]).reshape(-1,1)
    ws.range(f'R{start}').value=np.array(df_join["Pitch"]*df_join["Diameter"]).reshape(-1,1)
    ws.range(f'S{start}').value=np.array(df_join["Pitch"]*df_join["Diameter"]).reshape(-1,1)
    ws.range(f'U{start}').value=np.array(2.5*df_join["Diameter"]).reshape(-1,1)
    ws.range(f'T{start}').value=np.array(2.5*df_join["Diameter"]).reshape(-1,1)
    
    try:
        ws.range(f'AH{start}').value=np.array(df_join["Prying"]).reshape(-1,1)
    except:
        ws.range(f'AH{start}').value="YES"
        
    ws.range(f'AE{start}:AE{rows}').value="SLS Supported"
    # ws.range(f'AG{start}:AG{rows}').value=1.3
    # df_join["Number of Rows"]=df_join["Number of Rows"].apply(lambda x: 2 if int(x)<2 else 1.3)
    # ws.range(f'AG{start}').value=np.array(df_join["Number of Rows"]).reshape(-1,1)
    df_join["Application"]=df_join["Application"].apply(lambda x: 2 if "single" in x.lower() else 1.3)
    ws.range(f'AG{start}').value=np.array(df_join["Application"]).reshape(-1,1)
    ws.range(f'V{start}').value=np.array(df_join["Shim"]).reshape(-1,1)
    
    #writing loads
    ws.range(f'W{start}').value=np.array(df_join["Nx Bypass"]).reshape(-1,1)
    ws.range(f'X{start}').value=np.array(df_join["Ny Bypass"]).reshape(-1,1)
    ws.range(f'Y{start}').value=np.array(df_join["Nxy Bypass"]).reshape(-1,1)
    ws.range(f'AC{start}').value=np.array(df_join["F Bearing X"]).reshape(-1,1)
    ws.range(f'AD{start}').value=np.array(df_join["F Bearing Y"]).reshape(-1,1)
    ws.range(f'AF{start}').value=np.array(df_join["F Bearing Z"]).reshape(-1,1)
    
    try:
        ws.range(f'Z{start}').value=np.array(df_join["Mx"]).reshape(-1,1)
        ws.range(f'AA{start}').value=np.array(df_join["My"]).reshape(-1,1)
        ws.range(f'AB{start}').value=np.array(df_join["Mxy"]).reshape(-1,1)
    except Exception as e:
        print(f"WARNING - Moments are missing, using 0 instead.")
        ws.range(f'Z{start}:Z{rows}').value=0
        ws.range(f'AA{start}:AA{rows}').value=0
        ws.range(f'AB{start}:AB{rows}').value=0
    
    ws.range(f'AI{start}:AI{rows}').value=0 #DLS ratio
    wb.app.calculate()
    #main output
    columns=ws.range(f'B{start-1}:BM{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:BM{rows}').value),columns=columns)
    
    #THE TRICK-------------------------------
    all_contain_error=df_out["Failure Mode"].astype(str).str.contains('ERROR', case=False, na=False).all()
    if all_contain_error:
        print("WARNING - all joints gave ERROR label as result, trying again.")
        ws.range(f'P{start}:P{rows}').value=6.35
        wb.app.calculate()
        ws.range(f'P{start}').value=np.array(df_join["Diameter"]).reshape(-1,1)
        wb.app.calculate()
        
        columns=ws.range(f'B{start-1}:BM{start-1}').value
        df_out=pd.DataFrame((ws.range(f'B{start}:BM{rows}').value),columns=columns)
    #THE TRICK-------------------------------    
    
    if start==rows:  ws.range(f"B{start+1}:BM{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:BM{rows}").clear_contents() #clearing
    
    df_addition=df_join[["Element ID (PBARL)", "Property ID (PBARL)","Subcase ID"]].reset_index(drop=True) #Element ID header avg'da yok
    df_out=pd.concat((df_addition,df_out),axis=1)
    df_out.rename(columns={"Element ID (PBARL)":"Element ID","Property ID (PBARL)":"Property ID"},inplace=True)
    # ws.api.Protect(Password="UBU2530UGY")
    end=time.time()
    dt=end-begin
    ttb_sheet="CBJoint(BARZ)"
    
    return ttb_sheet,df_out,dt


def rf_ir_buckling(wb,rows,df_join,df_misc_joint):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    """
    ELS 320 -> 1.5
    ELS 420 -> 3.0
    HST 645 -> 4.0
    HST 646 -> 2.0
    BG 2082 -> 1.0
    
    NAS1151E-1158E -> 1.0 #automatin tab
    """
    
    ttb_sheet="Interrivet Buckling-Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    # def change_pin(x):
    #     if x=="ELS320": return 1.5/1
    #     elif x=="ELS420": return 3.0/1
    #     elif x=="ELS645": return 4.0/1
    #     elif x=="ELS646": return 2.0/1
    #     elif x=="BG2082": return 1.0/1
    #     else: 1.0/2.0
    
    file_name=os.path.basename(path_entry9.get())
    
    """
    MISC_joint içinde bir pshell in birden fazla pbarı komşu olabiliyor dolayısıyla n diyelim
    load kısmından da aynı pshell için n adet load geliyor
    df_merged bu nedenle nxn oluyor halbuki n sayısında kalmaı dolayısıyla nx1 arıyorum
    yani MISC_jointten sadece bir satır gelmeli onun için bazı manipülasyonlar yapıyorum
    pbar id ile filtreleyip daha sonra max diameter alıyorum
    
    """
    df_misc_joint.dropna(subset="Diameter",inplace=True)
    
    if "rib" in file_name.lower():
        print("(INFO) IR Buckling -> Rib aligned loads are given.")
        df_misc_joint=df_misc_joint[df_misc_joint["Property ID (PBARL)"].astype("str").str[2].isin(['3','0'])]
        # df_misc_joint.drop_duplicates(subset="Property ID", keep="first",inplace=True)
        df_misc_joint=df_misc_joint.loc[df_misc_joint.groupby("Property ID")["Diameter"].idxmax()]
        df_joint=df_misc_joint[["Property ID", "Property ID (PBARL)", "Pin", "Diameter", "Pitch"]]
        # df_join=pd.merge(df_join,df_joint,on="Property ID",how="left")
        df_join=pd.merge(df_join,df_joint,on="Property ID",how="inner")
        ttb_sheet="IR Buckling-RibAligned"
        
    elif "spar" in file_name.lower():
        print("(INFO) IR Buckling -> Spar aligned loads are given.")
        df_misc_joint=df_misc_joint[df_misc_joint["Property ID (PBARL)"].astype("str").str[2].isin(['4','0'])]
        # df_misc_joint.drop_duplicates(subset="Property ID", keep="first",inplace=True)
        df_misc_joint=df_misc_joint.loc[df_misc_joint.groupby("Property ID")["Diameter"].idxmax()]
        df_joint=df_misc_joint[["Property ID", "Property ID (PBARL)", "Pin", "Diameter", "Pitch"]]
        # df_join=pd.merge(df_join,df_joint,on="Property ID",how="left")
        df_join=pd.merge(df_join,df_joint,on="Property ID",how="inner")
        ttb_sheet="IR Buckling-SparAligned"
        
    else:
        print("(INFO) IR Buckling -> There is no indication of spar/rib for load file, so taking randomly.")
        # df_misc_joint.drop_duplicates(subset="Property ID", keep="first", inplace=True)
        df_misc_joint=df_misc_joint.loc[df_misc_joint.groupby("Property ID")["Diameter"].idxmax()]
        df_joint=df_misc_joint[["Property ID", "Property ID (PBARL)", "Pin", "Diameter", "Pitch"]]
        # df_join=pd.merge(df_join,df_joint,on="Property ID",how="left")
        df_join=pd.merge(df_join,df_joint,on="Property ID",how="inner")
        ttb_sheet="IR Buckling-NoneAligned"
    
    #burasi önemli, önce row sayarsa örneğin 1920 sayıyor ama yukarıda 1910'a iniyor, 
    #dolayısıyla 1920'ye göre autofill yapıyordu ve 10 tanesi öyle kalıyordu, şimdi ok
    rows=df_join.shape[0]
    rows = rows+start-1
    
    if start==rows: ws.range(f"B{start+1}:T{(rows+1)*2}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:T{rows*2}").clear_contents() #clearing
    
    ws.range(f'B{start}:T{start}').api.AutoFill(Destination=ws.range(f'B{start}:T{rows}').api,Type=0) #filling
    
    # df_join["Pin"].loc[df_join["Pin"]=="BG2082"]="NAS1151E-1158E"
    # df_join["factor"] = df_join["Pin"].apply(lambda x: change_pin(x)) #Cir faktörü için düzeltmeye gidiyorum
    # df_join["Pin"]="NAS1151E-1158E"
    # df_join["Pin"]=df_join["Pin"].apply(lambda x: x if x in ["ELS320","ELS420","HST645","HST646"])
    ws.range(f'B{start}').value=np.array(df_join["Pin"]).reshape(-1,1)
    
    df_join["MAT"]=df_join["MAT"].apply(lambda x: "Quartz/8552 8HS 285 g/m^2" if x=="Quartz/8552 8HS 285 g" else x) #quartz naming fix
    
    ws.range(f'C{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'G{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'L{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    ws.range(f'M{start}').value=np.array(df_join["Pitch"]*df_join["Diameter"]).reshape(-1,1)
    ws.range(f'N{start}:N{rows}').value="Head side"
    
    ws.range(f'O{start}').value=np.array(df_join["Nx"]).reshape(-1,1)
    
    wb.app.calculate()
    end=time.time()
    #main output
    columns=ws.range(f'B{start-1}:T{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:T{rows}').value),columns=columns)
    
    def fix_RF(x):
        try:
            if "HIGH" in x: return 1000
            else: return x
        except:
            return x
        
    df_out["RF"]=df_out["RF"].apply(lambda x: fix_RF(x)) #HIGH ise 1000 yapıyorum #HIGH ise 1000 yapıyorum
    df_addition=df_join[["Element ID","Property ID","Subcase ID"]] #joining with some input cols
    df_out=pd.concat((df_addition,df_out),axis=1) #yep doing it here
        
    # df_out["Cir, buckling coefficient"]=factor #writing my applied factor for observation
    # df_out["Nx bypass default"]=nx_default #similar thing for nx bypass as well, before I convert them to negative numbers
    # df_out["RF"].astype("float32",inplace=True)
    # df_out["RF"]=df_out["RF"].apply(lambda x: 0 if isinstance(x,str) else x)
    
    # df_out["RF"]=df_out["RF"]*df_join["factor"] #applying factor for finale RF
    # df_out["factor"]=df_join["factor"]
    
    if start==rows: ws.range(f"B{start+1}:T{(rows+1)*2}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:T{rows*2}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt


def rf_ir_buckling_old(wb,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    """
    ELS 320 -> 1.5
    ELS 420 -> 3.0
    HST 645 -> 4.0
    HST 646 -> 2.0
    BG 2082 -> 1.0
    
    NAS1151E-1158E -> 1.0 #automatin tab
    """
    begin=time.time()
    ttb_sheet="Interrivet Buckling-Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    df_join=df_join[df_join["Element Type"]=="Skin"].reset_index(drop=True,inplace=False) #filtering
    rows=df_join.shape[0]
    rows = rows+start-1
    
    ws.range(f'B{start+1}:T200').clear_contents() #clearing
    ws.range(f'B{start}:T{start}').api.AutoFill(Destination=ws.range(f'B{start}:T{rows}').api,Type=0) #filling
    
    def change_pin(x):
        if x=="ELS320": return 1.5/1
        elif x=="ELS420": return 3.0/1
        elif x=="ELS645": return 4.0/1
        elif x=="ELS646": return 2.0/1
        elif x=="BG2082": return 1.0/1
        else: 1.0/2.0
    
    # df_join["Pin"].loc[df_join["Pin"]=="BG2082"]="NAS1151E-1158E"
    df_join["factor"] = df_join["Pin"].apply(lambda x: change_pin(x)) #Cir faktörü için düzeltmeye gidiyorum
    factor=df_join["factor"].copy()
    df_join["Pin"]="NAS1151E-1158E"
    ws.range(f'B{start}').value=np.array(df_join["Pin"]).reshape(-1,1)
    
    ws.range(f'C{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'G{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'L{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    ws.range(f'M{start}').value=np.array(df_join["Pitch"]*df_join["Diameter"]).reshape(-1,1)
    ws.range(f'N{start}:N{rows}').value="Head side"
    
    nx_default=df_join["Nx Bypass"].copy()
    df_join["Nx Bypass"]=df_join["Nx Bypass"].apply(lambda x: (-1*float(x)) if float(x)>0 else x) #negatif yapiyorum
    ws.range(f'O{start}').value=np.array(df_join["Nx Bypass"]).reshape(-1,1)
    
    wb.app.calculate()
    end=time.time()
    #main output
    columns=ws.range(f'B{start-1}:T{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:T{rows}').value),columns=columns)
    
    # df_out["Cir, buckling coefficient"]=factor #writing my applied factor for observation
    # df_out["Nx bypass default"]=nx_default #similar thing for nx bypass as well, before I convert them to negative numbers
    # df_out["RF"].astype("float32",inplace=True)
    # df_out["RF"]=df_out["RF"].apply(lambda x: 0 if isinstance(x,str) else x)
    df_out["RF"]=df_out["RF"]*df_join["factor"] #applying factor for finale RF
    df_out["factor"]=df_join["factor"]
    
    if start==rows:  ws.range(f"B{start+1}:T{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:T{rows}").clear_contents() #clearing
    
    dt=end-begin
    return ttb_sheet,df_out,dt


def rf_repair_composite_old(wb,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    ttb_sheet="Composite Repair J.-Automation"
    ws=wb.sheets("Composite Bolted J.-Automation")
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    df_join=df_join[df_join["Element Type"]=="Skin"] #filtering
    rows=df_join.shape[0]
    rows = rows+start-1
    
    ws.range(f'B{start+1}:BL200').clear_contents() #clearing
    ws.range(f'B{start}:BL{start}').api.AutoFill(Destination=ws.range(f'B{start}:BL{rows}').api,Type=0) #filling
    # writing specifics
    # ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    #bar proplarından mat çekiyorum dolayısıyla metal geliyor, başka
    #bir çözüm düşünene kadar default M91 atıyorum.
    
    ws.range(f'B{start}:B{rows}').value="IM7/M91 194 g/m^2"
    ws.range(f'C{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'K{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    ws.range(f'L{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
    ws.range(f'M{start}:M{rows}').value="HW"
    
    ws.range(f'N{start}:N{rows}').value="HST 756"
    ws.range(f'O{start}:O{rows}').value="HST1094"
    ws.range(f'Q{start}:Q{rows}').value="HEAD"
    ws.range(f'P{start}:P{rows}').value=6.35
    
    #the trick-------------------------
    ll=df_join["Diameter"].copy()
    df_join["Diameter"]=7.92
    ws.range(f'P{start}').value=np.array(df_join["Diameter"]).reshape(-1,1)
    
    df_join["Diameter"]=ll
    ws.range(f'P{start}').value=np.array(df_join["Diameter"]).reshape(-1,1)
    #----------------------------------
    
    ws.range(f'R{start}:R{rows}').value=6*6.35
    ws.range(f'S{start}:S{rows}').value=6*6.35
    ws.range(f'U{start}:U{rows}').value=6*6.35
    ws.range(f'T{start}:T{rows}').value=6*6.35
    
    if ws.range("AH8")=="Prying": ws.range(f'AH{start}').value=np.array(df_join["Prying"]).reshape(-1,1)
    
    ws.range(f'AE{start}:AE{rows}').value="SLS Supported"
    ws.range(f'AG{start}:AG{rows}').value=1.3
    ws.range(f'V{start}:V{rows}').value=2
    
    #writing loads
    ws.range(f'W{start}').value=np.array(df_join["Nx Bypass"]).reshape(-1,1)
    ws.range(f'X{start}').value=np.array(df_join["Ny Bypass"]).reshape(-1,1)
    ws.range(f'Y{start}').value=np.array(df_join["Nxy Bypass"]).reshape(-1,1)
    ws.range(f'AC{start}:AC{rows}').value=0
    ws.range(f'AD{start}:AD{rows}').value=0
    ws.range(f'AF{start}:AF{rows}').value=0
    
    wb.app.calculate()
    end=time.time()
    
    #main output
    columns=ws.range(f'B{start-1}:BL{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:BL{rows}').value),columns=columns)
    
    if start==rows:  ws.range(f"B{start+1}:BL{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:BL{rows}").clear_contents() #clearing
    
    dt=end-begin
    return "Repair-CBJ",df_out,dt


def rf_repair_composite(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time()
    ttb_sheet="Composite Bolted J.-Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    rows=df_join.shape[0] #jit
    rows = rows+start-1
    
    ws.range(f'B{start+1}:BM200').clear_contents() #clearing
    
    ws.range(f'AJ{start}:BM{start}').api.AutoFill(Destination=ws.range(f'AJ{start}:BM{rows}').api,Type=0) #filling
    ws.range(f'G{start}:K{start}').api.AutoFill(Destination=ws.range(f'G{start}:K{rows}').api,Type=0) #filling
    
    # ws.range(f'B{start}:BM{start}').api.AutoFill(Destination=ws.range(f'B{start}:BM{rows}').api,Type=0) #filling
    ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
    ws.range(f'C{start}').value=np.array(df_join["n1"]).reshape(-1,1)
    ws.range(f'D{start}').value=np.array(df_join["n2"]).reshape(-1,1)
    ws.range(f'E{start}').value=np.array(df_join["n3"]).reshape(-1,1)
    ws.range(f'F{start}').value=np.array(df_join["n4"]).reshape(-1,1)
    ws.range(f'K{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
    
    #df_join["Temperature (C)"].fillna(100,inplace=True)
    ws.range(f'L{start}').value=np.array(df_join["Temperature (C)"]).reshape(-1,1)
    ws.range(f'M{start}:M{rows}').value="HW"
    
    ws.range(f'N{start}:N{rows}').value="HST 756"
    ws.range(f'O{start}:O{rows}').value="HST1094"
    ws.range(f'Q{start}:Q{rows}').value="HEAD"
    ws.range(f'P{start}:P{rows}').value=6.35
    ws.range(f'R{start}:R{rows}').value=6*6.35
    ws.range(f'S{start}:S{rows}').value=6*6.35
    ws.range(f'U{start}:U{rows}').value=6*6.35
    ws.range(f'T{start}:T{rows}').value=6*6.35
    # ws.range(f'AH{start}').value=np.array(df_join["Prying"]).reshape(-1,1)
    ws.range(f'AH{start}:AH{rows}').value="NO"
    ws.range(f'AE{start}:AE{rows}').value="SLS Supported"
    ws.range(f'AG{start}:AG{rows}').value=1.3
    ws.range(f'V{start}:V{rows}').value=2
    
    #writing loads
    ws.range(f'W{start}').value=np.array(df_join["Nx Average"]).reshape(-1,1)
    ws.range(f'X{start}').value=np.array(df_join["Ny Average"]).reshape(-1,1)
    ws.range(f'Y{start}').value=np.array(df_join["Nxy Average"]).reshape(-1,1)
    
    #momentler
    ws.range(f'Z{start}:Z{rows}').value=0
    ws.range(f'AA{start}:AA{rows}').value=0
    ws.range(f'AB{start}:AB{rows}').value=0
    #forces
    ws.range(f'AC{start}:AC{rows}').value=0
    ws.range(f'AD{start}:AD{rows}').value=0
    ws.range(f'AF{start}:AF{rows}').value=0
    ws.range(f'AI{start}:AI{rows}').value=0 #DLS ratio
    
    #the trick-------------------------
    ws.range(f'P{start}:P{rows}').value=7.92
    
    ws.range(f'P{start}:P{rows}').value=6.35
    #----------------------------------
    
    wb.app.calculate()
    end=time.time()
    
    #main output
    columns=ws.range(f'B{start-1}:BM{start-1}').value
    df_out=pd.DataFrame((ws.range(f'B{start}:BM{rows}').value),columns=columns).reset_index(drop=True)
    
    if start==rows:  ws.range(f"B{start+1}:BM{rows+1}").clear_contents() #clearing
    else: ws.range(f"B{start+1}:BM{rows}").clear_contents() #clearing
    dt=end-begin
    ttb_sheet="CBJoint-Repair"
    
    return ttb_sheet,df_out,dt


# =============================================================================
# OTHERS
# =============================================================================

def rf_pflutter(wb,rows,df_join):
    start=9 if df_join.shape[0]!=0 else 11
    begin=time.time() 
    if ml_choice.get()==1:
        ttb_sheet="Panel Flutter - AI"
        models=joblib.load(ml_path)
        
        #some preprocessing
        #df_join["Temperature (C)"].fillna(100,inplace=True)
        inputs=["Nx","Ny","Nxy","Mx","My","Mxy","n1","n2","n3","n4","Temperature (C)"]
        addition=["T"]
        
        #prediction
        df_out=df_join[addition+inputs]
        df_out.rename(columns={"T" : "t (mm)"}, inplace=True)
        df_out["RF"]=models["T-Residual"].predict(np.array(df_join[inputs]))
        dt=time.time()-start
        
        return ttb_sheet,df_out,dt
    
    ttb_sheet="Panel Flutter-Automation"
    ws=wb.sheets(ttb_sheet)
    
    result_label.config(text=f"({count}/{check_vars}) {ttb_sheet.replace(' ','').split('-')[0]}")
    root.update_idletasks()
    
    conditions={"Mach":[1.27,1.38,1.61,1.84,2.07],
                "Pressure":[113.5,116.7,117,115.1,115.3]}
    
    df_join.drop_duplicates("Property ID",inplace=True)
    if df_join.shape[0]==1: df_join=pd.concat([df_join,df_join]) #burada 1 row var ise ikiliyorum, yoksa algoritmaya uygun degil
    unique_property_number=df_join.shape[0]
    # rows=rows+start-1 #necessary tweak, rows makes the stop
    # rows = rows+start-1 if rows>=9 else start+1 #intentionally left this one, flutter has a weird behaviour
    ll=[]
    
    for m,q in zip(conditions["Mach"],conditions["Pressure"]):
        ws.range(f"B{start+1}:AE{start+unique_property_number}").clear_contents() #clearing
        ws.range(f'B{start}:AE{start}').api.AutoFill(Destination=ws.range(f'B{start}:AE{start+unique_property_number}').api,Type=0) #filling
        
        # writing specifics
        ws.range(f'B{start}').value=np.array(df_join["MAT"]).reshape(-1,1)
        ws.range(f'C{start}').value=np.array(df_join["n1"]).reshape(-1,1)
        ws.range(f'D{start}').value=np.array(df_join["n2"]).reshape(-1,1)
        ws.range(f'E{start}').value=np.array(df_join["n3"]).reshape(-1,1)
        ws.range(f'F{start}').value=np.array(df_join["n4"]).reshape(-1,1)
        ws.range(f'K{start}').value=np.array(df_join["aoff (deg)"]).reshape(-1,1)
        
        #writing loads
        ws.range(f'L{start}:L{rows}').value=m
        ws.range(f'M{start}:M{rows}').value=q
        
        ws.range(f'O{start}').value=np.array(df_join["Panel Length X"]).reshape(-1,1)
        ws.range(f'N{start}').value=np.array(df_join["Panel Length Y"]).reshape(-1,1)
        
        ws.range(f'P{start}:P{rows}').value=angle_value
        ws.range(f'Q{start}:Q{rows}').value=0.66
        
        df_join["Y Boundary (Ritz)"]=df_join["Y Boundary (Ritz)"].apply(lambda x: "Clamped" if x=="CC" else "Simply Supported")
        ws.range(f'R{start}').value=np.array(df_join["Y Boundary (Ritz)"]).reshape(-1,1)
        ws.range(f'S{start}:S{rows}').value="Flat Panel"
        ws.range(f'T{start}:T{rows}').value=0
        
        wb.app.calculate()
        
        #I HAVE TO DO THIS TO AVOID NON-FLOAT VALUES IN RF EVENTHOUGH THE INPUTS ARE CORRECT
        if isinstance(ws.range("U9").value,float):
            pass
        else:
            ws.range(f'Q{start}:Q{rows}').value=1.0
            # wb.app.calculation = 'automatic' #toggle on
            wb.app.calculate()
            time.sleep(1)
            ws.range(f'Q{start}:Q{rows}').value=0.66
            # wb.app.calculation = 'manual' #toggle off
            wb.app.calculate()
        #--------------------------------------------------------------------------------
        
        
        #some extras for this one
        columns=ws.range(f'B{start-1}:AE{start-1}').value
        df_out=pd.DataFrame((ws.range(f'B{start}:AE{rows}').value),columns=columns)
        df_addition=df_join[["Property ID"]].reset_index().drop("index",axis=1)
        df_out=pd.concat((df_addition,df_out),axis=1)
        
        df_out["Subcase ID"]=f'{m}M-{q}P'
        ll.append(df_out)
        
    df_out=pd.concat(ll)
    end=time.time()
    dt=end-begin
    
    #move column
    col="Subcase ID"
    cols=df_out.columns.to_list()
    cols.insert(2,cols.pop(cols.index(col)))
    df_out=df_out[cols]
    
    df_out.drop_duplicates(subset=["Property ID","Mach Number"],inplace=True) # daha önce concat ile arttırdıgım yeri atıyorum
    df_out.rename(columns={'Thickness (mm)':'t (mm)'}, inplace=True) # summary icin gerekli
    
    df_out.reset_index(drop=True,inplace=True)
    ws.range(f"B{start+1}:AE{100000}").clear_contents() #clearing
    return ttb_sheet,df_out,dt


# =============================================================================
# RESULT SUMMARY
# =============================================================================

"""
OLD ONE--------

def get_summary():
    messagebox.showwarning("Warning","Please make sure that your TTB excels are closed. Otherwise it may cause an error.")
    gen_button.config(text="...", font="Colossal 8 bold",fg="black")
    root.update_idletasks()
    
    try: 
        os.chdir(sum_file.get())
    except: 
        gen_button.config(text="ERROR", font="Colossal 8 bold",fg="red")
        return 1
    
    def get_rfnt(df):
        min_rf_data=[]
        for pid in df["Property ID"].unique():
            
            if "Subcase ID" not in df.columns:
                df["Subcase ID"]=None
                
            pid_df=df[df["Property ID"]==pid]
            min_rf_row=pid_df.loc[pid_df["RF"].idxmin()]
            max_rf_row=pid_df.loc[pid_df["RF"].idxmax()]
            min_rf_data.append({
                "Property ID": pid,
                "RF min": min_rf_row["RF"],
                "t (mm)": max_rf_row["t (mm)"],
                "LCID": min_rf_row["Subcase ID"]
                })
        
        return min_rf_data

    def find_tmin(pid):
        #string geliyor t kolonuna, onu hallediyor
        combined_df["t min"]=combined_df["t min"].apply(lambda x: None if isinstance(x,str) else x) 
        min_rf_value=pivot_df.loc[pid,"RF min"]
        min_t=combined_df[(combined_df["Property ID"]==pid) & (combined_df["RF min"]==min_rf_value)]["t min"].min()
        lcid=combined_df[(combined_df["Property ID"]==pid) & (combined_df["RF min"]==min_rf_value) & (combined_df["t min"]==min_t)]["LCID"].min()
        return min_t, lcid

    files=[f for f in os.listdir() if ((f.endswith(".xlsx")) and ("TTB" in f) and ("summary" not in f))]
    
    all_pid_data=[]
    for file in files:
        print(file)
        try:
            df=pd.read_excel(file)
            df.fillna("NaN",inplace=True)
            ### some excel file column names are irregular ###
            df.rename(columns={'RF Combined':'RF'},inplace=True)
            df.rename(columns={'Plate Thickness':'t (mm)'},inplace=True)
            df.rename(columns={'t1 (mm)':'t (mm)'},inplace=True)
            df.rename(columns={'Total Thickness (mm)':'t (mm)'},inplace=True)
            df.rename(columns={'T':'t (mm)'},inplace=True)
            
            min_rf_df=pd.DataFrame(get_rfnt(df))
            min_rf_df["file"]=file.split("-")[0][4:].rstrip(".xlsx")
            all_pid_data.append(min_rf_df)
            
        except Exception as e:
            print(e)
            gen_button.config(text="ERROR", font="Colossal 8 bold",fg="red")
            return 1
        
    combined_df=pd.concat(all_pid_data)
    
    pivot_df=combined_df.pivot_table(index="Property ID", columns="file", values="RF min", aggfunc="first")
    pivot_df["RF min"]=pivot_df.min(axis=1)
    pivot_df["t min"] = pivot_df.index.to_series().apply(lambda x: find_tmin(x)[0])
    pivot_df["LCID"] = pivot_df.index.to_series().apply(lambda x: find_tmin(x)[1])
    
    pivot_df.insert(0,"LCID",pivot_df.pop("LCID")) #LCID kolonu yerini degistiriyorum

    final_summary=pivot_df.reset_index()
    final_summary.fillna("n/a",inplace=True) #bos yerleri dolduruyorum
    try:
        final_summary.to_excel("TTB_summary.xlsx",index=False)
    except:
       gen_button.config(text="ERROR", font="Colossal 8 bold", fg="red") 
    
    gen_button.config(text="Generate", font="Colossal 8 bold", fg="green")
"""

def get_summary():
    messagebox.showwarning("Warning","Please make sure that your TTB excels are closed. Otherwise it may cause an error.")
    # gen_button.config(text="...", font="Colossal 8 bold",fg="black")
    root.update_idletasks()

    def bdf_parser(bdf_path):
        filename=os.path.basename(bdf_path)
        upd_filename=filename.replace(".","_TTB.")
        write_path=bdf_path.replace(filename,upd_filename)
        try:
            os.remove(write_path)
        except:
            pass
        filew=open(write_path,"w")
        listemiz=["CORD2R","GRID","CQUAD4","CTRIA3","CBAR","PBARL","PSHELL","MAT1","MAT2","MAT8","MAT9"]
                     
        with open(bdf_path,"r") as main:
            for line in main.readlines():
                if line.startswith("INCLUDE"):
                    path_fragment = line.split("'")[1].strip()  # Extract file path from directive
                    full_bdf_path = os.path.join(os.path.dirname(bdf_path), path_fragment)  
                    f_name = os.path.basename(full_bdf_path)
                    with open(full_bdf_path,"r") as fin:
                        if "MAT" in f_name:
                            filew.write(fin.read())  # Copy MAT content as is
                        
                        else:
                            for line in fin.readlines():
                                filew.write(line)
                else:
                    filew.write(line)

        filew.close()
        return write_path
            
    try:
        bdf_path=bdf_parser(bdf_file.get())
        bdf=read_bdf(bdf_path, xref=True, punch=True, debug=False, encoding='latin1')
        os.remove(bdf_path)
        try:
            mass=bdf.get_mass_breakdown()
        except Exception as e:
            print(e)
            print("WARNING: 'mass' data is not found")
            mass=None
            
    except Exception as e:
        print(e)
        print("WARNING: 'mass' data is not found")
        mass=None
        pass
        
    #########################################################################################################
    
    
    def change_column_names(df):
        rename_dict={'RF Combined':'RF', 'Plate Thickness':'t (mm)', 'Flange Thickness (tf) (mm):': 't (mm)',
                     't1 (mm)':'t (mm)', 'Total Thickness (mm)':'t (mm)', 'T':'t (mm)'}
        
        df.rename(columns={k: v for k,v in rename_dict.items() if k in df.columns},inplace=True)
        return df
        
    try: 
        os.chdir(sum_file.get())
    except: 
        gen_button.config(text="ERROR", font="Colossal 8 bold",fg="red")
        return 1
    
    main_data=[]
    opt_data=[]
    
    files=[f for f in os.listdir() if ((f.endswith(".xlsx")) and ("TTB" in f) and ("summary" not in f))]
    
    
    for file in files:
        # file=os.path.normpath(os.path.abspath(file))
        file=os.path.basename(file)
        # file_name=file.rstrip(".xlsx")[4:]
        file_name=file.strip("TTB_").rstrip(".xlsx")
        # file_name=file.strip("TTB_").strip("$").rstrip(".xlsx")
        
        try:
            df_main=pd.read_excel(file,sheet_name="RF min")
            df_main=change_column_names(df_main)
            
            if all(col in df_main.columns for col in ["Property ID","t (mm)","Subcase ID","RF"]):
                df_main["File"]=file_name
                main_data.append(df_main[["Property ID","t (mm)","Subcase ID","RF","File"]])
            else:
                # print(f"File {file_name}: missing required columns in 'RF min' sheet")
                print(f"WARNING: 'RF min' sheet in {file_name} not found.")
                print("One of the following columns might be missing: 'Property ID','t (mm)','Subcase ID','RF'")
                
        except Exception as e:
            print(f"WARNING: reading 'RF min' sheet in {file_name}: {e}")
            
            
        try:
            df_opt=pd.read_excel(file,sheet_name="RF min sized")
            df_opt["Subcase ID"]=df_opt["Property ID"].map(df_main.set_index("Property ID")["Subcase ID"])
            df_opt.rename(columns={"thickness":"t (mm)","Plate Thickness":"t (mm)",'RF Combined':'RF'},inplace=True)
            
            if all(col in df_opt.columns for col in ["Property ID","t (mm)"]):
                df_opt["File"]=file_name
                opt_data.append(df_opt[["Property ID","t (mm)","RF","File","Subcase ID"]])
            else:
                print(f"File {file_name}: missing required columns in 'RF min sized'")
                
        except Exception as e:
            print(f"WARNING: 'RF min sized' sheet in {file_name} not found")
                
    if not main_data:
        print("No valid data found to process")
        return 1
    
    combined_df=pd.concat(main_data,ignore_index=True)
    
    opt_lookup={}
    if opt_data:
        opt_df=pd.concat(opt_data,ignore_index=True)
        for _,row in opt_df.iterrows():
            if row["Property ID"] not in opt_lookup:
                opt_lookup[row["Property ID"]]={}
            opt_lookup[row["Property ID"]][row["File"]]=[row["t (mm)"],row["RF"],row["Subcase ID"]]
    
    pivot_df=combined_df.pivot_table(
        values="RF",
        index="Property ID",
        columns="File",
        aggfunc="first"
    ).reset_index()
    
    min_rf_data={}
    for prop_id,group in combined_df.groupby("Property ID"):
        group["RF"]=pd.to_numeric(group["RF"],errors="coerce")
        min_idx=group["RF"].idxmin()
        min_row=group.loc[min_idx]
        min_rf_data[prop_id]={
            "RF min": min_row["RF"],
            "Subcase ID": min_row["Subcase ID"],
            "t (mm)": min_row["t (mm)"],
            "File": min_row["File"]}
    pivot_df["Subcase ID"]=pivot_df["Property ID"].map(lambda x: min_rf_data[x]["Subcase ID"])
    pivot_df["RF min"]=pivot_df["Property ID"].map(lambda x: min_rf_data[x]["RF min"])
    pivot_df["t (mm) default"]=pivot_df["Property ID"].map(lambda x: min_rf_data[x]["t (mm)"])
    pivot_df["Default Failure"]=pivot_df["Property ID"].map(lambda x: min_rf_data[x]["File"])
    pivot_df["RF min sized"]=None
    pivot_df["t (mm) optimized"]=None
    pivot_df["Optimized Failure"]=None
    pivot_df["Optimized LCID"]=None
    
    
    """
    if opt_lookup: #-> ID : {'Failure:'thickness'}
        # pivot_df["t (mm) optimized"]=pivot_df["Property ID"].apply(lambda x: opt_lookup.get(x, {}).get(min_rf_data[x]["File"],None))
        for i,row in enumerate(pivot_df["Property ID"]):
            try: 
                pivot_df["t (mm) optimized"][i]=max(opt_lookup[row].values())
                pivot_df["Optimized Failure"][i]=max(opt_lookup[row],key=opt_lookup[row].get)
            except: 
                pivot_df["t (mm) optimized"][i]=None
                pivot_df["Optimized Failure"][i]=None
        # pivot_df["t (mm) optimized"]=pivot_df["Property ID"].apply(lambda x: (max(opt_lookup[x].values()),None))
    else:
        pivot_df["t (mm) optimized"]=None
    """
    
    def to_number(val,case):
        try: 
            return float(val)
        except:
            if case=="t":return float("-inf")
            elif case=="rf": return float("inf")
    
    if opt_lookup: #-> ID : {'Failure:'thickness'}
        # pivot_df["t (mm) optimized"]=pivot_df["Property ID"].apply(lambda x: opt_lookup.get(x, {}).get(min_rf_data[x]["File"],None))
        for i,row in enumerate(pivot_df["Property ID"]):
            try:
                best_k, best_v = max(opt_lookup[row].items(),key=lambda item: (to_number(item[1][0],"t"),-to_number(item[1][1],"rf")))
                pivot_df["t (mm) optimized"][i]=to_number(best_v[0],"t")
                pivot_df["RF min sized"][i]=to_number(best_v[1],"rf")
                pivot_df["Optimized Failure"][i]=best_k
                pivot_df["Optimized LCID"][i]=best_v[2]
            except: 
                pivot_df["t (mm) optimized"][i]=None
                pivot_df["RF min sized"][i]=None
                pivot_df["Optimized Failure"][i]=None
                pivot_df["Optimized LCID"][i]=None
        # pivot_df["t (mm) optimized"]=pivot_df["Property ID"].apply(lambda x: (max(opt_lookup[x].values()),None))
    else:
        pivot_df["t (mm) optimized"]=None
        pivot_df["RF min sized"]=None
        pivot_df["Optimized Failure"]=None
        pivot_df["Optimized LCID"]=None
        
        
    # for (i,(top_key, sub_dict)) in enumerate(opt_lookup.items()): # top_key: property id -> sub dict('t','RF') ->looking for max t, min RF
    #     best_k, best_v = max(sub_dict.items(),key=lambda item: (to_number(item[1][0],"t"),-to_number(item[1][1],"rf"))) # ->best_k is the failure, best_v is the list of those two
        
    #     filtered_df=pivot_df[pivot_df["Property ID"]==top_key]
    #     filtered_df["Property ID"]=to_number(best_v[0],"t")
    #     # pivot_df["t (mm) optimized"][i]=to_number(best_v[0],"t")
    #     filtered_df["Optimized Failure"]=best_k
    #     # pivot_df["Optimized Failure"][i]=best_k
    
    rf_cols=[col for col in pivot_df.columns if col not in ["Property ID","Subcase ID","RF min","RF min sized","t (mm) default","t (mm) optimized","Default Failure","Optimized Failure","Optimized LCID"]]
    final_cols=["Property ID", "Subcase ID","Optimized LCID"] + rf_cols + ["RF min","RF min sized","t (mm) default","t (mm) optimized","Default Failure", "Optimized Failure"]
    result_df=pivot_df[final_cols]
    if mass!=None:
        result_df["mass (kg) default"]=None
        result_df["mass (kg) optimized"]=None
        
        for i,row in result_df.iterrows():
            prop=int(result_df["Property ID"][i])
            if bdf.properties[prop].type in ["PCOMP","PSHELL","PBARL"]:
                # Initialize variables
                result_df["mass (kg) default"][i]=mass[0][prop]
                try:
                    f=result_df["t (mm) optimized"][i]/result_df["t (mm) default"][i]
                    result_df["mass (kg) optimized"][i]=mass[0][prop]*f
                except:
                    result_df["mass (kg) optimized"][i]="n/a"
                
            else:
                result_df["mass (kg) default"][i]="n/a"
                result_df["mass (kg) optimized"][i]="n/a"
        
    result_df.fillna("n/a",inplace=True) #bos yerleri dolduruyorum
    result_df.rename(columns={"Subcase ID":"LCID"},inplace=True)
    symmetry_df=make_symmetry_summary(result_df)
    
    try:
        with pd.ExcelWriter("TTB_summary.xlsx") as writer:
            result_df.to_excel(writer,sheet_name="Summary",index=False)
            
            try:
                symmetry_df.to_excel(writer,sheet_name="Symmetry",index=False)
            except:
                print("WARNING: 'Symmetry' sheet won't be generated, due to no optimization result.")
            
    except Exception as e:
        print(f"ERROR while doing the summary: {e}")
        gen_button.config(text="ERROR", font="Colossal 8 bold", fg="red") 
        return 
    
    gen_button.config(text="Generate", font="Colossal 8 bold", fg="green")
    messagebox.showinfo("Summary","The summary file has been made successfully !")
    
    return 0


def make_symmetry_summary(df):
    df["Property ID"]=df["Property ID"].astype("int32")
    id_set=sorted(set(df["Property ID"]))
    result_rows=[]
    
    if not df["t (mm) optimized"].isnull().all():
        target_col="t (mm) optimized"
    else:
        return 0
    
    for lhs in df["Property ID"]:
        rhs = lhs+ 10000000
        if rhs in id_set:
            row1=df[df["Property ID"] == lhs].copy()
            row2=df[df["Property ID"] == rhs].copy()
            
            if row1[target_col].iloc[0]>=row2[target_col].iloc[0]:
                winner_row=row1.copy()
                loser_row=row2.copy()
                winner_pid=row1["Property ID"].iloc[0]
                winner_str="LHS"
            else:
                winner_row=row2.copy()
                loser_row=row1.copy()
                winner_pid=row2["Property ID"].iloc[0]
                winner_str="RHS"
                
            for col in loser_row.columns:
                if col.lower() in ["t (mm) optimized", "mass (kg) optimized"]:
                    loser_row[f"{col} - final"]=winner_row[col].values[0]
                    winner_row[f"{col} - final"]=winner_row[col].values[0]
            
            winner_row["Sized by"] = winner_pid
            loser_row["Sized by"] = winner_pid
            winner_row["Sided by"] = winner_str
            loser_row["Sided by"] = winner_str
            
            result_rows.append(winner_row)
            result_rows.append(loser_row)
    
    try:
        new_df=pd.concat(result_rows).reset_index(drop=True)
        return new_df
    
    except Exception as e:
        print(e)
        return 0
        
    
def plot_summary():
    excel_path = plot_file.get()
    bdf_path=bdf_file.get()
    result=splot(bdf_path,excel_path)
    plot_button.config(text="S-Plot", font="Colossal 8 bold", fg="green") if result==0 else plot_button.config(text="ERROR", font="Colossal 8 bold", fg="red")
    if result==0:
        messagebox.showinfo("Summary Plot","Success ! The summary plot has been made.")
    

def plot_fastener():
    excel_path = misc_file.get()
    bdf_path=bdf_file2.get()
    result=fplot(bdf_path,excel_path)
    plot_button2.config(text="F-Plot", font="Colossal 8 bold", fg="green") if result==0 else plot_button2.config(text="ERROR", font="Colossal 8 bold", fg="red")
    if result==0:
        messagebox.showinfo("fastener Plot","Success ! The fastener plot has been made.")
    
    
# =============================================================================
# SIZING
# =============================================================================
# NEED TO WORK ON THIS ONE !
def size_t(df, rf_calc, step=0.1, tmin=1.5, tmax=15, tolerance=0.2):
    t_values=df["t (min)"].values
    rf_values=rf_calc()
    
    while np.any(np.abs(rf_values - 1) >= tolerance):
        mask=np.abs(rf_values - 1)>tolerance
        t_values[mask]+=np.sign(1-rf_values[mask])*step
        rf_values=rf_calc(t_values)
        
    df["t (min)"]=t_values
    return df
        

# =============================================================================
# MAIN STUFF
# =============================================================================

def main():
    user_answer=messagebox.askquestion("Final check", "Are you sure about your choices (in the tool) ?")
    if user_answer=="no":
        return None
    
    # user_answer=messagebox.askquestion("Close your toolbox","It is highly recommended to close your toolbox and let T4TOBIN re-open it to avoid some weird toolbox errors.\n\nWould you like to do that first ?")
    # if user_answer=="yes":
    #     return None
    
    # if user_answer=="no":
    #     messagebox.showwarning("Close your toolbox !","It is highly advisable to close your toolbox and let TATOBIN open it to avoid some weird toolbox errors by re-opening it.")
    #     return None
    
    start=time.time()
    write_log(sheet_name="",dt="",state=0)
    
    #reading stuff
    run_button.config(state=tk.DISABLED)
    result_label.config(text="reading files...", fg="gray", font=("Colossal 9"))
    progress_bar['value']=1
    root.update_idletasks()
    
    #LOAD K
    global ml_path,ttb_path, tatobin_path
    try:
        base_path=sys._MEIPASS
    except Exception as e:
        print(e)
        base_path=os.path.abspath(r'\\vds\alldept3\Analiz_T5200\T52G0\T24505\icons')
    
    ml_path=os.path.join(base_path,"K.joblib")
    
    # try:
    #     ml_path=r'C:/Users/t24505/Desktop/isler/inwork/09_tool_work/01_toolbox_interface_plus/guncel/source/dist/K.joblib'
    # except Exception as e:
    #     print(e)
    
    #main files
    ttb_path, misc_path, tatobin_path = path_entry1.get(), path_entry2.get(), os.getcwd()
    # os.chdir(os.path.dirname(ttb_path))
    os.chdir(tatobin_path)
    
    try:
        df_misc=pd.read_excel(misc_path,sheet_name="GENERAL")
        df_misc_joint=pd.read_excel(misc_path,sheet_name="JOINT")
        if ml_choice.get()==0: #if ML option is off, look for toolbox
            # app=xw.App(visible=False)
            ttb_wb=xw.Book(ttb_path)
            result_label.config(text="starting toolbox in the back...", fg="gray", font=("Colossal 9"))
            # ttb_wb=app.books.open(ttb_path)
        else:
            ttb_wb=None
            pass
        
    except Exception as e:
        print(e)
        result_label.config(text="ERROR due to constant files.", fg="red" , font=("Colossal 9"))
        run_button.config(state=tk.NORMAL)
        return 1
    
    # ttb_wb.calculation = 'automatic' #toggle on
    # ttb_wb.calculation = 'manual' #toggle off
    
    try:
        ttb_wb.app.api.Calculation=xw.constants.Calculation.xlCalculationAutomatic
        ttb_wb.app.api.Calculation=xw.constants.Calculation.xlCalculationManual
        ttb_wb.app.screen_updating=False
        ttb_wb.app.display_alerts=False
        ttb_wb.app.enable_events=False
    except:
        pass
    
    dfm_shell_avg=get_load_df(path_entry3.get(),df_misc)
    dfm_shell_all=get_load_df(path_entry4.get(),df_misc)
    dfm_bar_avg=get_load_df(path_entry5.get(),df_misc)
    dfm_bar_all=get_load_df(path_entry6.get(),df_misc)
    dfm_joint=get_load_df(path_entry7.get(),df_misc_joint)
    
    dfc_shell_avg=get_load_df(path_entry8.get(),df_misc)
    dfc_shell_all=get_load_df(path_entry9.get(),df_misc)
    dfc_bar_avg=get_load_df(path_entry10.get(),df_misc)
    dfc_bar_all=get_load_df(path_entry11.get(),df_misc)
    dfc_joint=get_load_df(path_entry12.get(),df_misc_joint)
    
    result_label.config(text="processing...", fg="gray", font=("Colossal 9"))
    progress_bar['value']=2
    root.update_idletasks()
    
    #some checks
    for i in [dfm_shell_all,dfm_bar_all,dfc_shell_all,dfc_bar_all]:
        if ('Element ID' not in i.columns) and (len(i.columns)!=0):
            result_label.config(text="ERROR wrong load file.", fg="red" , font=("Colossal 9")), run_button.config(state=tk.NORMAL), run_button.config(state=tk.NORMAL)
            return 1
    
    
    #counting checkbuttons for progress bar --------
    global check_vars,count
    check_vars,count=0,1
    
    for i in range(1,50):
        try:
            if eval(f"m{i}.get()"): check_vars+=1
        except:
            pass
        
        try:
            if eval(f"c{i}.get()"): check_vars+=1
        except:
            pass
    
    if check_vars==0: check_vars=1 #irbuckling icin
    #-----------------------------------------------
    
    #COMPOSITES
    if c1.get():#unnotched
        rows=dfc_shell_all.shape[0] #just for the output, taking headers
        try: sheet_name,df_out,dt=rf_unnotched(ttb_wb,rows,dfc_shell_all) #goes to calc
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL), run_button.config(state=tk.NORMAL)
        
        df_addition=dfc_shell_all[["Element ID","Property ID","Subcase ID"]] #joining with some input cols
        df_out_final=pd.concat((df_addition,df_out),axis=1) #yep doing it here
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c2.get():#cai
        rows=dfc_shell_avg.shape[0] #just for the output, taking headers
        try: sheet_name,df_out,dt=rf_cai(ttb_wb,rows,dfc_shell_avg) #goes to calc
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfc_shell_avg[["Property ID","Subcase ID"]] #joining with some input cols
        df_out_final=pd.concat((df_addition,df_out),axis=1) #yep doing it here
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c3.get():#buckling
        rows=dfc_shell_avg.shape[0]
        try: sheet_name,df_out,dt=rf_buckling(ttb_wb,rows,dfc_shell_avg,"composite")
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfc_shell_avg[["Property ID","Subcase ID"]] #joining with some input cols
        df_out_final=pd.concat((df_addition,df_out),axis=1) #yep doing it here
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c4.get():#ei
        rows=dfc_shell_avg.shape[0]
        try: sheet_name,df_out,dt=rf_ei(ttb_wb,rows,dfc_shell_avg)
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfc_shell_avg[["Property ID","Subcase ID"]] #Element ID header avg'da yok
        df_out_final=pd.concat((df_addition,df_out),axis=1)
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c5.get():#pflutter
        rows=dfc_shell_avg.shape[0]
        try: sheet_name,df_out,dt=rf_pflutter(ttb_wb,rows,dfc_shell_avg.copy()) #taking copy, otherwise mess up the data for later use, remember flutter + repairability
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_out_final=df_out.copy() # df_out_final argumentini kullanmak icin burasi dummy sekilde lazim, 
                            # concat gerek yok prop id icin zaten df_out icinde geliyor bu failureda
        
        write_stuff(sheet_name,df_out,df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
    
    if c6.get():#ritz
        rows=dfc_shell_avg.shape[0]
        try: sheet_name,df_out,dt=rf_buckling_ritz(ttb_wb,rows,dfc_shell_avg,"composite")
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfc_shell_avg[["Property ID","Subcase ID"]] #joining with some input cols
        df_out_final=pd.concat((df_addition,df_out),axis=1)
        
        write_stuff(sheet_name,df_out,df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c7.get():#ils
        rows=dfc_shell_all.shape[0]
        try: sheet_name,df_out,dt=rf_ils(ttb_wb,rows,dfc_shell_all)
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_out.reset_index(drop=True,inplace=True) #tekrarlayan indexler vardı böyle yapmak zorunda kaldım
        df_out_final=df_out
        
        write_stuff(sheet_name,df_out,df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
    
    if c8.get():#sandwich
        rows=dfc_shell_all.shape[0]
        try: 
            sheet_name,df_out,dt=rf_sandwich(ttb_wb,rows,dfc_shell_all,dfc_shell_avg)
        except Exception as e: 
            result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
            print(f"ERROR - due to failure tabs. {e}")
            
        df_out.reset_index(drop=True,inplace=True) #tekrarlayan indexler vardı böyle yapmak zorunda kaldım
        df_out_final=df_out
        
        write_stuff(sheet_name,df_out,df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c9.get():#local buckling
        rows=dfc_bar_avg.shape[0]
        try: sheet_name,df_out,dt=rf_local_buckling(ttb_wb,rows,dfc_bar_avg,df_misc_joint, "composite")
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_out.reset_index(drop=True,inplace=True) #tekrarlayan indexler vardı böyle yapmak zorunda kaldım
        df_out_final=df_out
        
        write_stuff(sheet_name,df_out,df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c14.get():#crippling        
        rows=dfc_bar_all.shape[0]
        try: sheet_name,df_out,dt=rf_crippling_composite(ttb_wb,rows,dfc_bar_all)
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfc_bar_all[["Element ID","Property ID","Subcase ID","T"]] #Element ID header avg'da yok
        df_addition.rename(columns={"T":"t (mm)"},inplace=True)
        df_out_final=pd.concat((df_addition,df_out),axis=1)
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c16.get():#ils bar
        rows=dfc_shell_all.shape[0]
        try: sheet_name,df_out,dt=rf_ils_bars(ttb_wb,rows,dfc_bar_all)
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_out.reset_index(drop=True,inplace=True) #tekrarlayan indexler vardı böyle yapmak zorunda kaldım
        df_out_final=df_out
        
        write_stuff(sheet_name,df_out,df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
    
    if c11.get():
        rows=dfc_bar_all.shape[0] #just for the output, taking headers
        try: sheet_name,df_out,dt=rf_ir_buckling_composite(ttb_wb,rows,dfc_bar_all,df_misc_joint) #goes to calc
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL), run_button.config(state=tk.NORMAL)
        
        df_out_final=df_out #made the trick inside the function
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
      
    if c12.get():
        rows=dfc_bar_avg.shape[0]
        try: sheet_name,df_out,dt=rf_ei_bars(ttb_wb,rows,dfc_bar_avg)
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfc_bar_avg[["Property ID","Subcase ID"]] #Element ID header avg'da yok
        df_out_final=pd.concat((df_addition,df_out),axis=1)
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c10.get(): #unfolding
      rows=dfc_bar_all.shape[0]
      try: sheet_name,df_out,dt=rf_unfolding(ttb_wb,rows,dfc_bar_all)
      except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
      
      df_addition=dfc_bar_all[["Element ID","Property ID","Subcase ID","Fastener Diameter (mm)","T"]] #Element ID header avg'da yok
      df_addition.rename(columns={"T":"t (mm)"},inplace=True)
      df_out_final=pd.concat((df_addition,df_out),axis=1)
      
      write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
      write_log(sheet_name,dt,state=1)
      
      count+=1
      progress_bar['value']=100*(count-1)/check_vars
     
    
    if c33.get(): #openhole
      rows=dfc_shell_avg.shape[0]
      try: sheet_name,df_out,dt=rf_openhole(ttb_wb,rows,dfc_shell_avg)
      except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
      
      df_addition=dfc_shell_avg[["Property ID","Subcase ID"]] #joining with some input cols
      df_out_final=pd.concat((df_addition,df_out),axis=1)
      
      write_stuff(sheet_name,df_out,df_out_final,dt) #making the output
      write_log(sheet_name,dt,state=1)
      
      count+=1
      progress_bar['value']=100*(count-1)/check_vars
        
    #JOINT
    if c20.get(): #joint
        try: sheet_name,df_out,dt=rf_joint_composite(ttb_wb,dfc_joint)
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_out_final=df_out #made the trick inside the function
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
    
    if c19.get(): #joint, caps, BARS
        try: sheet_name,df_out,dt=rf_joint_composite_cap(ttb_wb,dfc_joint,df_misc)
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_out_final=df_out #made the trick inside the function
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c21.get(): #repairability
        # OLD STUFF USING JOINT LOADS
        # try: sheet_name,df_out,dt=rf_repair_composite(ttb_wb,dfc_joint)
        # except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        # dfc_joint=dfc_joint[dfc_joint["Element Type"]=="Skin"]
        # df_addition=dfc_joint[["Bar Element ID", "Property ID","Subcase ID"]].reset_index(drop=True) #Element ID header avg'da yok
        # df_out_final=pd.concat((df_addition,df_out),axis=1)
        
        # write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        # write_log(sheet_name,dt,state=1)
        
        # NEW ONE, AVERAGE LOAD
        rows=dfc_shell_avg.shape[0] #just for the output, taking headers
        try: sheet_name,df_out,dt=rf_repair_composite(ttb_wb,rows,dfc_shell_avg) #goes to calc
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfc_shell_avg[["Property ID","Subcase ID"]] #joining with some input cols
        df_out_final=pd.concat((df_addition,df_out),axis=1) #yep doing it here
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c22.get():#ir_buckling
        try: sheet_name,df_out,dt=rf_ir_buckling_old(ttb_wb,dfc_joint)
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        dfc_joint=dfc_joint[dfc_joint["Element Type"]=="Skin"]
        df_addition=dfc_joint[["Bar Element ID", "Property ID","Subcase ID"]].reset_index(drop=True) #Element ID header avg'da yok
        df_out_final=pd.concat((df_addition,df_out),axis=1)
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)

        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if c23.get():
        rows=dfc_shell_all.shape[0] #just for the output, taking headers
        try: sheet_name,df_out,dt=rf_ir_buckling(ttb_wb,rows,dfc_shell_all,df_misc_joint) #goes to calc
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL), run_button.config(state=tk.NORMAL)
        
        df_out_final=df_out #did the trick inside rf function
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    #METALS
    if m1.get():#strength
        rows=dfm_shell_avg.shape[0] #just for the output, taking headers
        try: sheet_name,df_out,dt=rf_strength(ttb_wb,rows,dfm_shell_avg) #goes to calc
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        # df_addition=dfm_shell_all[["Element ID","Property ID","Subcase ID"]] #joining with some input cols
        df_addition=dfm_shell_avg[["Property ID","Subcase ID"]] #joining with some input cols
        df_out_final=pd.concat((df_addition,df_out),axis=1) #yep doing it here
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if m2.get():#durability
        rows=dfm_shell_avg.shape[0] #just for the output, taking headers
        try: sheet_name,df_out,dt=rf_durability(ttb_wb,rows,dfm_shell_avg) #goes to calc
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfm_shell_avg[["Property ID","Subcase ID"]] #joining with some input cols
        df_out_final=pd.concat((df_addition,df_out),axis=1) #yep doing it here
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if m3.get():#buckling
        rows=dfm_shell_avg.shape[0]
        try: sheet_name,df_out,dt=rf_buckling(ttb_wb,rows,dfm_shell_avg,"metal")
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfm_shell_avg[["Property ID","Subcase ID"]] #Element ID header avg'da yok
        df_out_final=pd.concat((df_addition,df_out),axis=1)
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
    
    if m4.get():#ritz
        rows=dfm_shell_avg.shape[0]
        try: sheet_name,df_out,dt=rf_buckling_ritz(ttb_wb,rows,dfm_shell_avg,"metal")
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfm_shell_avg[["Property ID","Subcase ID"]] #joining with some input cols
        df_out_final=pd.concat((df_addition,df_out),axis=1)
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
    
    if m7.get():#local buckling
        rows=dfm_bar_avg.shape[0]
        try: sheet_name,df_out,dt=rf_local_buckling(ttb_wb,rows,dfm_bar_avg,df_misc_joint,"metal")
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_out.reset_index(drop=True,inplace=True) #tekrarlayan indexler vardı böyle yapmak zorunda kaldım
        df_out_final=df_out
            
        write_stuff(sheet_name,df_out,df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if m8.get():#bar_strength
        rows=dfm_bar_avg.shape[0] #just for the output, taking headers
        try: sheet_name,df_out,dt=rf_bar_strength(ttb_wb,rows,dfm_bar_avg) #goes to calc
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        # df_addition=dfm_bar_avg[["Element ID","Property ID","Subcase ID"]] #joining with some input cols
        df_addition=dfm_bar_avg[["Property ID","Subcase ID"]] #joining with some input cols
        df_out_final=pd.concat((df_addition,df_out),axis=1) #yep doing it here
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if m9.get():#bar_durability
        rows=dfm_bar_avg.shape[0] #just for the output, taking headers
        try: sheet_name,df_out,dt=rf_bar_durability(ttb_wb,rows,dfm_bar_avg) #goes to calc
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfm_bar_avg[["Property ID","Subcase ID"]] #joining with some input cols
        df_out_final=pd.concat((df_addition,df_out),axis=1) #yep doing it here
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if m10.get():#crippling
        rows=dfm_bar_all.shape[0]
        try: sheet_name,df_out,dt=rf_crippling_metal(ttb_wb,rows,dfm_bar_all)
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_addition=dfm_bar_all[["Element ID","Property ID","Subcase ID"]] #Element ID header avg'da yok
        df_out_final=pd.concat((df_addition,df_out),axis=1)
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
    
    if m12.get():#ir-buckling
        rows=dfm_bar_all.shape[0] #just for the output, taking headers
        try: sheet_name,df_out,dt=rf_ir_buckling_metal(ttb_wb,rows,dfm_bar_all,df_misc_joint) #goes to calc
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL), run_button.config(state=tk.NORMAL)
        
        df_out_final=df_out #made the trick inside the function
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
        
    if m11.get(): #fbending
      rows=dfm_bar_all.shape[0]
      try: sheet_name,df_out,dt=rf_fbending(ttb_wb,rows,dfm_bar_all,df_misc_joint)
      except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
      
      df_out_final=df_out
      
      write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
      write_log(sheet_name,dt,state=1)
      
      count+=1
      progress_bar['value']=100*(count-1)/check_vars
      
      
    #JOINT
    if m13.get():#joint
        try: sheet_name,df_out,dt=rf_joint_metal(ttb_wb,dfm_joint)
        except: result_label.config(text="ERROR due to failure tabs.", fg="red", font="Colossal 9"), run_button.config(state=tk.NORMAL)
        
        df_out_final=df_out #made the trick inside the function
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        write_log(sheet_name,dt,state=1)
        
        count+=1
        progress_bar['value']=100*(count-1)/check_vars
    
    
    # ttb_wb.app.calculation = 'automatic'
    end=time.time()
    progress_bar['value']=100
    
    result_label.config(text=f"({count-1}/{check_vars}) DONE ! {end-start:0.2f} seconds", fg="green", font=("Colossal 9 bold"))
    run_button.config(state=tk.NORMAL)
    root.update_idletasks()
    write_log(sheet_name,dt,state=2)
    
    # get_summary() #summary function
    # progressbar.stop()
    """activate here if you want to keep the toolbox at background"""
    stop_event.set()
    
    #EGER BACKGROUND KULLANIRSAN ACABILIRSIN
    # ttb_wb.close()
    try:
        ttb_wb.app.api.Calculation=xw.constants.Calculation.xlCalculationAutomatic
        ttb_wb.app.screen_updating=True
        ttb_wb.app.display_alerts=True
        ttb_wb.app.enable_events=True
    except:
        pass
    """
    # try:
    #     app.quit() #to prevent excel pile-up at the background
    #     app.kill()
    #     del app
    # except:
    #     pass
    
    del ttb_wb
    """
    return None
    

def get_load_df(path_entry,df_misc):
    """misc file is combined with the load file
    based on the Property ID column"""
    # path_entry=Path(path_entry)
    df_join=pd.DataFrame()
    
    try:
        
        try:
            df_load=pd.read_csv(path_entry)
        except:
            df_load=pd.read_excel(path_entry)
        
        if len(df_load.columns)==1:
            try:
                cols=[col for col in str(df_load.columns.values).strip("[").strip("]").strip("'").split(",")]
                df_load=df_load[df_load.columns[0]].str.split(",",expand=True)
                df_load.columns=cols
            except Exception as e:
                print("ERROR - something wrong with reading csv file, columns are weird.")
                print(e)
                
        #bütün csvleri kapsar
        if "Temperature (C)" in df_load.columns:
            # df_load["Temperature (C) - default"]=df_load["Temperature (C)"].copy()
            # df_load["Temperature (C)"]=df_load["Temperature (C)"].apply(lambda x: 130 if x>130 else x)
            df_load.rename(columns={"Subcase_ID":"Subcase ID"},inplace=True)
            
            # 0 -> MECH
            # 1 -> COLD
            # 2 -> HOT
            # 3 -> STD
            df_load["Temperature (C)"].loc[(df_load["Temperature (C)"].isna()) & (df_load["Subcase ID"].astype(str).str[-1]=="1")]=-54
            df_load["Temperature (C)"].loc[(df_load["Temperature (C)"].isna()) & (df_load["Subcase ID"].astype(str).str[-1]=="2")]=100
            df_load["Temperature (C)"].loc[(df_load["Temperature (C)"].isna()) & (df_load["Subcase ID"].astype(str).str[-1]=="3")]=100
            # df_load["Temperature (C)"].loc[(df_load["Temperature (C)"].isna()) & (df_load["Subcase ID"].astype(str).str[-1]=="0")]=23
            df_load["Temperature (C)"].fillna(100,inplace=True)
            
        #JOINT LOAD
        if "Bar Property ID" in df_load.columns: 
            if "P - Web Radius" in df_load.columns: #unfolding
                df_load.rename(columns={'Bar Property ID':'Property ID', 'Bar Element ID': 'Element ID'}, inplace=True)
                # df_load.drop("Element ID (PBARL)",inplace=True,axis=1)
                df_join=pd.merge(df_load,df_misc,on="Property ID",how="inner")
                
            else:
                df_load.rename(columns={'Bar Property ID':'Property ID (PBARL)', 'Bar Element ID': 'Element ID (PBARL)',
                                        'NX Bypass':'Nx Bypass', 'NY Bypass':'Ny Bypass', 'NXY Bypass': 'Nxy Bypass',
                                        'MX':'Mx','MY':'My','MXY':'Mxy'}, inplace=True)
                # df_join=pd.merge(df_load,df_misc,on="Property ID (PBARL)",how="inner")
                
                df_load.drop("Property ID (PBARL)",inplace=True,axis=1)
                df_join=pd.merge(df_load,df_misc,on="Element ID (PBARL)",how="inner")
                
            return df_join
        
        if "MX" in df_load.columns:
            df_load.rename(columns={"MX":"Nx","MY":"Ny","MXY":"Nxy",
                                    "BMX":"Mx","BMY":"My","BMXY":"Mxy",
                                    "TX":"Tx","TY":"Ty"},inplace=True)
        
        if "NX Average" in df_load.columns:
            df_load.rename(columns={"NX Average":"Nx Average","NY Average":"Ny Average","NXY Average":"Nxy Average",
                                    "MX Average":"Mx Average","MY Average":"My Average","MXY Average":"Mxy Average",
                                    "TX":"Tx","TY":"Ty"},inplace=True)
            
        if "Subcase_ID" in df_load.columns or "Property_ID" in df_load.columns:
            try: df_load.rename(columns={"Element_ID":"Element ID","Property_ID":"Property ID","Subcase_ID":"Subcase ID"},inplace=True)
            except: df_load.rename(columns={"Property_ID":"Property ID","Subcase_ID":"Subcase ID"},inplace=True)
                
            try: df_load["Property ID"] = df_load["Property ID"].apply(lambda x : int(x.strip("[").strip("]")))
            except: pass
        
        if "Subcase ID" in df_load.columns:
            try: df_load["Property ID"] = df_load["Property ID"].apply(lambda x : int(x.strip("[").strip("]")))
            except: pass
        
        #eger df_load ve misc icinde aynı pid yoksa bos verir
        df_join=pd.merge(df_load,df_misc,on="Property ID",how="inner")
        
        try:
            df_join["Panel Length X"]=df_join["Panel Length X"].apply(lambda x: df_join["Panel Length X"].mean() if (x==0 or x==None) else x)
            df_join["Panel Length Y"]=df_join["Panel Length Y"].apply(lambda x: df_join["Panel Length Y"].mean() if (x==0 or x==None) else x)
        except:
            pass
        
    except: #eger path_entry boş ise, geç ve baştaki empty df_join yolla
        pass
    
    return df_join

"""
def pre_write(sheet_name,df_out,dt, df,additional_cols,joint=False):
    if joint:
        dfc_joint=df[df["Element Type"]=="Skin"]
        df_addition=df[[additional_cols]].reset_index(drop=True) #Element ID header avg'da yok
        df_out_final=pd.concat((df_addition,df_out),axis=1)
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        result_label.config(text=f"~ {sheet_name}")
        root.update_idletasks()
        
    else:
        rows=dfm_bar_all.shape[0] #just for the output, taking headers
        try: sheet_name,df_out,dt=rf_bar_strength(ttb_wb,rows,dfm_bar_all) #goes to calc
        except: result_label.config(text="ERROR due to failure tabs.", font=("Times 11"), fg="red")
        
        df_addition=dfm_bar_all[["Element ID","Property ID","Subcase ID"]] #joining with some input cols
        df_out_final=pd.concat((df_addition,df_out),axis=1) #yep doing it here
        
        write_stuff(sheet_name,df_out, df_out_final,dt) #making the output
        result_label.config(text=f"~ {sheet_name}")
        root.update_idletasks()
"""   
   
def write_stuff(sheet_name,df_out,df_out_final,dt):
    # df_describe['Calculation (seconds)'].loc[1]=float(f'{dt:0.2f}')
    sheet_name=sheet_name.replace(" ","")
    file_name=datetime.datetime.now().strftime(f"{sheet_name}_%H%M%S-%d%m%Y")
    # file_name=datetime.datetime.now().strftime(f"{sheet_name}-%H%M%S%Y%m%d")
    os.chdir(tatobin_path)
    # os.chdir(os.path.dirname(ttb_path))
    
    # for file in os.listdir():
    #     if sheet_name in file:
    #         sheet_name=sheet_name+"_"+str(time.time()).split(".")[-1][-3:]
    #         sheet_name=sheet_name[:31]
    #         break
    
    rogue_path=os.path.join("//vds/alldept3/Analiz_T5200/T52G0/T24505/9001_trainingdata",f"TTB_{file_name}-{os.getlogin()}.xlsx")
    
    try: df_out_final.dropna(subset="Property ID", inplace=True)
    except: pass

    if "cbj" in sheet_name.lower() and "ML" not in sheet_name:
        df_out_final["RF"].fillna(0,inplace=True)
        df_out_final["RF"]=df_out_final["RF"].apply(lambda x: 0 if isinstance(x,str) else x) #need to get rid of strings to work with idxmin
        df_out_final["RFcombined"]=df_out_final["RFcombined"].apply(lambda x: 0 if isinstance(x,str) else x) #need to get rid of strings to work with idxmin
        df_out_final["RFnet"]=df_out_final["RFnet"].apply(lambda x: 0 if isinstance(x,str) else x) #need to get rid of strings to work with idxmin
        df_rf=df_out_final.loc[df_out_final.groupby("Property ID")["RF"].idxmin(), df_out_final.columns].reset_index(drop=True)
        df_rf21=df_out_final.loc[df_out_final.groupby("Property ID")["RFcombined"].idxmin(), df_out_final.columns].reset_index(drop=True)
        df_rf22=df_out_final.loc[df_out_final.groupby("Property ID")["RFnet"].idxmin(), df_out_final.columns].reset_index(drop=True)
        df_rf2=pd.concat([df_rf21,df_rf22])
        
        with pd.ExcelWriter(f"TTB_{file_name}.xlsx") as writer:
                df_out_final.to_excel(writer,sheet_name=f"{sheet_name}",index=False)
                df_rf.to_excel(writer,sheet_name="RF min",index=False)
                df_rf2.to_excel(writer,sheet_name="RF min 2",index=False)
                # df_describe.to_excel(writer,sheet_name="stats",index=True)
                
        try: shutil.copy2(f"TTB_{file_name}.xlsx",rogue_path)
        except: pass
                
    else:
        try:
            """
            df_out_final["RF"]=pd.to_numeric(df_out_final["RF"],errors="coerce")
            df_out_final["RF"].fillna("n/a",inplace=True)
            df_out_final["RF"]=df_out_final["RF"].apply(lambda x: 0 if isinstance(x,str) else x) #need to get rid of strings to work with idxmin
            df_rf=df_out_final.loc[df_out_final.groupby("Property ID")["RF"].idxmin().dropna().astype(int), df_out_final.columns].reset_index(drop=True)
            """
            # df_out_final["RF"].fillna(0,inplace=True)
            df_out_final["RF"]=df_out_final["RF"].fillna(0)
            
            if "crippling" in sheet_name.lower():
                df_out_final["RF"]=df_out_final["RF"].apply(lambda x: 1000 if isinstance(x,str) else x) #need to get rid of strings to work with idxmin
            else:
                df_out_final["RF"]=df_out_final["RF"].apply(lambda x: 0 if isinstance(x,str) else x) #need to get rid of strings to work with idxmin
                
            df_rf=df_out_final.loc[df_out_final.groupby("Property ID")["RF"].idxmin(), df_out_final.columns].reset_index(drop=True)
            
        except:
            try:
                df_out_final["RF Combined"].fillna(0,inplace=True)
                df_out_final["RF Combined"]=df_out_final["RF Combined"].apply(lambda x: 0 if isinstance(x,str) else x) #need to get rid of strings to work with idxmin
                df_rf=df_out_final.loc[df_out_final.groupby("Property ID")["RF Combined"].idxmin(), df_out_final.columns].reset_index(drop=True)
            except Exception as e:
                print(f"ERROR - {e}")
        
        with pd.ExcelWriter(f"TTB_{file_name}.xlsx") as writer:
                df_out_final.to_excel(writer,sheet_name=f"{sheet_name}",index=False)
                df_rf.to_excel(writer,sheet_name="RF min",index=False)
                # df_describe.to_excel(writer,sheet_name="stats",index=True) 
                
        try: shutil.copy2(f"TTB_{file_name}.xlsx",rogue_path)    
        except: pass
            #get additional info
            #ttb_name=os.path.basename(path_entry1.get())
            #misc_name=os.path.basename(path_entry2.get())
            # df_describe.to_excel(writer,sheet_name="stats",index=True) 
    
    df_describe=df_out_final.describe()
    print("\nRF summary:")
    try: 
        try: print(df_describe["RF"])
        except: print(df_describe["RF Combined"])
    except: 
        pass

    full_path=os.path.join(os.getcwd(),f'TTB_{file_name}.xlsx')
    print(f"\nSaved - {full_path}\n")
    return 0
  

def write_log(sheet_name,dt,state):
    """
    n=78
    if state==0:
        with open("TTB.log","a") as fout:
            fout.write("\n"+n*"="+"\n")
            readable_time=time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time()))
            fout.write(f"TTB has started on: {readable_time}\n")
            # fout.write(n*"-"+"\n")
            fout.write("\n")
        
    elif state==1:
        with open("TTB.log","a") as fout:
            aa=19-len(f"{dt:0.2f}")
            fout.write(f"* {sheet_name}{(40-len(sheet_name))*' '}{dt:0.2f} seconds{aa*' '}COMPLETED\n")
    
    elif state==2:
        with open("TTB.log","a") as fout:
            # fout.write(n*"-"+"\n")
            fout.write("\n")
            readable_time=time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time()))
            fout.write(f"TTB has finished on: {readable_time}\n")
            fout.write(n*"="+"\n\n")
    """
    return 0



# =============================================================================
# HELPERS        
# =============================================================================

def center_window(window):
    window.update_idletasks()
    width = window.winfo_width()
    height = window.winfo_height()
    screen_width = window.winfo_screenwidth()
    screen_height = window.winfo_screenheight()
    x = (screen_width - width) // 2
    y = (screen_height - height) // 2
    window.geometry(f"{width}x{height}+{x}+{y}")
    
    return None


def place_tab(tabcontrol,name):
    # global tab_style
    # tab_style=ttk.Style()
    style.configure("TNotebook.Tab", font=("Segoe UI",9,"normal"), padding=[2,2])
    # style.configure("TNotebook", background="red")
    style.map("TNotebook.Tab", background=[("selected","red")], foreground=[("selected","blue")])
    tab=ttk.Frame(tabcontrol)
    tabcontrol.add(tab, text=name)
    tabcontrol.pack(expand=1,ipadx=1, fill="both")
    return tab


def open_directory(directory):
    if os.path.isdir(directory):
        os.startfile(directory)


def random_requirement(path):
    try:
        df=pd.read_excel(path)
        req=random.choice(list(df["Requirement"]))
        
        idx=df[df["Requirement"]==req].index[0]
        chapter_title=df["Chapter Title"][idx]
        chapter_no=df["Chapter #"][idx]
        
        text=f"{req}\n\n({chapter_no} - {chapter_title})"
        # text=f"{chapter_no} - {chapter_title}\n\n{req}"
        messagebox.showinfo("ASC Requirement",text)
        
    except:
        messagebox.showerror("ERROR","Something is wrong.")
    

def update_message():
    path=r'//vds/alldept3/Analiz_T5200/T52G0/T24505/icons/ASC Static-Tails_20241204.xlsx'
    try: df=pd.read_excel(path)
    except: df=None
    
    while not stop_event.is_set():
        try:
            req=random.choice(list(df["Requirement"])).replace("\n"," ")
            idx=df[df["Requirement"]==req].index[0]
            chapter_title=df["Chapter Title"][idx]
            chapter_no=df["Chapter #"][idx]
            text=f"{req} ({chapter_no} - {chapter_title})"
         
        except:
            text="Looking for an information..."
            
        req_label.config(text=text, wraplength=450)
        root.update_idletasks() #only visual parts, buttons are not for instance
        # root.update()
        time.sleep(15)

def toggle_highlight(entry,var):
    if var.get():
        entry.config(highlightbackground="green",highlightthickness=2)
    else:
        entry.config(highlightthickness=0)
    
def browse_path1():
    path = filedialog.askopenfilename(filetypes=[("Toolbox file", "*.xlsm")])  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry1.delete(0, tk.END)
        path_entry1.insert(0, path)
    return None

def browse_path2():
    path = filedialog.askopenfilename(filetypes=[("Misc file", "*.xlsx")])  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry2.delete(0, tk.END)
        path_entry2.insert(0, path)
    return None

def browse_path3():
    path = filedialog.askopenfilename(filetypes=[("Load file", "*.csv"),("Load file (alt)", "*.xlsx")]
)  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry3.delete(0, tk.END)
        path_entry3.insert(0, path)
    return None

def browse_path4():
    path = filedialog.askopenfilename(filetypes=[("Load file", "*.csv"),("Load file (alt)", "*.xlsx")]
)  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry4.delete(0, tk.END)
        path_entry4.insert(0, path)
    return None

def browse_path5():
    path = filedialog.askopenfilename(filetypes=[("Load file", "*.csv"),("Load file (alt)", "*.xlsx")]
)  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry5.delete(0, tk.END)
        path_entry5.insert(0, path)
    return None

def browse_path6():
    path = filedialog.askopenfilename(filetypes=[("Load file", "*.csv"),("Load file (alt)", "*.xlsx")]
)  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry6.delete(0, tk.END)
        path_entry6.insert(0, path)
    return None

def browse_path7():
    path = filedialog.askopenfilename(filetypes=[("Load file", "*.csv"),("Load file (alt)", "*.xlsx")]
)  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry7.delete(0, tk.END)
        path_entry7.insert(0, path)
    return None

def browse_path8():
    path = filedialog.askopenfilename(filetypes=[("Load file", "*.csv"),("Load file (alt)", "*.xlsx")]
)  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry8.delete(0, tk.END)
        path_entry8.insert(0, path)
    return None

def browse_path9():
    path = filedialog.askopenfilename(filetypes=[("Load file", "*.csv"),("Load file (alt)", "*.xlsx")]
)  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry9.delete(0, tk.END)
        path_entry9.insert(0, path)
    return None

def browse_path10():
    path = filedialog.askopenfilename(filetypes=[("Load file", "*.csv"),("Load file (alt)", "*.xlsx")]
)  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry10.delete(0, tk.END)
        path_entry10.insert(0, path)
    return None

def browse_path11():
    path = filedialog.askopenfilename(filetypes=[("Load file", "*.csv"),("Load file (alt)", "*.xlsx")]
)  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry11.delete(0, tk.END)
        path_entry11.insert(0, path)
    return None

def browse_path12():
    path = filedialog.askopenfilename(filetypes=[("Load file", "*.csv"),("Load file (alt)", "*.xlsx")]
)  # For file selection
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        path_entry12.delete(0, tk.END)
        path_entry12.insert(0, path)
    return None

# def browse_path_ml():
#     path = filedialog.askopenfilename(filetypes=[("Load file", "*.pkl")])  # pickle file
#     # Uncomment the line below to allow directory selection instead
#     # path = filedialog.askdirectory() 
#     if path:
#         ml_file.delete(0, tk.END)
#         ml_file.insert(0, path)
#     return None

def browse_path_sum():
    # Uncomment the line below to allow directory selection instead
    messagebox.showwarning("Summary","(Optional) If you want to summarize 'mass', make sure to choose MASTER.BDF in the below option also.")
    path = filedialog.askdirectory() 
    if path:
        sum_file.delete(0, tk.END)
        sum_file.insert(0, path)
    return None

def browse_path_plot():
    path = filedialog.askopenfilename(filetypes=[("TTB_summary file", "*.xlsx")])  # pickle file
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        plot_file.delete(0, tk.END)
        plot_file.insert(0, path)
    return None

def browse_path_plot2():
    path = filedialog.askopenfilename(filetypes=[("Misc file", "*.xlsx")])  # pickle file
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        misc_file.delete(0, tk.END)
        misc_file.insert(0, path)
    return None

def browse_path_plot3():
    path = filedialog.askopenfilename(filetypes=[(".bdf file", "*.bdf")])  # pickle file
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        bdf_file.delete(0, tk.END)
        bdf_file.insert(0, path)
    return None

def browse_path_plot4():
    path = filedialog.askopenfilename(filetypes=[(".bdf file", "*.bdf")])  # pickle file
    # Uncomment the line below to allow directory selection instead
    # path = filedialog.askdirectory() 
    if path:
        bdf_file2.delete(0, tk.END)
        bdf_file2.insert(0, path)
    return None


def my_read_bdf(path):
    try:
        try: bdf=read_bdf(path,punch=True,xref=True)
        except: bdf=read_bdf(path,punch=True,xref=False)
    except:
        try: bdf=read_bdf(path,punch=False,xref=True)
        except: bdf=read_bdf(path,punch=False,xref=False)
    return bdf


# def browse_path13():
#     path = filedialog.askopenfilename()  # For file selection
#     # Uncomment the line below to allow directory selection instead
#     # path = filedialog.askdirectory() 
#     if path:
#         path_entry13.delete(0, tk.END)
#         path_entry13.insert(0, path)
#     return None

# =============================================================================
# """""""""""""""""""""""""""""""""""G  U  I"""""""""""""""""""""""""""""""""""
# =============================================================================

if __name__=="__main__":
    username=os.getlogin()
    uname=getpass.getuser()
    os_name=platform.system()
    os_version=platform.version()
    processor_info=platform.processor()
    architecture=platform.architecture()[0]
    cpu_cores=psutil.cpu_count(logical=False)
    cpu_threads=psutil.cpu_count(logical=True)
    total_memory=psutil.virtual_memory().total/(1024**3)
    available_memory=psutil.virtual_memory().available/(1024**3)
    total_disk=psutil.disk_usage('/').total/(1024**3)
    used_dist=psutil.disk_usage('/').used/(1024**3)
    free_disk=psutil.disk_usage('/').free/(1024**3)
    
    uname=os.getlogin()
    uname_no=""
    for i in uname:
        try: uname_no+=str(int(i))
        except: pass
    
            
    #----COWSAY SCREEN
    ll=['cow','dragon','fox','kittly','meow','octopus',
        'stegosaurus','stimpy','trex','turtle','tux']
    
    char=ll[int(uname_no)%len(ll)]
    char_mod=char[0].upper()+char[1:]
    
    text=f"\nWELCOME {os.getlogin()} !\nI am {char_mod} and this is T4TOBIN.\nIts aim is to minimize errors, make output files standardand reduce time spend in the GFEM sizing process.\n...\nI see that you have:\n\
        Operating System -> {os_name} {architecture}\nProcessor -> {cpu_cores} cores / {cpu_threads} threads\n\
        Memory -> {available_memory:0.2f} GB free / {total_memory:0.2f} GB total\nDisk -> {free_disk:0.2f} GB free / {total_disk:0.2f} GB total\n...\n\
            Please do not hesitate to share your ideas and annoying bugs about the tool.\n\n"
            
    # text=(
    #       f"\nWELCOME {os.getlogin()}! This is T4TOBIN.\n"
    #       f"Its aim is to minimize errors, make output files standardand reduce time spend in the GFEM sizing process.\n\n"
    #       f"I see that you have:\n"
    #       f"Operating System -> {os_name} {architecture}\nProcessor -> {cpu_cores} cores / {cpu_threads} threads\n"
    #       f"Memory -> {available_memory:0.2f} GB free / {total_memory:0.2f} GB total\nDisk -> {free_disk:0.2f} GB free / {total_disk:0.2f} GB total\n"
    #       f"Please do not hesitate to share your ideas\nand annoying bugs about the tool.\n"
    #       )
    
    # text=f"\nWELCOME {os.getlogin()} !\nMy name is Mr. {char_mod} and this is the Tail-Toolbox-Interface-2 (a.k.a. T4TOBIN). Its aim is to minimize errors, make output files standard and reduce time spend in the GFEM sizing process.\nI see that you have:\n\
    #     Operating System: {os_name} {architecture}\nProcessor: {cpu_cores} cores / {cpu_threads} threads\n\
    #     Memory: {available_memory:0.2f} GB free / {total_memory:0.2f} GB total\nDisk: {free_disk:0.2f} GB free / {total_disk:0.2f} GB total\n\
    #         Please do not hesitate to make contributions to the tool by informing about bugs and sharing ideas."
    
    
    # print(cowsay.get_output_string(char,text))
    
    #------FIGLET SCREEN
    
    text=(
          f"WELCOME {os.getlogin()}! Your system briefly:\n\n"
          # f"Its aim is to minimize errors, make output files standardand reduce time spend in the GFEM sizing process.\n\n"
          f"Operating System -> {os_name} {architecture}\nProcessor -> {cpu_cores} cores / {cpu_threads} threads\n"
          f"Memory -> {available_memory:0.2f} GB free / {total_memory:0.2f} GB total\nDisk -> {free_disk:0.2f} GB free / {total_disk:0.2f} GB total\n"
          f"\n(Please do not hesitate to share your ideas and annoying bugs about the tool.)\n"
          )
    
    #one solution is to add "--collect-all pyfiglet" -> DID NOT WORK
    """
    ll=["3d-ascii","standard","graffiti","ghost","block","big","epic","ansi_shadow"]
    figlet=pyfiglet.Figlet(font="big")
    ascii_art=figlet.renderText("T4TOBIN")
    print("-"*47+"\n")
    print(ascii_art,end="")
    print("-"*47+"\n")
    # print("##################################################################################")
    """
    figlet=("""
------------------------------------------------

 _______ _  _ _______ ____  ____ _____ _   _ 
|__   __| || |__   __/ __ \|  _ \_   _| \ | |
   | |  | || |_ | | | |  | | |_) || | |  \| |
   | |  |__   _|| | | |  | |  _ < | | | . ` |
   | |     | |  | | | |__| | |_) || |_| |\  |
   |_|     |_|  |_|  \____/|____/_____|_| \_|
                                             
                                             
------------------------------------------------
      
""")
    
    print(figlet,end="")
    print(text)
    
    """
    print("##################################################################################")
    print(f"WELCOME {os.getlogin()} !\n")
    print(f"Operating System: {os_name} {architecture}")
    print(f"Processor: {processor_info} {cpu_cores}/{cpu_threads}")
    print(f"Memory: {available_memory:0.2f} GB / {total_memory:0.2f} GB")
    print(f"Disk: {free_disk:0.2f} GB / {total_disk:0.2f} GB")
    print(f"\nThis is the Tail-Toolbox-Interface-2 a.k.a. T4TOBIN \nIts aim is to minimize errors, make output files standard\nand reduce time spend in the GFEM sizing process.\n")
    print("##################################################################################\n") 
    """
    
    #----COLUMN NAMES
    lcid_col="Subcase_ID"
    elid_col="Element_ID"
    pid_col="Property_ID"
    nxx_col,nyy_col,nxy_col="MX","MY","MXY"
    nxx_avg_col,nyy_avg_col,nxy_avg_col="NX Average","NY Average","NXY Average"
    
    
    #-----------------
    # Initialize the GUI
    root = tk.Tk()
    root.title("T4TOBIN")
    root.geometry("480x640")
    # root.configure(bg="red")  # Set background color to gray
    root.resizable(False,False)
    
    style=ttk.Style()
    style.theme_use("vista")
    def_theme=style.theme_use()
    # print(def_theme)
    # style.theme_use('winnative') #('winnative', 'clam', 'alt', 'default', 'classic', 'vista', 'xpnative')
    
    tabcontrol=ttk.Notebook(root)
    tab1=place_tab(tabcontrol,"🏚 Home")
    tab3=place_tab(tabcontrol,"🌫 Composite failures")
    tab2=place_tab(tabcontrol,"🛡 Metallic failures")
    tab4=place_tab(tabcontrol,"📊 Summary") #for future uses
    tab5=place_tab(tabcontrol,"🍄 About")
    
    
    try:
        img=tk.PhotoImage(file='//vds/alldept3/Analiz_T5200/T52G0/T24505/icons/face2.PNG', master=tab1)
        # img=tk.PhotoImage(file='//vds/alldept3/Analiz_T5200/T52G0/T24505/icons/c2.png', master=tab1)
        img_label=tk.Label(tab5,image=img)
        img_label.place(x=385,y=10)
    except:
        pass
    
    center_window(root)
    
# =============================================================================
# ---------------HOME
# =============================================================================
    constant_label=tk.Label(tab1,text="Put your toolbox and misc file in the below boxes, these are the constants.",
                            justify="left", font="Verdana 8 italic")
    constant_label.place(x=10,y=10)
    
            
    # browses
    browse_button1 = tk.Button(tab1, text="Tbox :", command=browse_path1, width=5,fg="black")
    browse_button1.place(x=10,y=40)
    path_entry1 = tk.Entry(tab1,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry1.place(x=70,y=41, height=25)
    
    
    browse_button2 = tk.Button(tab1, text="Misc :", command=browse_path2, width=5, fg="black")
    browse_button2.place(x=10,y=80)
    path_entry2 = tk.Entry(tab1,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry2.place(x=70,y=81, height=25)
    
   
    #seperator (probably ML)
    separator = ttk.Separator(tab1, orient='horizontal')
    separator.place(x=10,y=130, width=455)
    
    constant_label_ml=tk.Label(tab1,text="ML model: ",justify="left", font="Verdana 8 bold", fg="black")
    constant_label_ml.place(x=10,y=145)
    
    # def toggle():
    #     if ml_button.config('text')[-1] == "OFF": ml_button.config(text="ON", relief="sunken", bg="green")
    #     else: ml_button.config(text="OFF", relief="raised", bg="SystemButtonFace")
        
    # ml_button=tk.Button(tab1, text="OFF", width=3, fg="black", command=toggle, relief="raised",bd=2)
    # ml_button.place(x=80,y=140)
    
    def toggle_radio():
        #colors=["#FF10F0","#9D00FF","#007CF0","#FF005C"]
        BG_SOFT="#1E1E1E"
        BG_DARK="#0A0A0A"
        BG_DARKER="#050505"
        CYAN="#00ffff"
        MAGENTA="#ff00ff"
        PURPLE="#bd00ff"
        CYAN_GLOW="#00d4ff"
        CRIMSON="#DC143C"
        
        if ml_choice.get()==0:
            root.configure(bg="gray")
            path_entry1.config(state=tk.NORMAL)
            run_button.config(text="➡ Run")
            # ml_file.config(state=tk.DISABLED,disabledbackground="SystemButtonFace") #OFF
            s1.map("run.TButton",foreground=[("active","green"),("pressed","green")], background=[("active","white"),("pressed","white")])
            s2.map("cancel.TButton",foreground=[("active","red"),("pressed","red")], background=[("active","white"),("pressed","white")])
            style.map("TNotebook.Tab", foreground=[("selected","blue")])
            ml_radio2.config(fg="black")
            # constant_label_ml.config(font="Verdana 8 bold", fg="gray")
            messagebox.showinfo("ML option","ML model is de-activated.")
            
        else:
            root.configure(bg="black")
            path_entry1.config(state=tk.DISABLED,disabledbackground="SystemButtonFace")
            # ml_file.config(state=tk.NORMAL) #ON
            run_button.config(text="⚡ Run")
            s1.map("run.TButton",foreground=[("active",MAGENTA),("pressed",MAGENTA)], background=[("active", MAGENTA),("pressed", MAGENTA)])
            s2.map("cancel.TButton",foreground=[("active","red"),("pressed","red")], background=[("active", MAGENTA),("pressed", MAGENTA)])
            style.map("TNotebook.Tab", foreground=[("selected",MAGENTA)],focuscolor="none") ##FF10F0
            ml_radio2.config(fg=MAGENTA)
            # constant_label_ml.config(font="Verdana 8 bold", fg="#DC143C")
            messagebox.showwarning("ML option","ML model is ACTIVATED ! This model is capable of solving:\n\n◾ Composite Bolted Joint\n◾ Ritz Buckling")
        
        # else:
        #     style.theme_use("clam")
        #     root.configure(bg="#1e1e1e")
        #     # tab_style.theme_use("default")
            # style.configure("TNotebook", backgrond="#1e1e1e", borderwidth=1, relief="solid")
            # style.configure("TNotebook.Tab", background="#1a1a1a", foreground="#ff66cc")
            # style.map("TNotebook.Tab", background=[("selected","#ff1a8c")], foreground=[("selected","black")])
            # style.configure("Black.TFrame", background=BG_SOFT)
            
            # for tab_id in tabcontrol.tabs():
            #     tab=tabcontrol.nametowidget(tab_id)
            #     tab.configure(style="Black.TFrame")
                
            #     for child in tab.winfo_children():
            #         if isinstance(child,tk.Entry):
            #             child.configure(bg=CYAN_GLOW)
            #         if isinstance(child,tk.Button):
            #             child.configure(bg=CYAN)
            #         else:
            #             try:
            #                 child.configure(bg=BG_SOFT)
            #             except:
            #                 pass
                # if isinstance(entry,tk.Entry):
                #     entry.configure(bg="black")
            
        #     path_entry1.config(state=tk.DISABLED,disabledbackground="SystemButtonFace")
        #     ml_file.config(state=tk.NORMAL) #ON
        #     run_button.config(text="⚡ Run")
            
        #     ml_radio2.config(fg="#FF10F0")
        #     messagebox.showwarning("ML option","ML prediction is ACTIVATED ! This model is capable of solving:\n\n◾ Composite Bolted Joint\n◾ Ritz Buckling")
        
            
    # ml_browse = tk.Button(tab1, text="pkl :", command=browse_path_ml, width=5,fg="black")
    # ml_browse.place(x=10,y=177)
    # ml_file = tk.Entry(tab1,width=65, font=("Colossal",8), relief="sunken", borderwidth=2)
    # ml_file.place(x=70,y=178, height=25)
    # ml_file.config(state=tk.DISABLED,disabledbackground="SystemButtonFace")
    
    ml_choice=tk.IntVar()
    ml_radio1=tk.Radiobutton(tab1, text="OFF", variable=ml_choice, value=0, command=toggle_radio)
    ml_radio1.place(x=85,y=144)
    ml_radio2=tk.Radiobutton(tab1, text="ON", variable=ml_choice, value=1, command=toggle_radio)
    ml_radio2.place(x=135,y=144)
    ml_radio2.config(state=tk.NORMAL)
    
    # ml_note=tk.Label(tab1, justify="left", text="Please share your data, so we can improve K.",
    #                  font="Verdana 8 italic")
    # ml_note.place(x=10,y=180)
    
    try:
        useful_path3=r'\\vds\alldept3\Analiz_T5200\T52G0\T24505\9000_TrainingData'
        clickable_label=tk.Label(tab1,text="Please share your data here ! So we can improve our ML model.", cursor="hand2",
                                justify="left", font="Verdana 8 italic", fg="black")
        clickable_label.place(x=10,y=180)
        clickable_label.bind("<Button-1>", lambda e: open_directory(useful_path3))
    except:
        pass
    """
    constant_label=tk.Label(tab1,text="WELCOME human !\n\nThis is the Tail-Toolbox-Interface V2 a.k.a. TATOBIN_V2 \n\n\
Its aim is to minimize errors, to make output files standard\nand to reduce time in the GFEM sizing process.",
                            justify="left", font="Verdana 8")
    constant_label.place(x=10,y=145)
    
    notifications_y=250
    constant_label2=tk.Label(tab1,text="Notifications:",
                            justify="left", font="Verdana 8 underline")
    constant_label2.place(x=10,y=notifications_y)
    
    useful_path=r'\\vds\alldept3\Analiz_T5200\T52G0\02-BLOCK_10\03-Failure_Modes'
    clickable_label=tk.Label(tab1,text="1) Click here for information about the analysis strategy.", cursor="hand2",
                            justify="left", font="Verdana 8 bold", fg="black")
    clickable_label.place(x=10,y=notifications_y+25)
    clickable_label.bind("<Button-1>", lambda e: open_directory(useful_path))
    
    note1=tk.Label(tab1,text="2) 'Panel flutter' needs average load excel to fulfill panel lengths.", font="Verdana 8", fg="black")
    note1.place(x=10,y=notifications_y+45)
    note2=tk.Label(tab1,text="3) 'Buckling' is the analytical one and needs toolbox v4.06.", font="Verdana 8", fg="black")
    note2.place(x=10,y=notifications_y+65)
    note3=tk.Label(tab1,text="4) 'Strength' calculations are based on N-sigma Mises stress.", font="Verdana 8", fg="black")
    note3.place(x=10,y=notifications_y+85)
    note4=tk.Label(tab1,text="5) In some random cases it is advised to close the toolbox.", font="Verdana 8", fg="black")
    note4.place(x=10,y=notifications_y+105)
    note5=tk.Label(tab1,text="6) Do not exceed the maximum input size for excel (circa 1 million rows).", font="Verdana 8", fg="black")
    note5.place(x=10,y=notifications_y+125)
    #seperator (probably sizing)
    """
    
    
    separator = ttk.Separator(tab1, orient='horizontal')
    separator.place(x=10,y=220, width=455)
    
    # constant_label=tk.Label(tab1,text="Reserved for the future use.", fg="gray",
    #                         justify="left", font="Verdana 8 italic")
    
    # constant_label = tk.LabelFrame(tab1, text="Load File Selection", padx=10, pady=10)
    
    constant_label=tk.Label(tab1,text="Did you know ?", fg="gray",
                            justify="left", font="Verdana 8 ")
    constant_label.place(x=10,y=235)
    
    req_label=tk.Label(tab1,text=" ",fg="black",justify="left",font="Verdana 8")
    req_label.place(x=10,y=255)
    
    """run-----------------------------------------------"""
    
    #run
    # highlight_frame=tk.Frame(tab1, bg="steelblue", width=119, height=33.4)
    # highlight_frame.place(x=345,y=512+62)
    
    #ttk button style
    s1=ttk.Style()
    s1.configure("run.TButton",font=("Colossal", 10))
    s1.map("run.TButton",foreground=[("active","green"),("pressed","green")], background=[("active","white"),("pressed","white")])
    
    s2=ttk.Style()
    s2.configure("cancel.TButton",font=("Colossal", 10))
    s2.map("cancel.TButton",foreground=[("active","red"),("pressed","red")], background=[("active","white"),("pressed","white")])
    
    #THE LOADING SCREEN TRICK
    
    stop_event=threading.Event() #making this for later to signal threads to stop
    update_thread=threading.Thread(target=update_message, daemon=True)
    update_thread.start()
    
    #run
    def main_thread():
        calculation_thread=threading.Thread(target=main,daemon=False)  
        calculation_thread.start()
    
    # run_button = tk.Button(tab1, text="Run", command = main_thread, font=("Colossal 10 bold"), #Times bold
    #                             width=13,fg="black", relief="raised", bd=2)
    # run_button = tk.Button(tab1, text="Run", command = main, font=("Colossal 10 bold"), #Times bold
    #                             width=13, fg="black", relief="raised", bd=2)
    # run_button = ttk.Button(tab1, text="Run", command = main_thread, width=13, cursor="hand2", style="run.TButton")
    run_button = ttk.Button(tab1, text="➡ Run", command = main, width=13, cursor="hand2", style="run.TButton")
    # run_button.place(x=348,y=512+65)
    run_button.place(x=364,y=512+65)
    
    #close
    def root_destroy():
        user_answer=messagebox.askquestion("Cancel", "Are you sure that you want to close the program ?", default="no")
        if user_answer=="no":
            return None
        if user_answer=="yes":
            stop_event.set()
            root.destroy()
            
    # cancel_button = tk.Button(tab1, text="Cancel", command=root_destroy, font=("Colossal 10"), 
    #                             width=13,fg="black")
    cancel_button = ttk.Button(tab1, text="✖ Cancel", command=root_destroy, width=13, cursor="hand2", style="cancel.TButton")
    cancel_button.place(x=11,y=512+65)
    
    #wait label
    result_label=tk.Label(tab1,text="waiting...", fg="gray", width=29, font=("Colossal 9"))
    result_label.place(x=130.5,y=512+69)
    
    #progress bar
    progress_bar=ttk.Progressbar(tab1,length=452, mode='determinate', maximum=100, value=0)
    progress_bar.place(x=12,y=487+64, height=10)
    
# =============================================================================
# ---------------METALLIC FAILURES #starts at 1
# =============================================================================
    
    """shells"""
    constant_label=tk.Label(tab2,text="Shell loads",justify="right", font="Verdana 8 bold")
    constant_label.place(x=10,y=10)
    
    # browses
    browse_button3 = tk.Button(tab2, text="Avg :", command=browse_path3, width=5,fg="black")
    browse_button3.place(x=10,y=40)
    path_entry3 = tk.Entry(tab2,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry3.place(x=70,y=41, height=25)
    
    browse_button4 = tk.Button(tab2, text="All :", command=browse_path4, width=5,fg="black", underline=0)
    browse_button4.place(x=10,y=80)
    path_entry4 = tk.Entry(tab2,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry4.place(x=70,y=81, height=25)
    
    #checks - metals
    m1,m2,m3,m4,m5,m6=tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar()
    
    
    def get_ultimate_choice():
        if m1.get() or m8.get():
            popup=Toplevel(root)
            popup.title("Metallic Strength")
            popup.geometry("265x105")
            try:
                popup.iconbitmap(r'//vds/alldept3/Analiz_T5200/T52G0/T24505/icons/c3.ico')
            except:
                pass
            popup.resizable(False,False)
            center_window(popup)
        
            global ultimate_choice
            ultimate_choice=tk.IntVar()
            label=tk.Label(popup,text="Choose the loading type :",justify="right", font="Verdana 8")
            label.place(x=10,y=10)
            radio1=tk.Radiobutton(popup, text="Ultimate Load", variable=ultimate_choice, value=0)
            radio1.place(x=10,y=36)
            radio2=tk.Radiobutton(popup, text="Proof Load", variable=ultimate_choice, value=1)
            radio2.place(x=160,y=36)
        
            def save_value():
                if ultimate_choice.get()==1:
                    messagebox.showinfo("Metallic Strength","PROOF LOAD has chosen.")
                else:
                    messagebox.showinfo("Metallic Strength","ULTIMATE LOAD has chosen.")
                popup.destroy()
                
            ttk.Button(popup, text="OK", command=save_value).place(x=102,y=70,width=60)
    
        
        
    mheck1=tk.Checkbutton(tab2, text="Strength", variable=m1, command=get_ultimate_choice)
    mheck1.place(x=70,y=125, height=25)
    # mheck1.config(state=tk.DISABLED) #stressler yok load extractionda
    
    mheck2=tk.Checkbutton(tab2, text="Durability", variable=m2)
    mheck2.place(x=220,y=125, height=25)
    mheck2.config(state=tk.DISABLED) #stressler yok load extractionda
    
    def buckling_analytical_warning():
        if m3.get() or c3.get(): 
            messagebox.showwarning("Buckling - Analytical","You have selected 'Buckling - Analytical'.\nThis option requires previous toolbox versions.")
            
    mheck3=tk.Checkbutton(tab2, text="Buckling - Analytical", variable=m3, command=buckling_analytical_warning)
    # mheck3=tk.Checkbutton(tab2, text="Open hole", variable=m3)
    mheck3.place(x=70,y=185, height=25)
    
    def buckling_ritz_warning():
        if m4.get() or c6.get() and ml_choice.get()==0: 
            messagebox.showwarning("Buckling - Ritz","Make sure your Toolbox and Ritz.exe are in the same folder. AND wait for Ritz.exe selection, don't go anywhere yet !")
        
    # def buckling_ritz_path():
    #     if m4.get() or c6.get():
    #         # ritz_path=filedialog.askdirectory(title="select Ritz_batch.exe path") 
    #         ritz_path=filedialog.askopenfilename(title="Select Ritz.exe",filetypes=[("Ritz executable", "*.exe")])
    #         if ritz_path:
    #             ritz_entry.set(ritz_path)
    #             messagebox.showinfo("Buckling - Ritz", f"You have chosen the following path for 'Ritz_batch.exe' :\n{ritz_entry.get()}")
    #     return None
    
    # ritz_entry=tk.StringVar()
    # mheck4=tk.Checkbutton(tab2, text="Buckling - Ritz", variable=m4,  command=buckling_ritz_warning)
    mheck4=tk.Checkbutton(tab2, text="Buckling - Ritz", command=buckling_ritz_warning, variable=m4)
    mheck4.place(x=70,y=155, height=25)
    # mheck4.config(state=tk.DISABLED)
    
    mheck5=tk.Checkbutton(tab2, text="TBD", variable=m5)
    mheck5.place(x=370,y=125, height=25)
    mheck5.config(state=tk.DISABLED)
    
    mheck6=tk.Checkbutton(tab2, text="TBD", variable=m6)
    mheck6.place(x=370,y=155, height=25)
    mheck6.config(state=tk.DISABLED)
    
    mheck6=tk.Checkbutton(tab2, text="TBD", variable=m6)
    mheck6.place(x=220,y=155, height=25)
    mheck6.config(state=tk.DISABLED)
    
    mheck6=tk.Checkbutton(tab2, text="TBD", variable=m6)
    mheck6.place(x=220,y=185, height=25)
    mheck6.config(state=tk.DISABLED)
    
    
    #seperator
    separator = ttk.Separator(tab2, orient='horizontal')
    separator.place(x=10,y=200+30, width=455)
    
    """bars"""
    constant_label=tk.Label(tab2,text="Bar loads",justify="right", font="Verdana 8 bold")
    constant_label.place(x=10,y=220+30)
    
    # browses
    browse_button5 = tk.Button(tab2, text="Avg :", command=browse_path5, width=5,fg="black")
    browse_button5.place(x=10,y=40+210+30)
    path_entry5 = tk.Entry(tab2,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry5.place(x=70,y=40+210+31, height=25)
    
    browse_button6 = tk.Button(tab2, text="All :", command=browse_path6, width=5,fg="black", underline=0)
    browse_button6.place(x=10,y=80+210+30)
    path_entry6 = tk.Entry(tab2,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry6.place(x=70,y=80+210+31, height=25)
    
    #checks - metals
    m7,m8,m9,m10,m11,m12=tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar()
    m13,m14=tk.BooleanVar(),tk.BooleanVar()
    
    mheck7=tk.Checkbutton(tab2, text="Local Buckling", variable=m7)
    mheck7.place(x=220,y=125+210+30, height=25)
    
    mheck8=tk.Checkbutton(tab2, text="Strength", variable=m8, command=get_ultimate_choice)
    mheck8.place(x=70,y=155+210+30, height=25)
    
    mheck9=tk.Checkbutton(tab2, text="Durability", variable=m9)
    mheck9.place(x=70,y=125+210+90, height=25)
    mheck9.config(state=tk.DISABLED)
    
    mheck10=tk.Checkbutton(tab2, text="Crippling", variable=m10, underline=0)
    mheck10.place(x=70,y=155+210, height=25)
    
    mheck11=tk.Checkbutton(tab2, text="Flange Bending", variable=m11, underline=0)
    mheck11.place(x=220,y=155+210+30, height=25)
    # mheck11.config(state=tk.DISABLED)
    
    mheck13=tk.Checkbutton(tab2, text="TBD", variable=m13)
    mheck13.place(x=370,y=155+210+30, height=25)
    mheck13.config(state=tk.DISABLED)
    
    mheck14=tk.Checkbutton(tab2, text="TBD", variable=m14)
    mheck14.place(x=370,y=125+210+30, height=25)
    mheck14.config(state=tk.DISABLED)
    
    mheck12=tk.Checkbutton(tab2, text="Buckling - IR", variable=m12, underline=0)
    mheck12.place(x=220,y=125+210+90, height=25)
    
    #seperator
    separator = ttk.Separator(tab2, orient='horizontal')
    separator.place(x=10,y=200+210+60, width=455)
    
    """joint"""
    constant_label=tk.Label(tab2,text="Joint loads",justify="right", font="Verdana 8 bold")
    constant_label.place(x=10,y=220+210+60)
    
    # browses
    browse_button7 = tk.Button(tab2, text="Joint :", command=browse_path7, width=5,fg="black")
    browse_button7.place(x=10,y=40+210+210+60)
    path_entry7 = tk.Entry(tab2,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry7.place(x=70,y=40+210+210+61, height=25)
    
    #checks - metals
    m13,m14=tk.BooleanVar(),tk.BooleanVar()
    
    mheck13=tk.Checkbutton(tab2, text="Metallic\nBolted Joint", variable=m13, justify="left")
    mheck13.place(x=70,y=125+210+170+60, height=25)
    
    mheck14=tk.Checkbutton(tab2, text="TBD", variable=m14)
    mheck14.place(x=220,y=125+210+170+60, height=25)
    mheck14.config(state=tk.DISABLED)
    
# =============================================================================
# ---------------COMPOSITE FAILURES #starts at 8
# =============================================================================
    """shells"""
    constant_label=tk.Label(tab3,text="Shell loads",justify="right", font="Verdana 8 bold")
    constant_label.place(x=10,y=10)
    
    # browses
    browse_button8 = tk.Button(tab3, text="Avg :", command=browse_path8, width=5,fg="black")
    browse_button8.place(x=10,y=40)
    path_entry8 = tk.Entry(tab3,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry8.place(x=70,y=41, height=25)
    
    browse_button9 = tk.Button(tab3, text="All :", command=browse_path9, width=5,fg="black", underline=0)
    browse_button9.place(x=10,y=80)
    path_entry9 = tk.Entry(tab3,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry9.place(x=70,y=81, height=25)
    
    #checks - composites
    c1,c2,c3,c4,c5,c6,c7,c8=tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),\
                            tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar()
                            
    c9,c10,c11,c12,c13,c14,c15,c16=tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),\
                                    tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar()
    
    c23,c33=tk.BooleanVar(),tk.BooleanVar() #IR buckling with all loads
    
    check1=tk.Checkbutton(tab3, text="Unnotched", variable=c1, underline=0)
    check1.place(x=70,y=125, height=15)
    
    #-----------POPUP
    def get_energy_value():
        if c2.get()==1:
            popup=Toplevel(root)
            popup.title("Impact Energy")
            popup.geometry("244x80")
            
            try: popup.iconbitmap(r'//vds/alldept3/Analiz_T5200/T52G0/T24505/icons/c3.ico')
            except: pass
                
            popup.resizable(False,False)
            center_window(popup)
            tk.Label(popup,text="Enter the impact energy value (J) : ").place(x=10,y=10)
            
            #flat, groove, raised, ridge, solid, or sunken
            energy_entry=tk.Entry(popup,relief="solid",bd=1)
            energy_entry.place(x=200,y=11,width=30)
                
            def save_value():
                global energy_value
                energy_value=energy_entry.get()
                if energy_value=='' or energy_value==None: energy_value=55
                try: 
                    if float(energy_value)<=0: energy_value=55
                except: 
                    pass
                messagebox.showinfo("Impact Energy",f"Stored energy value is {energy_value} J.")
                popup.destroy()
            ttk.Button(popup, text="OK", command=save_value).place(x=92,y=45,width=60)
    #-----------POPUP
    
    check2=tk.Checkbutton(tab3, text="Transverse Residual", variable=c2, command=get_energy_value)
    check2.place(x=220,y=125, height=15)
    
    def message_openhole():
        if c33.get()==1:
            messagebox.showwarning("Open Hole Strength", "Beware that, this analysis is only applicable to holes with a diameter less than 150 mm.")
        
    check3=tk.Checkbutton(tab3, text="Buckling - Analytical", variable=c3, command=buckling_analytical_warning)
    # check33=tk.Checkbutton(tab3, text="Open Hole", variable=c33, command=message_openhole)
    check3.place(x=70,y=150+25, height=15)
    
    check33=tk.Checkbutton(tab3, text="Open Hole", variable=c33, command=message_openhole)
    check33.place(x=70,y=150+50, height=15)
    
    check4=tk.Checkbutton(tab3, text="Edge Residual", variable=c4)
    # check4.config(bitmap="info")
    check4.place(x=220,y=150, height=15)
    # check4.config(state=tk.DISABLED)
    
    
    #-----------POPUP
    def get_flow_angle():
        if c5.get()==1:
            messagebox.showwarning("Panel Flutter", "This analysis requires (any) average load input for only panel dimensions.")
            popup=Toplevel(root)
            popup.title("Flow Angle")
            popup.geometry("300x80")
            try: popup.iconbitmap(r'//vds/alldept3/Analiz_T5200/T52G0/T24505/icons/c3.ico')
            except: pass
            popup.resizable(False,False)
            center_window(popup)
            tk.Label(popup,text="Enter a flow angle value (0,15,30,45 degrees) : ").place(x=10,y=10)
            
            #flat, groove, raised, ridge, solid, or sunken
            angle_entry=tk.Entry(popup,relief="solid",bd=1)
            angle_entry.place(x=260,y=11,width=30)
                
            def save_value():
                global angle_value
                angle_value=int(angle_entry.get())
                if angle_value not in [0,15,30,45]: angle_value=45
                if angle_value==0: angle_value="0 degree"
                if angle_value==15: angle_value="15 degree"
                if angle_value==30: angle_value="30 degree"
                if angle_value==45: angle_value="45 degree"
                messagebox.showinfo("Flow Angle",f"Stored flow angle is {angle_value}.")
                popup.destroy()
        
            ttk.Button(popup, text="OK", command=save_value).place(x=122,y=45,width=60)
    #-----------POPUP
    
    check5=tk.Checkbutton(tab3, text="Panel Flutter", variable=c5, command=get_flow_angle)
    check5.place(x=370,y=125, height=15)
    # check5.config(state=tk.DISABLED)
    
    ritz_entry=tk.StringVar()
    # check6=tk.Checkbutton(tab3, text="Buckling - Ritz", variable=c6, command=buckling_ritz_path)
    check6=tk.Checkbutton(tab3, text="Buckling - Ritz", variable=c6, command=buckling_ritz_warning)
    check6.place(x=70,y=150, height=15)
    # check6.config(state=tk.DISABLED)
    
    check7=tk.Checkbutton(tab3, text="Interlaminar Shear", variable=c7, underline=0)
    check7.place(x=220,y=150+25, height=15)
    # check6.config(state=tk.DISABLED)
    
    def get_sandwich_inputs():
        if c8.get()==1:
            messagebox.showwarning("Sandwich", "This analysis requires both 'All' and 'Avg' loads.")
            popup=Toplevel(root)
            popup.title("Sandwich")
            popup.geometry("244x168")
            try: popup.iconbitmap(r'//vds/alldept3/Analiz_T5200/T52G0/T24505/icons/c3.ico')
            except: pass
            popup.resizable(False,False)
            center_window(popup)
            
            var=tk.IntVar(value="20")
            text="Ramp angle (deg): "
            text=text+(45-len(text))*"."
            tk.Label(popup,text=text).place(x=10,y=10)
            sandwich_angle_entry=tk.Entry(popup,relief="solid",bd=1,textvariable=var)
            sandwich_angle_entry.place(x=200,y=11,width=30)
            
            var=tk.StringVar(value="25")
            text="Ramp radius (mm): "
            text=text+(43-len(text))*"."
            tk.Label(popup,text=text).place(x=10,y=36)
            sandwich_radius_entry=tk.Entry(popup,relief="solid",bd=1,textvariable=var)
            sandwich_radius_entry.place(x=200,y=36,width=30)
            
            var=tk.StringVar(value="25")
            text="Impact Energy (J): "
            text=text+(47-len(text))*"."
            tk.Label(popup,text=text).place(x=10,y=61)
            #flat, groove, raised, ridge, solid, or sunken
            sandwich_energy_entry=tk.Entry(popup,relief="solid",bd=1,textvariable=var)
            sandwich_energy_entry.place(x=200,y=61,width=30)
            
            tk.Label(popup,text="Do Buckling Analysis ?").place(x=10,y=90)
            sandwich_buck=tk.StringVar(value="NO")
            sandwich_radio1=tk.Radiobutton(popup, text="YES", variable=sandwich_buck, value="YES")
            sandwich_radio1.place(x=140,y=90)
            sandwich_radio2=tk.Radiobutton(popup, text="NO", variable=sandwich_buck, value="NO")
            sandwich_radio2.place(x=186,y=90)
            
            def save_value():
                global sandwich_inputs #angle, radius, energy
                sandwich_inputs=[float(sandwich_angle_entry.get()),float(sandwich_radius_entry.get()),float(sandwich_energy_entry.get()),sandwich_buck.get()]
                              
                for i,val in enumerate(sandwich_inputs[:3]):
                    if val=="" or val==None or val<0: sandwich_inputs[i]=20
                
                messagebox.showinfo("Sandwich", "Inputs are stored !")
                print(f"SANDWICH - Inputs are -> {sandwich_inputs}")
                popup.destroy()
                
            ttk.Button(popup, text="OK", command=save_value).place(x=92,y=130,width=60)
            
    check8=tk.Checkbutton(tab3, text="Sandwich", variable=c8, command=get_sandwich_inputs,underline=len("Sandwich")-1)
    check8.place(x=220,y=155+45, height=15)
    # check8.config(state=tk.DISABLED)
    
    check23=tk.Checkbutton(tab3, text="Buckling - IR", variable=c23, underline=0,\
                           command=(lambda : messagebox.showinfo("Buckling - IR (Interrivet)","Beware that, having word 'spar' or 'rib' in your load-file-name is important for T4TOBIN to find out aligned bars and corresponding inputs. Otherwise it will proceed with a default option.")))
    check23.place(x=370,y=155+20, height=15)
    
    #seperator
    separator = ttk.Separator(tab3, orient='horizontal')
    separator.place(x=10,y=200+30, width=455)
    
    """bars"""
    constant_label=tk.Label(tab3,text="Bar loads",justify="right", font="Verdana 8 bold")
    constant_label.place(x=10,y=220+30)
    
    # browses
    browse_button10 = tk.Button(tab3, text="Avg :", command=browse_path10, width=5,fg="black")
    browse_button10.place(x=10,y=40+210+30)
    path_entry10 = tk.Entry(tab3,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry10.place(x=70,y=40+210+31, height=25)
    
    browse_button11 = tk.Button(tab3, text="All :", command=browse_path11, width=5,fg="black", underline=0)
    browse_button11.place(x=10,y=80+210+30)
    path_entry11 = tk.Entry(tab3,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry11.place(x=70,y=80+210+31, height=25)
    
    #checks - composites
    check9=tk.Checkbutton(tab3, text="Local Buckling", variable=c9)
    check9.place(x=220,y=125+210+30, height=25)
    
    check10=tk.Checkbutton(tab3, text="Unfolding", variable=c10, underline=0,\
                           command=lambda : messagebox.showinfo("Unfolding","Enter your -flange loads- path into 'All' please. Also beware that 'Q' value will be taken as 0 (zero) for now."))
    check10.place(x=70,y=155+210+30, height=25)
    
    check11=tk.Checkbutton(tab3, text="Buckling - IR", variable=c11, underline=0)
    check11.place(x=370,y=155+210+30, height=25)
    
    check12=tk.Checkbutton(tab3, text="Edge Residual", variable=c12)
    check12.place(x=220,y=155+210+30, height=25)
    
    check13=tk.Checkbutton(tab3, text="TBD", variable=c13)
    check13.place(x=370,y=125+210+30, height=25)
    check13.config(state=tk.DISABLED)
    
    check14=tk.Checkbutton(tab3, text="Crippling", variable=c14, underline=0)
    check14.place(x=70,y=125+210+30, height=25)
    # check14.config(state=tk.DISABLED)
    
    check15=tk.Checkbutton(tab3, text="TBD", variable=c15)
    check15.place(x=70,y=155+210+60, height=25)
    check15.config(state=tk.DISABLED)
    
    check16=tk.Checkbutton(tab3, text="Interlaminar Shear", variable=c16, underline=0)
    check16.place(x=220,y=155+210+60, height=25)
    
    # seperator
    separator = ttk.Separator(tab3, orient='horizontal')
    separator.place(x=10,y=200+210+60, width=455)
    
    """joint"""
    constant_label=tk.Label(tab3,text="Joint loads",justify="right", font="Verdana 8 bold")
    constant_label.place(x=10,y=220+210+60)
    
    # browses
    browse_button12 = tk.Button(tab3, text="Joint :", command=browse_path12, width=5,fg="black")
    browse_button12.place(x=10,y=40+210+210+60)
    path_entry12 = tk.Entry(tab3,width=65, font=("Colossal",8),relief="sunken",bd=2)
    path_entry12.place(x=70,y=40+210+210+61, height=25)
    
    # joints
    c19,c20,c21,c22=tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar(),tk.BooleanVar()
    
    check20=tk.Checkbutton(tab3, text="Composite\nBolted Joint", variable=c20, justify="left")
    check20.place(x=70,y=125+210+170+60, height=25)
     
    check21=tk.Checkbutton(tab3, text="Repairability", variable=c21)
    check21.place(x=370,y=150, height=15)
    
    check22=tk.Checkbutton(tab3, text="IR Buckling", variable=c22)
    check22.place(x=370,y=125+210+170+60, height=25)
    check22.config(state=tk.DISABLED)
    
    check19=tk.Checkbutton(tab3, text="Composite (Flanges)\nBolted Joint", variable=c19, justify="left")
    check19.place(x=220,y=125+210+170+60, height=25)
    # check22.config(state=tk.DISABLED)
    
    # =============================================================================
    # ------------ M I S C
    # =============================================================================
    
    """misc"""
    
    constant_label=tk.Label(tab4,text="Choose where TTB results are located,",justify="right", 
                            font="Verdana 8 italic")
    constant_label.place(x=10,y=10)

    # browses
    sum_button = tk.Button(tab4, text="dir :", command=browse_path_sum, width=5,fg="black")
    sum_button.place(x=10,y=40)
    sum_file = tk.Entry(tab4,width=65, font=("Colossal",8),relief="sunken",bd=2)
    sum_file.place(x=70,y=41, height=25)
    
    gen_button= tk.Button(tab4, text="Generate", command=get_summary, font=("Colossal 8 bold"),width=15,fg="black")
    gen_button.place(x=349,y=80)
    
    info_label=tk.Label(tab4,text="(SUMMARY FILE)", font="Verdana 7 bold")
    info_label.place(x=10,y=80)
    
    separator = ttk.Separator(tab4, orient='horizontal')
    separator.place(x=10,y=120, width=455)
    
    #plot
    plot_label=tk.Label(tab4,text="Choose TTB_summary.xlsx file,",justify="right", 
                            font="Verdana 8 italic")
    plot_label.place(x=10,y=130)
    
    plot_file = tk.Button(tab4, text="sum :", command=browse_path_plot, width=5,fg="black")
    plot_file.place(x=10,y=160)
    plot_file = tk.Entry(tab4,width=65, font=("Colossal",8),relief="sunken",bd=2)
    plot_file.place(x=70,y=161, height=25)
    
    
    bdf_label=tk.Label(tab4,text="Choose related .bdf file,",justify="right", 
                            font="Verdana 8 italic")
    bdf_label.place(x=10,y=210)
    
    bdf_file = tk.Button(tab4, text="bdf :", command=browse_path_plot3, width=5,fg="black")
    bdf_file.place(x=10,y=240)
    bdf_file = tk.Entry(tab4,width=65, font=("Colossal",8),relief="sunken",bd=2)
    bdf_file.place(x=70,y=241, height=25)
    
    plot_button= tk.Button(tab4, text="S-Plot", command=plot_summary, font=("Colossal 8 bold"),width=15,fg="black")
    plot_button.place(x=349,y=280)
    
    info_label=tk.Label(tab4,text="(SUMMARY PLOT)", font="Verdana 7 bold")
    info_label.place(x=10,y=280)
    
    
    separator = ttk.Separator(tab4, orient='horizontal')
    separator.place(x=10,y=320, width=455)
    
    #plot
    plot_label=tk.Label(tab4,text="Choose Misc.xlsx file,",justify="right", 
                            font="Verdana 8 italic")
    plot_label.place(x=10,y=330)
    
    misc_file = tk.Button(tab4, text="Misc :", command=browse_path_plot2, width=5,fg="black")
    misc_file.place(x=10,y=360)
    misc_file = tk.Entry(tab4,width=65, font=("Colossal",8),relief="sunken",bd=2)
    misc_file.place(x=70,y=361, height=25)
    
    
    bdf_label=tk.Label(tab4,text="Choose related .bdf file,",justify="right", 
                            font="Verdana 8 italic")
    bdf_label.place(x=10,y=410)
    
    bdf_file2 = tk.Button(tab4, text="bdf :", command=browse_path_plot4, width=5,fg="black")
    bdf_file2.place(x=10,y=440)
    bdf_file2 = tk.Entry(tab4,width=65, font=("Colossal",8),relief="sunken",bd=2)
    bdf_file2.place(x=70,y=441, height=25)
    
    plot_button2= tk.Button(tab4, text="F-Plot", command=plot_fastener, font=("Colossal 8 bold"),width=15,fg="black")
    plot_button2.place(x=349,y=480)
    
    info_label=tk.Label(tab4,text="(FASTENER PLOT)", font="Verdana 7 bold")
    info_label.place(x=10,y=480)
    
    
# =============================================================================
# ------------ABOUT
# =============================================================================
    
    notifications_y=10

    constant_label=tk.Label(tab5,text=f"WELCOME {os.getlogin()} !\n\nThis is the Tail-Toolbox-Interface-2 a.k.a. T4TOBIN \n\nIts aim is to minimize errors, make output files standard\nand reduce time spend in the GFEM sizing process.",
                            justify="left", font="Verdana 8")
    constant_label.place(x=10,y=notifications_y)
    
    
    constant_label2=tk.Label(tab5,text="Some notifications:",
                            justify="left", font="Verdana 8 underline")
    constant_label2.place(x=10,y=notifications_y+105)
    
    try:
        useful_path=r'\\vds\alldept3\Analiz_T5200\T52G0\02-BLOCK_10\03-Failure_Modes'
        clickable_label=tk.Label(tab5,text="* Click here for information about the analysis strategy.", cursor="hand2",
                                justify="left", font="Verdana 8 bold", fg="black")
        clickable_label.place(x=10,y=notifications_y+130)
        clickable_label.bind("<Button-1>", lambda e: open_directory(useful_path))
    except:
        pass        
    
    # useful_path2=r'//vds/alldept3/Analiz_T5200/T52G0/T24505/icons/ASC Static-Tails_20241204.xlsx'
    # clickable_label=tk.Label(tab5,text="* Tell me a random ASC Requirement.", cursor="hand2",
    #                         justify="left", font="Verdana 8 bold", fg="black")
    # clickable_label.place(x=10,y=notifications_y+150)
    # clickable_label.bind("<Button-1>", lambda e: random_requirement(useful_path2))
    
    note1=tk.Label(tab5,text="- 'Panel flutter' needs average load excel to fulfill panel lengths.", font="Verdana 8", fg="black")
    note1.place(x=10,y=notifications_y+150)
    note2=tk.Label(tab5,text="- 'Buckling' is the analytical one and needs toolbox v4.06 or similar.", font="Verdana 8", fg="black")
    note2.place(x=10,y=notifications_y+170)
    note3=tk.Label(tab5,text="- 'Strength' calculations are based on N-sigma Mises stress.", font="Verdana 8", fg="black")
    note3.place(x=10,y=notifications_y+190)
    note5=tk.Label(tab5,text="- Do not exceed the maximum input size for excel (circa 1 million rows).", font="Verdana 8", fg="black")
    note5.place(x=10,y=notifications_y+210)
    note6=tk.Label(tab5,text="- Do not try to open two toolboxes in different directories.", font="Verdana 8", fg="black")
    note6.place(x=10,y=notifications_y+230)
    # seperator (probably sizing)
    
    constant_label3=tk.Label(tab5,text="Latest updates (v4.00):",
                            justify="left", font="Verdana 8 underline")
    constant_label3.place(x=10,y=notifications_y+270)
    
    updates=[
             "-ML addition: mbj"
             "-ML model: cbj & ritz",
             "-Sandwich analysis has been added.",
             "-Open Hole, Flange Bending, Unfolding, CBJ Flanges addition",
             "-Various composite bar failure adjustments.",
             "-Local buckling has been added.",
             "-Shim thickness is now a user option.",
             ]
    
    update_y=notifications_y+270
    for update in updates:
        update1=tk.Label(tab5,text=update, font="Verdana 8", fg="black")
        update_y+=20
        update1.place(x=10,y=update_y)
    # try:
    #     base_path = sys._MEIPASS
    #     print(base_path)
    #     root.iconbitmap(os.path.join(base_path, "MSReportBuilder.exe.0.ico"))
    # except Exception:
    #     root.iconbitmap('//vds/alldept3/Analiz_T5200/T52G0/T24505/icons/MSReportBuilder.exe.0.ico')
    
    
    # info_button = tk.Button(tab5, text="Remind me a requirement", command=main, font=("Colossal 10"), #Times bold
    #                             width=20,height=1,fg="black", relief="raised", bd=2)
    # info_button.place(x=155,y=512+60)
    
    # '//vds/alldept3/Analiz_T5200/T52G0/T24505/icons/ASC Static-Tails_20241204.xlsx'
# =============================================================================
# NOTES
# clear sheets by taking their row numbers
# mbj için bar mat al web mat değil
# crippling section 0.32 orani ?
# ir buckling icin ele bazli gitmek lazım 
# temporary file error ?
# =============================================================================
    
    try: root.iconbitmap(r'//vds/alldept3/Analiz_T5200/T52G0/T24505/icons/c3.ico')
    except: pass

    root.mainloop()
    sys.exit(0)
    # update_thread.join()
